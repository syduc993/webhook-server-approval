import json
from app.core.config.settings import settings
# [THAY ƒê·ªîI] Import c√°c h√†m helper m·ªõi t·ª´ node_config
from app.core.config.node_config import get_workflow_config, get_field_mapping, get_qr_trigger_config
from app.core.infrastructure.lark_service import lark_service
from app.core.infrastructure.cache_service import cache_service
from app.core.utils.field_extractor import FieldExtractor
from app.domains.qr_generation.services.vietqr_service import vietqr_service
from app.domains.qr_generation.models import QRType, BankInfo
from typing import Dict, Any

class QRProcessor:
    """
    B·ªô x·ª≠ l√Ω QR ch√≠nh - Qu·∫£n l√Ω logic nghi·ªáp v·ª• t·∫°o v√† x·ª≠ l√Ω m√£ QR cho h·ªá th·ªëng ph√™ duy·ªát.
    
    [N√ÇNG C·∫§P] Class n√†y gi·ªù ƒë√¢y ƒë·ªçc c·∫•u h√¨nh ƒë·ªông t·ª´ APPROVAL_WORKFLOWS ƒë·ªÉ h·ªó tr·ª£
    nhi·ªÅu quy tr√¨nh ph√™ duy·ªát kh√°c nhau.
    
    Attributes:
        field_extractor (FieldExtractor): B·ªô tr√≠ch xu·∫•t tr∆∞·ªùng d·ªØ li·ªáu t·ª´ form.
    """

    def __init__(self):
        """Kh·ªüi t·∫°o QRProcessor v·ªõi c√°c service c·∫ßn thi·∫øt."""
        self.field_extractor = FieldExtractor()

    def validate_amount_value(self, amount_value) -> dict:
        """
        Validate v√† chuy·ªÉn ƒë·ªïi gi√° tr·ªã s·ªë ti·ªÅn.
        """
        try:
            if amount_value is None:
                return {'valid': False, 'amount': None, 'error': 'S·ªë ti·ªÅn kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng'}
            
            amount_float = float(amount_value)
            amount_int = int(amount_float)
            
            if amount_int <= 0:
                return {'valid': False, 'amount': amount_int, 'error': 'S·ªë ti·ªÅn ph·∫£i l·ªõn h∆°n 0'}
                
            return {'valid': True, 'amount': amount_int, 'error': None}
            
        except (ValueError, TypeError) as e:
            return {'valid': False, 'amount': None, 'error': f'ƒê·ªãnh d·∫°ng s·ªë ti·ªÅn kh√¥ng h·ª£p l·ªá: {str(e)}'}

    def _find_active_qr_trigger(self, task_list: list, form_data: list, qr_trigger_configs: list) -> Dict[str, Any]:
        """
        [H√ÄM M·ªöI] T√¨m ki·∫øm node ƒëang ho·∫°t ƒë·ªông kh·ªõp v·ªõi c√°c ƒëi·ªÅu ki·ªán trong c·∫•u h√¨nh qr_trigger_nodes.
        """
        # T·∫°o m·ªôt map ƒë·ªÉ tra c·ª©u c√°c node theo t√™n
        nodes_by_name = {}
        for task in task_list:
            node_name = task.get('node_name', '')
            if node_name not in nodes_by_name:
                nodes_by_name[node_name] = []
            nodes_by_name[node_name].append(task)
            
        # Duy·ªát qua t·ª´ng c·∫•u h√¨nh trigger (v√≠ d·ª•: m·ªôt cho t·∫°m ·ª©ng, m·ªôt cho thanh to√°n)
        for trigger_config in qr_trigger_configs:
            node_name_contains = trigger_config.get("node_name_contains")
            required_status = trigger_config.get("status")

            # T√¨m t·∫•t c·∫£ c√°c node c√≥ t√™n kh·ªõp v·ªõi c·∫•u h√¨nh
            matching_nodes = []
            for name, nodes in nodes_by_name.items():
                if node_name_contains in name:
                    matching_nodes.extend(nodes)

            print(f"üîç T√¨m th·∫•y {len(matching_nodes)} node c√≥ t√™n ch·ª©a '{node_name_contains}'.")

            # L·∫∑p qua c√°c node ƒë√£ t√¨m th·∫•y ƒë·ªÉ ki·ªÉm tra ƒëi·ªÅu ki·ªán
            for i, node in enumerate(matching_nodes, 1):
                node_id = node.get('node_id')
                node_status = node.get('status')
                print(f"   - Ki·ªÉm tra l·∫ßn {i} (Node ID: {node_id[:8]}..., Tr·∫°ng th√°i: {node_status})...")

                if node_status == required_status:
                    # L·∫•y template t·ª´ config ƒë·ªÉ t·∫°o t√™n tr∆∞·ªùng ƒë·ªông
                    yes_no_field_template = trigger_config.get("yes_no_field_template")
                    amount_field_template = trigger_config.get("amount_field_template")

                    yes_no_field_name = yes_no_field_template.format(i=i)
                    amount_field_name = amount_field_template.format(i=i)

                    yes_no_value = self.field_extractor.extract_field_value(form_data, yes_no_field_name)
                    
                    if yes_no_value == "Yes":
                        print(f"     ‚úÖ ƒêi·ªÅu ki·ªán th·ªèa m√£n: Node {required_status} v√† ng∆∞·ªùi d√πng ch·ªçn 'Yes'.")
                        amount_value = self.field_extractor.extract_field_value(form_data, amount_field_name)
                        
                        return {
                            "amount": amount_value,
                            "node_id": node_id,
                            "node_name": node.get('node_name'),
                            "qr_type": trigger_config.get("qr_type", "unknown"),
                            "field_used": amount_field_name,
                            "trigger_round": i
                        }
                    else:
                        print(f"     - B·ªè qua: Ng∆∞·ªùi d√πng kh√¥ng ch·ªçn 'Yes' cho l·∫ßn {i} (Gi√° tr·ªã: {yes_no_value}).")
                else:
                    print(f"     - B·ªè qua: Tr·∫°ng th√°i node kh√¥ng ph·∫£i {required_status}.")

        return None # Kh√¥ng t√¨m th·∫•y trigger n√†o ho·∫°t ƒë·ªông

    # [THAY ƒê·ªîI] Signature c·ªßa h√†m ƒë√£ thay ƒë·ªïi ƒë·ªÉ nh·∫≠n approval_code
    async def process_approval_with_qr_comment(self, instance_code: str, approval_code: str, access_token: str) -> bool:
        """
        [N√ÇNG C·∫§P] X·ª≠ l√Ω ph√™ duy·ªát b·∫±ng c√°ch ƒë·ªçc c·∫•u h√¨nh ƒë·ªông d·ª±a tr√™n approval_code.
        """
        try:
            # B∆∞·ªõc 1: L·∫•y c·∫•u h√¨nh cho quy tr√¨nh hi·ªán t·∫°i
            workflow_config = get_workflow_config(approval_code)
            if not workflow_config:
                print(f"‚ùå Kh√¥ng t√¨m th·∫•y c·∫•u h√¨nh cho quy tr√¨nh '{approval_code}'. B·ªè qua.")
                return True # Coi nh∆∞ th√†nh c√¥ng v√¨ kh√¥ng c√≥ g√¨ ƒë·ªÉ l√†m

            print(f"‚öôÔ∏è √Åp d·ª•ng c·∫•u h√¨nh cho quy tr√¨nh: {workflow_config.get('name')}")

            # B∆∞·ªõc 2: L·∫•y th√¥ng tin chi ti·∫øt c·ªßa instance
            api_response = await lark_service.get_approval_instance(instance_code, access_token)
            if not api_response or 'data' not in api_response:
                print(f"‚ùå Kh√¥ng th·ªÉ l·∫•y th√¥ng tin instance {instance_code}")
                return False
            
            task_list = api_response['data'].get('task_list', [])
            form_data = json.loads(api_response['data'].get('form', '[]'))

            # B∆∞·ªõc 3: [LOGIC M·ªöI] T√¨m node ƒëang ho·∫°t ƒë·ªông d·ª±a tr√™n c·∫•u h√¨nh
            qr_trigger_configs = workflow_config.get('qr_trigger_nodes', [])
            active_trigger_info = self._find_active_qr_trigger(task_list, form_data, qr_trigger_configs)

            if not active_trigger_info:
                print(f"‚è≠Ô∏è Kh√¥ng c√≥ trigger t·∫°o QR n√†o ƒëang ho·∫°t ƒë·ªông cho instance {instance_code}. B·ªè qua.")
                return True

            # B∆∞·ªõc 4: Tr√≠ch xu·∫•t th√¥ng tin t·ª´ trigger ƒë√£ t√¨m th·∫•y
            matching_node_id = active_trigger_info['node_id']
            qr_type = active_trigger_info['qr_type']
            amount_value = active_trigger_info['amount']
            field_used = active_trigger_info['field_used']
            node_name = active_trigger_info['node_name']
            trigger_round = active_trigger_info['trigger_round']
            
            # B∆∞·ªõc 5: Ki·ªÉm tra duplicate TR∆Ø·ªöC KHI t·∫°o QR
            if cache_service.is_qr_recently_generated(
                instance_code, matching_node_id, qr_type, 
                settings.QR_CACHE_DURATION_MINUTES
            ):
                print(f"‚ö†Ô∏è PH√ÅT HI·ªÜN TR√ôNG L·∫∂P: QR {qr_type.upper()} cho node {node_name} ƒë√£ ƒë∆∞·ª£c t·∫°o g·∫ßn ƒë√¢y.")
                return True
            
            print(f"üí∞ Chi ti·∫øt t·∫°o QR cho l·∫ßn {trigger_round}:")
            print(f"   - Lo·∫°i: {qr_type}")
            print(f"   - S·ªë ti·ªÅn: {amount_value}")
            print(f"   - Tr∆∞·ªùng s·ª≠ d·ª•ng: {field_used}")
            print(f"   - Node k√≠ch ho·∫°t: {node_name} ({matching_node_id[:8]}...)")
            
            # B∆∞·ªõc 6: Validate s·ªë ti·ªÅn
            amount_validation = self.validate_amount_value(amount_value)
            if not amount_validation['valid']:
                print(f"‚ùå S·ªë ti·ªÅn kh√¥ng h·ª£p l·ªá: {amount_validation['error']}")
                return False
            amount_int = amount_validation['amount']

            # B∆∞·ªõc 7: [LOGIC M·ªöI] Tr√≠ch xu·∫•t th√¥ng tin ng√¢n h√†ng t·ª´ field_mappings
            field_mappings = workflow_config.get('field_mappings', {})
            bank_id_field = field_mappings.get('bank_name')
            account_no_field = field_mappings.get('account_number')
            account_name_field = field_mappings.get('beneficiary_name')

            if not all([bank_id_field, account_no_field, account_name_field]):
                 print(f"‚ùå L·ªói c·∫•u h√¨nh: Thi·∫øu 'bank_name', 'account_number', ho·∫∑c 'beneficiary_name' trong field_mappings c·ªßa quy tr√¨nh {approval_code}.")
                 return False

            bank_id = self.field_extractor.extract_field_value(form_data, bank_id_field)
            account_no = self.field_extractor.extract_field_value(form_data, account_no_field)
            account_name = self.field_extractor.extract_field_value(form_data, account_name_field)

            if not all([bank_id, account_no, account_name]):
                missing = [f for f, v in {bank_id_field: bank_id, account_no_field: account_no, account_name_field: account_name}.items() if not v]
                print(f"‚ùå Thi·∫øu th√¥ng tin ng√¢n h√†ng tr√™n form: {', '.join(missing)}")
                return False
            
            # B∆∞·ªõc 8: T·∫°o m√¥ t·∫£ QR
            description = vietqr_service.generate_qr_description(f"{qr_type}{trigger_round}", instance_code)
            
            # B∆∞·ªõc 9: T·∫°o VietQR code
            qr_image_buffer = vietqr_service.create_qr_in_memory(
                bank_id, account_no, amount_int, description, account_name
            )
            if not qr_image_buffer:
                print("‚ùå Kh√¥ng th·ªÉ t·∫°o m√£ VietQR")
                return False
            
            # B∆∞·ªõc 10: Upload ·∫£nh l√™n Lark
            filename = f"{instance_code}_{qr_type}{trigger_round}_qr.png"
            upload_result = await lark_service.upload_image_to_approval(qr_image_buffer, filename, access_token)
            if not upload_result['success']:
                print(f"‚ùå Upload th·∫•t b·∫°i: {upload_result['error']}")
                return False
            
            # B∆∞·ªõc 11: ƒê√°nh d·∫•u ƒë√£ t·∫°o QR
            cache_service.mark_qr_as_generated(instance_code, matching_node_id, qr_type)
            
            # B∆∞·ªõc 12: T·∫°o comment
            comment_result = await lark_service.create_enhanced_comment_with_image(
                instance_code=instance_code,
                file_url=upload_result['file_url'],
                file_code=upload_result['file_code'],
                filename=filename,
                qr_type=f"{qr_type.capitalize()} L·∫ßn {trigger_round}",
                amount=amount_int,
                node_name=node_name,
                access_token=access_token
            )
            
            if comment_result['success']:
                print(f"‚úÖ Ho√†n th√†nh x·ª≠ l√Ω ph√™ duy·ªát {instance_code}")
                return True
            else:
                print(f"‚ùå T·∫°o comment th·∫•t b·∫°i: {comment_result['error']}")
                return False
                
        except Exception as e:
            print(f"‚ùå L·ªói nghi√™m tr·ªçng khi x·ª≠ l√Ω ph√™ duy·ªát: {e}")
            import traceback
            traceback.print_exc()
            return False

qr_processor = QRProcessor()













# class QRProcessor:
#     """
#     B·ªô x·ª≠ l√Ω QR ch√≠nh - Qu·∫£n l√Ω logic nghi·ªáp v·ª• t·∫°o v√† x·ª≠ l√Ω m√£ QR cho h·ªá th·ªëng ph√™ duy·ªát.
    
#     Class n√†y x·ª≠ l√Ω to√†n b·ªô quy tr√¨nh t·ª´ vi·ªác ki·ªÉm tra node ph√™ duy·ªát, tr√≠ch xu·∫•t d·ªØ li·ªáu,
#     validate th√¥ng tin, t·∫°o m√£ VietQR v√† upload l√™n h·ªá th·ªëng Lark.
    
#     Attributes:
#         field_extractor (FieldExtractor): B·ªô tr√≠ch xu·∫•t tr∆∞·ªùng d·ªØ li·ªáu t·ª´ form
#     """

#     def __init__(self):
#         """Kh·ªüi t·∫°o QRProcessor v·ªõi c√°c service c·∫ßn thi·∫øt."""
#         self.field_extractor = FieldExtractor()
#         # self.amount_detector kh√¥ng c√≤n c·∫ßn thi·∫øt n·ªØa
#         # self.amount_detector = AmountDetector()

#     # --- H√ÄM C≈® N√ÄY V·∫™N GI·ªÆ L·∫†I NH∆ØNG KH√îNG ƒê∆Ø·ª¢C G·ªåI TRONG H√ÄM CH√çNH ---
#     def check_pending_allowed_node_in_task_list(self, api_response: dict, node_config: dict = None) -> dict:
#         """
#         Ki·ªÉm tra node c√≥ tr·∫°ng th√°i ph√π h·ª£p v√† ƒë√°p ·ª©ng c√°c ƒëi·ªÅu ki·ªán b·ªï sung.
#         (H√†m n√†y kh√¥ng c√≤n ƒë∆∞·ª£c s·ª≠ d·ª•ng trong lu·ªìng ch√≠nh t·∫°o QR ƒë·ªông)
#         """
#         if node_config is None:
#             node_config = NODE_CONFIG
#         # ... logic c·ªßa h√†m c≈© gi·ªØ nguy√™n ...
#         try:
#             # Tr√≠ch xu·∫•t d·ªØ li·ªáu t·ª´ API response
#             data = api_response.get('data', {})
#             task_list = data.get('task_list', [])
#             configured_node_ids = list(node_config.keys())
            
#             # T·∫°o map ƒë·ªÉ tra c·ª©u nhanh tr·∫°ng th√°i c·ªßa c√°c node
#             node_status_map = {}
#             for task in task_list:
#                 node_id = task.get('node_id')
#                 status = task.get('status', 'UNKNOWN')
#                 if node_id:
#                     node_status_map[node_id] = status
            
#             print(f"üîç ƒêang ki·ªÉm tra c√°c node v·ªõi ƒëi·ªÅu ki·ªán b·ªï sung:")
#             for node_id, config in node_config.items():
#                 required_status = config.get('required_status', 'PENDING')
#                 additional_conditions = config.get('additional_conditions', [])
#                 print(f"   ‚Ä¢ {node_id[:8]}... - {config['name']} (y√™u c·∫ßu: {required_status})")
#                 if additional_conditions:
#                     for condition in additional_conditions:
#                         print(f"     + ƒêi·ªÅu ki·ªán th√™m: {condition['node_id'][:8]}... ph·∫£i ·ªü tr·∫°ng th√°i {condition['required_status']}")
            
#             print(f"üìã Danh s√°ch task ch·ª©a {len(task_list)} nhi·ªám v·ª•")
            
#             matching_configured_nodes = []
            
#             # Duy·ªát qua t·ª´ng node ƒë√£ c·∫•u h√¨nh
#             for node_id in configured_node_ids:
#                 config = node_config[node_id]
#                 required_status = config.get('required_status', 'PENDING')
#                 current_status = node_status_map.get(node_id, 'NOT_FOUND')
                
#                 # Ki·ªÉm tra ƒëi·ªÅu ki·ªán ch√≠nh
#                 if current_status != required_status:
#                     continue
                    
#                 # Ki·ªÉm tra c√°c ƒëi·ªÅu ki·ªán b·ªï sung
#                 additional_conditions = config.get('additional_conditions', [])
#                 all_conditions_met = True
                
#                 for condition in additional_conditions:
#                     condition_node_id = condition['node_id']
#                     condition_required_status = condition['required_status']
#                     condition_current_status = node_status_map.get(condition_node_id, 'NOT_FOUND')
                    
#                     print(f"üîç Ki·ªÉm tra ƒëi·ªÅu ki·ªán b·ªï sung: {condition_node_id[:8]}... ")
#                     print(f"   Y√™u c·∫ßu: {condition_required_status}, Hi·ªán t·∫°i: {condition_current_status}")
                    
#                     if condition_current_status != condition_required_status:
#                         all_conditions_met = False
#                         print(f"‚ùå ƒêi·ªÅu ki·ªán b·ªï sung kh√¥ng ƒë√°p ·ª©ng cho {node_id[:8]}...")
#                         break
#                     else:
#                         print(f"‚úÖ ƒêi·ªÅu ki·ªán b·ªï sung ƒë√£ ƒë√°p ·ª©ng")
                
#                 # N·∫øu t·∫•t c·∫£ ƒëi·ªÅu ki·ªán ƒë·ªÅu th·ªèa m√£n
#                 if all_conditions_met:
#                     matching_configured_nodes.append({
#                         'node_id': node_id,
#                         'config': config,
#                         'strategy': config['strategy'],
#                         'matched_status': current_status,
#                         'required_status': required_status,
#                         'additional_conditions_met': True
#                     })
#                     print(f"‚úÖ T√¨m th·∫•y node ph√π h·ª£p: {node_id[:8]}... ({config['name']}) - Tr·∫°ng th√°i: {current_status}")
            
#             # Tr·∫£ v·ªÅ node ph√π h·ª£p ƒë·∫ßu ti√™n
#             if matching_configured_nodes:
#                 first_matching = matching_configured_nodes[0]
#                 return {
#                     'found': True,
#                     'node_id': first_matching['node_id'],
#                     'node_config': first_matching['config'],
#                     'strategy': first_matching['strategy'],
#                     'matched_status': first_matching['matched_status'],
#                     'required_status': first_matching['required_status'],
#                     'all_tasks': task_list,
#                     'all_matching_configured': matching_configured_nodes,
#                     'node_status_map': node_status_map
#                 }
#             else:
#                 print(f"‚ùå Kh√¥ng t√¨m th·∫•y node n√†o ƒë√°p ·ª©ng t·∫•t c·∫£ ƒëi·ªÅu ki·ªán")
#                 return {
#                     'found': False,
#                     'node_id': None,
#                     'node_config': None,
#                     'strategy': None,
#                     'matched_status': None,
#                     'all_tasks': task_list,
#                     'all_matching_configured': [],
#                     'node_status_map': node_status_map
#                 }
            
#         except Exception as e:
#             print(f"‚ùå L·ªói khi ki·ªÉm tra node: {e}")
#             return {
#                 'found': False,
#                 'error': str(e),
#                 'all_tasks': [],
#                 'all_matching_configured': []
#             }