================================================================================
TH√îNG TIN D·ª∞ √ÅN HO√ÄN CH·ªàNH
================================================================================
Th·ªùi gian t·∫°o: 2025-09-15 15:59:24
Th∆∞ m·ª•c g·ªëc: d:\Atino\extension\webhook-server-approval
================================================================================

üìÅ C·∫§U TR√öC THU M·ª§C
--------------------------------------------------
‚îú‚îÄ‚îÄ üìÅ app/
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ config/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ node_config.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ settings.py
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ models/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ approval.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ event.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ response.py
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ routers/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ config.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ debug.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ manual.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ webhook.py
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ services/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ cache_service.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ lark_service.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ qr_processor.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ validation_service.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ vietqr_service.py
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ utils/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ amount_detector.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ field_extractor.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ helpers.py
‚îú‚îÄ‚îÄ üìÑ .gitignore
‚îú‚îÄ‚îÄ üìÑ Dockerfile
‚îú‚îÄ‚îÄ üìÑ Get detail code.ipynb
‚îú‚îÄ‚îÄ üìÑ project_complete_info.txt
‚îú‚îÄ‚îÄ üìÑ README.md
‚îî‚îÄ‚îÄ üìÑ requirements.txt


üìÑ DANH S√ÅCH T·∫§T C·∫¢ FILE
--------------------------------------------------
.gitignore (594 bytes)
app\config\node_config.py (2877 bytes)
app\config\settings.py (1261 bytes)
app\models\approval.py (1584 bytes)
app\models\event.py (899 bytes)
app\models\response.py (1015 bytes)
app\routers\config.py (1637 bytes)
app\routers\debug.py (3444 bytes)
app\routers\manual.py (2574 bytes)
app\routers\webhook.py (1789 bytes)
app\services\cache_service.py (4384 bytes)
app\services\lark_service.py (8266 bytes)
app\services\qr_processor.py (15166 bytes)
app\services\validation_service.py (8994 bytes)
app\services\vietqr_service.py (3010 bytes)
app\utils\amount_detector.py (10152 bytes)
app\utils\field_extractor.py (4442 bytes)
app\utils\helpers.py (2198 bytes)
Dockerfile (726 bytes)
Get detail code.ipynb (9345 bytes)
project_complete_info.txt (0 bytes)
README.md (779 bytes)
requirements.txt (136 bytes)

T·ªïng c·ªông: 23 file

üíª N·ªòI DUNG T·∫§T C·∫¢ FILE CODE
================================================================================

============================================================
FILE: app\config\node_config.py
============================================================
"""Node configuration for different approval workflows"""

NODE_CONFIG = {
    "30e5338b60587c64c7cef5f6a7211ccb": {
        "name": "truong_phong_duyet",
        "type": "dual_detection",
        "advance_field": "S·ªë ti·ªÅn t·∫°m ·ª©ng",
        "payment_field": "S·ªë ti·ªÅn thanh to√°n",
        "strategy": "detect_both_fields",
        "required_status": "PENDING",
        "description": "Tr∆∞·ªüng ph√≤ng duy·ªát - Auto detect advance/payment"
    },
    "f23535375a26847ef71c1cbf0755f246": {
        "name": "thanh_toan_sau_tam_ung", 
        "type": "payment_only",
        "advance_field": None,
        "payment_field": "S·ªë ti·ªÅn c√≤n ph·∫£i thanh to√°n",
        "strategy": "payment_field_only",
        "required_status": "APPROVED",
        "additional_conditions": [
            {
                "node_id": "ef83b231885a1a77658f32808a199764",
                "required_status": "PENDING",
                "description": "Node ti·∫øp theo ph·∫£i PENDING"
            }
        ],
        "description": "Thanh to√°n sau t·∫°m ·ª©ng - Payment only (trigger on APPROVED + next node PENDING)"
    }
}

def get_node_config(node_id: str) -> dict:
    """
    L·∫•y configuration cho m·ªôt node_id c·ª• th·ªÉ
    
    Args:
        node_id (str): Node ID c·∫ßn l·∫•y config
        
    Returns:
        dict: Node config ho·∫∑c None n·∫øu kh√¥ng t√¨m th·∫•y
    """
    return NODE_CONFIG.get(node_id)

def get_node_strategy(node_id: str) -> str:
    """
    L·∫•y strategy c·ªßa m·ªôt node
    
    Args:
        node_id (str): Node ID
        
    Returns:
        str: Strategy name ho·∫∑c "unknown" n·∫øu kh√¥ng t√¨m th·∫•y
    """
    config = get_node_config(node_id)
    return config.get("strategy", "unknown") if config else "unknown"

def print_node_config_summary():
    """Print summary c·ªßa NODE_CONFIG v·ªõi additional conditions"""
    print("üìã NODE_CONFIG Summary:")
    for node_id, config in NODE_CONFIG.items():
        required_status = config.get('required_status', 'PENDING')
        additional_conditions = config.get('additional_conditions', [])
        
        print(f"   ‚Ä¢ {node_id[:8]}... - {config['name']} ({config['strategy']})")
        print(f"     Fields: advance='{config['advance_field']}', payment='{config['payment_field']}'")
        print(f"     Required Status: {required_status}")
        
        if additional_conditions:
            print(f"     Additional Conditions:")
            for condition in additional_conditions:
                print(f"       - {condition['node_id'][:8]}... must be {condition['required_status']}")

def get_configured_node_ids():
    """Tr·∫£ v·ªÅ list t·∫•t c·∫£ node IDs ƒë∆∞·ª£c c·∫•u h√¨nh"""
    return list(NODE_CONFIG.keys())

# Backward compatibility
ALLOWED_NODE_IDS = get_configured_node_ids()

============================================================

============================================================
FILE: app\config\settings.py
============================================================
import os
from typing import Optional

class Settings:
    # FastAPI settings
    DEBUG: bool = os.getenv("DEBUG", "false").lower() == "true"
    PORT: int = int(os.getenv("PORT", "8000"))
    
    # Lark API settings
    LARK_APP_ID: str = os.getenv("LARK_APP_ID", "cli_a758ffaf41f8502f")
    LARK_APP_SECRET: str = os.getenv("LARK_APP_SECRET", "45Jsgm3TYfEwD2F67BH1LctlYEcCjZpH")
    BASE_URL: str = "https://open.larksuite.com/open-apis"
    APPROVAL_UPLOAD_URL: str = "https://www.larksuite.com/approval/openapi/v2/file/upload"
    
    # VietQR settings
    VIETQR_TEMPLATE: str = "compact2"
    VIETQR_BASE_URL: str = "https://img.vietqr.io/image"
    
    # Cache settings
    QR_CACHE_DURATION_MINUTES: int = 5
    TOKEN_CACHE_BUFFER_SECONDS: int = 300  # 5 minutes buffer
    
    # File settings
    EVENTS_FILE: str = "lark_events.csv"
    
    # Default user for comments
    DEFAULT_USER_ID: str = "cd11b141"
    
    # Validation settings (for future extensions)
    ENABLE_AMOUNT_VALIDATION: bool = os.getenv("ENABLE_AMOUNT_VALIDATION", "false").lower() == "true"
    ENABLE_WORKFLOW_ALERTS: bool = os.getenv("ENABLE_WORKFLOW_ALERTS", "false").lower() == "true"

# Global settings instance
settings = Settings()

============================================================

============================================================
FILE: app\models\approval.py
============================================================
from pydantic import BaseModel
from typing import Optional, List, Dict, Any

class FormField(BaseModel):
    name: Optional[str] = None
    type: Optional[str] = None
    value: Optional[Any] = None

class TaskInfo(BaseModel):
    node_id: Optional[str] = None
    status: Optional[str] = None
    task_id: Optional[str] = None
    node_name: Optional[str] = None

class ApprovalInstance(BaseModel):
    instance_code: str
    status: Optional[str] = None
    form: Optional[str] = None
    task_list: Optional[List[TaskInfo]] = None

class AmountDetectionResult(BaseModel):
    advance_amount: Optional[float] = None
    payment_amount: Optional[float] = None
    advance_field_found: bool = False
    payment_field_found: bool = False
    all_amount_fields: Dict[str, Any] = {}
    fields_used: Dict[str, Optional[str]] = {}

class QRTypeResult(BaseModel):
    qr_type: str  # 'advance', 'payment', 'none'
    amount: Optional[float] = None
    field_used: Optional[str] = None
    reason: str

class NodeProcessingResult(BaseModel):
    success: bool
    qr_type: str = 'none'
    amount: Optional[float] = None
    field_used: Optional[str] = None
    node_strategy: Optional[str] = None
    reason: Optional[str] = None
    error: Optional[str] = None
    field_detection: Optional[AmountDetectionResult] = None

class ValidationResult(BaseModel):
    """Model for validation results - extensible for future validations"""
    is_valid: bool
    validation_type: str
    message: str
    details: Optional[Dict[str, Any]] = None

============================================================

============================================================
FILE: app\models\event.py
============================================================
from pydantic import BaseModel
from typing import Optional, Dict, Any
from datetime import datetime

class EventHeader(BaseModel):
    event_id: Optional[str] = None
    event_type: Optional[str] = None
    create_time: Optional[str] = None
    token: Optional[str] = None
    tenant_key: Optional[str] = None
    app_id: Optional[str] = None

class EventBody(BaseModel):
    instance_code: Optional[str] = None
    type: Optional[str] = None
    object: Optional[Dict[str, Any]] = None

class LarkEvent(BaseModel):
    schema: Optional[str] = None
    header: Optional[EventHeader] = None
    event: Optional[EventBody] = None
    type: Optional[str] = None  # For URL verification
    challenge: Optional[str] = None  # For URL verification

class EventRecord(BaseModel):
    timestamp: datetime
    event_type: str
    instance_code: Optional[str]
    raw_event: str

============================================================

============================================================
FILE: app\models\response.py
============================================================
from pydantic import BaseModel
from typing import Optional, Dict, Any, List

class APIResponse(BaseModel):
    success: bool
    message: Optional[str] = None
    data: Optional[Dict[str, Any]] = None
    error: Optional[str] = None

class UploadResult(BaseModel):
    success: bool
    file_code: Optional[str] = None
    file_url: Optional[str] = None
    error: Optional[str] = None

class CommentResult(BaseModel):
    success: bool
    comment_id: Optional[str] = None
    error: Optional[str] = None

class QRGenerationResult(BaseModel):
    success: bool
    qr_type: Optional[str] = None
    amount: Optional[float] = None
    field_used: Optional[str] = None
    node_name: Optional[str] = None
    comment_id: Optional[str] = None
    error: Optional[str] = None
    processing_info: Optional[Dict[str, Any]] = None

class CacheStatus(BaseModel):
    total_cached_qr: int
    active_cache: Dict[str, Dict[str, Any]]
    cache_duration_minutes: int
    current_time: str

============================================================

============================================================
FILE: app\routers\config.py
============================================================
from fastapi import APIRouter
from app.config.node_config import NODE_CONFIG, get_node_config, get_configured_node_ids
from app.services.cache_service import cache_service

router = APIRouter()

@router.get("/node-ids")
async def get_allowed_node_ids():
    """Xem danh s√°ch allowed node IDs hi·ªán t·∫°i"""
    return {
        "allowed_node_ids": get_configured_node_ids(),
        "total_allowed": len(NODE_CONFIG)
    }

@router.get("/nodes")
async def get_node_configuration():
    """Xem chi ti·∫øt NODE_CONFIG"""
    return {
        "node_config": NODE_CONFIG,
        "total_nodes": len(NODE_CONFIG),
        "configured_node_ids": list(NODE_CONFIG.keys()),
        "strategies": {
            node_id: config["strategy"] 
            for node_id, config in NODE_CONFIG.items()
        }
    }

@router.get("/nodes/{node_id}")
async def get_specific_node_config(node_id: str):
    """Xem config c·ªßa m·ªôt node c·ª• th·ªÉ"""
    config = get_node_config(node_id)
    if config:
        return {
            "node_id": node_id,
            "config": config,
            "short_id": node_id[:8] + "..."
        }
    else:
        return {
            "error": f"Node ID {node_id} not found in configuration",
            "available_nodes": list(NODE_CONFIG.keys())
        }

@router.get("/cache/qr-status")
async def get_qr_cache_status():
    """Xem tr·∫°ng th√°i cache QR generation"""
    return cache_service.get_cache_status()

@router.post("/cache/clear")
async def clear_qr_cache():
    """Clear cache QR generation manually"""
    return cache_service.clear_cache()

============================================================

============================================================
FILE: app\routers\debug.py
============================================================
from fastapi import APIRouter
import json
from app.services.lark_service import lark_service
from app.services.qr_processor import qr_processor
from app.utils.amount_detector import AmountDetector
from app.config.node_config import NODE_CONFIG

router = APIRouter()
amount_detector = AmountDetector()

@router.get("/instance/{instance_code}")
async def debug_instance(instance_code: str):
    """Debug instance v·ªõi NODE_CONFIG"""
    try:
        access_token = await lark_service.get_access_token()
        if not access_token:
            return {"error": "Cannot get access token"}
        
        api_response = await lark_service.get_approval_instance(instance_code, access_token)
        if not api_response:
            return {"error": "Cannot get instance data"}
        
        # S·ª≠ d·ª•ng function v·ªõi NODE_CONFIG
        check_result = qr_processor.check_pending_allowed_node_in_task_list(api_response)
        
        return {
            "instance_code": instance_code,
            "node_check_result": check_result,
            "node_config": NODE_CONFIG,
            "will_generate_qr": check_result['found'],
            "reason": f"Found {check_result.get('strategy', 'unknown')} node with required status" if check_result['found'] else "No matching configured nodes found"
        }
            
    except Exception as e:
        return {"error": str(e)}

@router.get("/instance/{instance_code}/fields")
async def debug_instance_fields(instance_code: str):
    """Debug chi ti·∫øt v·ªÅ fields trong form c·ªßa instance"""
    try:
        access_token = await lark_service.get_access_token()
        if not access_token:
            return {"error": "Cannot get access token"}
        
        api_response = await lark_service.get_approval_instance(instance_code, access_token)
        if not api_response:
            return {"error": "Cannot get instance data"}
            
        if 'data' not in api_response or 'form' not in api_response['data']:
            return {"error": "No form data found"}
            
        form_str = api_response['data']['form']
        form_data = json.loads(form_str)
        
        # Enhanced field detection
        field_detection = amount_detector.detect_available_amount_fields(form_data)
        
        # Test v·ªõi t·∫•t c·∫£ configured nodes
        node_results = {}
        for node_id, config in NODE_CONFIG.items():
            node_result = amount_detector.get_amount_and_type_for_node(node_id, form_data)
            node_results[config['name']] = {
                'node_id': node_id[:8] + '...',
                'strategy': config['strategy'],
                'result': node_result
            }
        
        # Extract t·∫•t c·∫£ field names ƒë·ªÉ debug
        all_fields = []
        for field in form_data:
            field_info = {
                'name': field.get('name'),
                'type': field.get('type'),
                'value': field.get('value')
            }
            all_fields.append(field_info)
        
        return {
            "instance_code": instance_code,
            "field_detection": field_detection,
            "node_processing_results": node_results,
            "all_form_fields": all_fields,
            "total_fields": len(all_fields)
        }
            
    except Exception as e:
        return {"error": str(e)}

============================================================

============================================================
FILE: app\routers\manual.py
============================================================
from fastapi import APIRouter
import json
from app.services.lark_service import lark_service
from app.services.qr_processor import qr_processor
from app.utils.amount_detector import AmountDetector
import os
import pandas as pd
from app.config.settings import settings

router = APIRouter()
amount_detector = AmountDetector()

@router.post("/process/{instance_code}")
async def manual_process_instance(instance_code: str):
    """Enhanced manual processing v·ªõi detailed results"""
    try:
        access_token = await lark_service.get_access_token()
        if not access_token:
            return {"success": False, "error": "Cannot get access token"}
        
        # Get detailed processing info tr∆∞·ªõc khi process
        api_response = await lark_service.get_approval_instance(instance_code, access_token)
        
        processing_info = {"instance_code": instance_code}
        
        if api_response:
            # Get node check info
            node_check = qr_processor.check_pending_allowed_node_in_task_list(api_response)
            processing_info["node_check"] = node_check
            
            # Get field detection info if node found
            if node_check['found'] and 'data' in api_response and 'form' in api_response['data']:
                form_str = api_response['data']['form']
                form_data = json.loads(form_str)
                
                node_id = node_check['node_id']
                amount_result = amount_detector.get_amount_and_type_for_node(node_id, form_data)
                processing_info["amount_detection"] = amount_result
        
        # Process the instance
        result = await qr_processor.process_approval_with_qr_comment(instance_code, access_token)
        
        return {
            "success": result,
            "message": f"{'Successfully processed' if result else 'Failed to process'} instance {instance_code}",
            "processing_info": processing_info
        }
            
    except Exception as e:
        return {"success": False, "error": str(e)}

@router.get("/events")
async def get_events():
    """Xem events ƒë√£ nh·∫≠n"""
    try:
        if os.path.exists(settings.EVENTS_FILE):
            df = pd.read_csv(settings.EVENTS_FILE, encoding='utf-8')
            return {
                "total_events": len(df),
                "latest_events": df.tail(20).to_dict('records')
            }
        return {"message": "No events found"}
    except Exception as e:
        return {"error": str(e)}

============================================================

============================================================
FILE: app\routers\webhook.py
============================================================
from fastapi import APIRouter, Request
from fastapi.responses import JSONResponse
from app.services.lark_service import lark_service
from app.services.qr_processor import qr_processor
from app.utils.helpers import save_event_to_csv, get_event_type, extract_instance_code
from app.config.settings import settings

router = APIRouter()

@router.post("/webhook")
async def handle_lark_webhook(request: Request):
    try:
        data = await request.json()
        print(f"üì® Received webhook: {get_event_type(data)}")
        
        # Handle URL verification
        if data.get("type") == "url_verification":
            return JSONResponse(content={"challenge": data.get("challenge")})
        
        # L∆∞u event v√†o CSV
        await save_event_to_csv(data, settings.EVENTS_FILE)
        
        # X·ª≠ l√Ω approval event
        event_type = get_event_type(data)
        if "approval" in event_type.lower():
            instance_code = extract_instance_code(data)
            if instance_code:
                print(f"üîç Processing approval instance: {instance_code}")
                
                # L·∫•y access token
                access_token = await lark_service.get_access_token()
                if access_token:
                    # X·ª≠ l√Ω t·ª± ƒë·ªông: check node_id -> l·∫•y th√¥ng tin -> t·∫°o QR -> upload -> comment
                    await qr_processor.process_approval_with_qr_comment(instance_code, access_token)
                else:
                    print("‚ùå Kh√¥ng th·ªÉ l·∫•y access token")
        
        return JSONResponse(content={"status": "success"})
        
    except Exception as e:
        print(f"‚ùå Error: {e}")
        return JSONResponse(content={"error": str(e)}, status_code=500)

============================================================

============================================================
FILE: app\services\cache_service.py
============================================================
from datetime import datetime, timedelta
from typing import Dict, Optional

class CacheService:
    def __init__(self):
        self.qr_generation_cache: Dict[str, datetime] = {}
    
    def generate_cache_key(self, instance_code: str, node_id: str, qr_type: str) -> str:
        """
        T·∫°o cache key ƒë·ªÉ detect duplicate
        
        Args:
            instance_code (str): Instance code
            node_id (str): Node ID (8 k√Ω t·ª± ƒë·∫ßu)
            qr_type (str): 'advance' ho·∫∑c 'payment'
            
        Returns:
            str: Unique cache key
        """
        short_node_id = node_id[:8] if len(node_id) > 8 else node_id
        return f"{instance_code}_{short_node_id}_{qr_type}"

    def is_qr_recently_generated(self, instance_code: str, node_id: str, qr_type: str, 
                               cache_duration_minutes: int = 5) -> bool:
        """
        Check xem QR ƒë√£ ƒë∆∞·ª£c t·∫°o trong th·ªùi gian g·∫ßn ƒë√¢y ch∆∞a
        
        Returns:
            bool: True n·∫øu ƒë√£ t·∫°o g·∫ßn ƒë√¢y, False n·∫øu ch∆∞a ho·∫∑c ƒë√£ h·∫øt h·∫°n
        """
        try:
            cache_key = self.generate_cache_key(instance_code, node_id, qr_type)
            
            if cache_key not in self.qr_generation_cache:
                print(f"üÜï Cache miss: {cache_key} - ch∆∞a t·∫°o QR")
                return False
            
            generated_time = self.qr_generation_cache[cache_key]
            current_time = datetime.now()
            time_diff = current_time - generated_time
            
            if time_diff > timedelta(minutes=cache_duration_minutes):
                del self.qr_generation_cache[cache_key] 
                print(f"‚è∞ Cache expired: {cache_key} ({time_diff.total_seconds()/60:.1f} minutes ago)")
                return False
            
            print(f"üîí Cache hit: {cache_key} - QR ƒë√£ t·∫°o {time_diff.total_seconds()/60:.1f} ph√∫t tr∆∞·ªõc")
            return True
            
        except Exception as e:
            print(f"‚ùå Error checking cache: {e}")
            return False

    def mark_qr_as_generated(self, instance_code: str, node_id: str, qr_type: str):
        """ƒê√°nh d·∫•u QR ƒë√£ ƒë∆∞·ª£c t·∫°o"""
        try:
            cache_key = self.generate_cache_key(instance_code, node_id, qr_type)
            self.qr_generation_cache[cache_key] = datetime.now()
            
            print(f"üîí Marked QR as generated: {cache_key}")
            print(f"üìä Cache size: {len(self.qr_generation_cache)} entries")
            
        except Exception as e:
            print(f"‚ùå Error marking cache: {e}")

    def get_cache_status(self) -> Dict:
        """L·∫•y tr·∫°ng th√°i cache"""
        try:
            current_time = datetime.now()
            active_cache = {}
            
            for cache_key, generated_time in self.qr_generation_cache.items():
                time_diff = current_time - generated_time
                minutes_ago = time_diff.total_seconds() / 60
                
                active_cache[cache_key] = {
                    'generated_at': generated_time.isoformat(),
                    'minutes_ago': round(minutes_ago, 1),
                    'will_expire_in_minutes': max(0, 5 - minutes_ago)
                }
            
            return {
                'total_cached_qr': len(self.qr_generation_cache),
                'active_cache': active_cache,
                'cache_duration_minutes': 5,
                'current_time': current_time.isoformat()
            }
            
        except Exception as e:
            return {"error": str(e)}

    def clear_cache(self) -> Dict:
        """Clear t·∫•t c·∫£ cache"""
        try:
            old_count = len(self.qr_generation_cache)
            old_keys = list(self.qr_generation_cache.keys())
            
            self.qr_generation_cache.clear()
            
            return {
                'message': f'Successfully cleared {old_count} cache entries',
                'cleared_keys': old_keys,
                'current_cache_size': len(self.qr_generation_cache)
            }
            
        except Exception as e:
            return {"success": False, "error": str(e)}

# Global cache instance
cache_service = CacheService()

============================================================

============================================================
FILE: app\services\lark_service.py
============================================================
import requests
import json
from datetime import datetime
from typing import Optional, Dict, Any
from app.config.settings import settings

class LarkService:
    def __init__(self):
        self.access_token_cache = {"token": None, "expires_at": None}
    
    async def get_access_token(self) -> Optional[str]:
        """L·∫•y access token t·ª´ LarkSuite v·ªõi caching"""
        current_time = datetime.now().timestamp()
        
        if (self.access_token_cache["token"] and 
            self.access_token_cache["expires_at"] and 
            current_time < self.access_token_cache["expires_at"]):
            return self.access_token_cache["token"]
        
        try:
            url = f"{settings.BASE_URL}/auth/v3/tenant_access_token/internal"
            payload = {
                "app_id": settings.LARK_APP_ID,
                "app_secret": settings.LARK_APP_SECRET
            }
            
            response = requests.post(url, json=payload, timeout=10)
            data = response.json()
            
            if data.get("code") == 0:
                token = data["tenant_access_token"]
                expires_in = data.get("expire", 7200)
                
                self.access_token_cache["token"] = token
                self.access_token_cache["expires_at"] = current_time + expires_in - settings.TOKEN_CACHE_BUFFER_SECONDS
                
                print(f"‚úÖ Got access token")
                return token
            else:
                print(f"‚ùå Failed to get token: {data}")
                return None
                
        except Exception as e:
            print(f"‚ùå Error getting token: {e}")
            return None

    async def get_approval_instance(self, instance_code: str, access_token: str) -> Optional[Dict]:
        """L·∫•y th√¥ng tin approval instance"""
        try:
            url = f"{settings.BASE_URL}/approval/v4/instances/{instance_code}"
            headers = {"Authorization": f"Bearer {access_token}"}
            
            print(f"üîç L·∫•y th√¥ng tin instance: {instance_code}")
            response = requests.get(url, headers=headers, timeout=10)
            
            if response.status_code != 200:
                print(f"‚ùå L·ªói API call: {response.status_code}")
                return None
                
            api_response = response.json()
            
            if api_response.get("code") != 0:
                print(f"‚ùå API response error: {api_response}")
                return None
                
            return api_response
            
        except Exception as e:
            print(f"‚ùå Error getting approval instance: {e}")
            return None

    async def upload_image_to_approval(self, image_buffer, filename: str, access_token: str) -> Dict:
        """Upload ·∫£nh l√™n Lark Approval API"""
        try:
            image_buffer.seek(0)
            
            files = {
                'name': (None, filename),
                'type': (None, 'image'),
                'content': (filename, image_buffer, 'image/png')
            }
            
            headers = {
                'Authorization': f'Bearer {access_token}'
            }
            
            print(f"üì§ ƒêang upload ·∫£nh: {filename}")
            response = requests.post(settings.APPROVAL_UPLOAD_URL, files=files, headers=headers)
            
            if response.status_code == 200:
                data = response.json()
                if data.get('code') == 0:
                    file_code = data['data']['code']
                    file_url = data['data']['url']
                    print(f'‚úÖ Upload ·∫£nh th√†nh c√¥ng! File code: {file_code}')
                    return {
                        'success': True,
                        'file_code': file_code,
                        'file_url': file_url
                    }
                else:
                    error_msg = f"API error: {data.get('msg')} (code: {data.get('code')})"
                    print(f'‚ùå Upload th·∫•t b·∫°i: {error_msg}')
                    return {'success': False, 'error': error_msg}
            else:
                error_msg = f"HTTP error: {response.status_code}"
                print(f'‚ùå Upload th·∫•t b·∫°i: {error_msg}')
                return {'success': False, 'error': error_msg}
                
        except Exception as e:
            error_msg = f"Exception: {str(e)}"
            print(f"‚ùå L·ªói upload: {error_msg}")
            return {'success': False, 'error': error_msg}

    async def create_enhanced_comment_with_image(self, instance_code: str, file_url: str, file_code: str, 
                                               filename: str, qr_type: str, amount: int, node_name: str,
                                               access_token: str, user_id: str = None) -> Dict:
        """T·∫°o comment v·ªõi ·∫£nh v√† th√¥ng tin chi ti·∫øt"""
        try:
            if user_id is None:
                user_id = settings.DEFAULT_USER_ID
                
            create_comment_url = f'{settings.BASE_URL}/approval/v4/instances/{instance_code}/comments'
            
            params = {
                "user_id": user_id,
                "user_id_type": "user_id"
            }
            
            # Enhanced comment text v·ªõi type info
            qr_type_display = {
                'advance': 'T·∫†M ·ª®NG',
                'payment': 'THANH TO√ÅN'
            }
            
            comment_text = f"""üè¶ M√£ VietQR {qr_type_display.get(qr_type, qr_type.upper())}
            üí∞ S·ªë ti·ªÅn: {amount:,} VND
            üìã Node: {node_name}
            üìÑ Instance: {instance_code}"""

            # Estimate file size
            try:
                file_size = len(filename) * 100  # Rough estimate
            except:
                file_size = 50000  # Default estimate
            
            content_data = {
                "text": comment_text,
                "files": [{
                    "url": file_url,
                    "fileSize": file_size,
                    "title": filename,
                    "type": "image",
                    "extra": file_code
                }]
            }
            
            request_body = {
                "content": json.dumps(content_data, ensure_ascii=False)
            }
            
            headers_comment = {
                'Authorization': f'Bearer {access_token}',
                'Content-Type': 'application/json'
            }
            
            print(f"üì§ ƒêang t·∫°o enhanced comment cho instance: {instance_code}")
            print(f"   Comment: {comment_text.replace(chr(10), ' | ')}")
            
            response = requests.post(
                create_comment_url, 
                params=params,
                json=request_body, 
                headers=headers_comment
            )
            
            if response.status_code == 200:
                comment_result = response.json()
                if comment_result.get('code') == 0:
                    comment_id = comment_result.get("data", {}).get("comment_id", "N/A")
                    print(f'‚úÖ T·∫°o enhanced comment th√†nh c√¥ng! Comment ID: {comment_id}')
                    return {'success': True, 'comment_id': comment_id}
                else:
                    error_msg = f"API error: {comment_result.get('msg')} (code: {comment_result.get('code')})"
                    print(f'‚ùå T·∫°o comment th·∫•t b·∫°i: {error_msg}')
                    return {'success': False, 'error': error_msg}
            else:
                error_msg = f"HTTP error: {response.status_code}"
                print(f'‚ùå T·∫°o comment th·∫•t b·∫°i: {error_msg}')
                return {'success': False, 'error': error_msg}
                
        except Exception as e:
            error_msg = f"Exception: {str(e)}"
            print(f"‚ùå L·ªói t·∫°o enhanced comment: {error_msg}")
            return {'success': False, 'error': error_msg}

# Global service instance
lark_service = LarkService()

============================================================

============================================================
FILE: app\services\qr_processor.py
============================================================
"""
QR Processing Service - Main business logic for QR generation and processing
"""
import json
from typing import Dict, Optional, List
from app.config.settings import settings
from app.config.node_config import NODE_CONFIG, get_node_config
from app.services.lark_service import lark_service
from app.services.vietqr_service import vietqr_service
from app.services.cache_service import cache_service
from app.services.validation_service import validation_service
from app.utils.field_extractor import FieldExtractor
from app.utils.amount_detector import AmountDetector
from app.models.approval import NodeProcessingResult

class QRProcessor:
    def __init__(self):
        self.field_extractor = FieldExtractor()
        self.amount_detector = AmountDetector()
    
    def check_pending_allowed_node_in_task_list(self, api_response: dict, node_config: dict = None) -> dict:
        """
        Ki·ªÉm tra node c√≥ status ph√π h·ª£p + additional conditions
        """
        if node_config is None:
            node_config = NODE_CONFIG
            
        try:
            data = api_response.get('data', {})
            task_list = data.get('task_list', [])
            configured_node_ids = list(node_config.keys())
            
            # T·∫°o dict ƒë·ªÉ lookup status c·ªßa t·∫•t c·∫£ nodes
            node_status_map = {}
            for task in task_list:
                node_id = task.get('node_id')
                status = task.get('status', 'UNKNOWN')
                if node_id:
                    node_status_map[node_id] = status
            
            print(f"üîç Checking nodes with additional conditions:")
            for node_id, config in node_config.items():
                required_status = config.get('required_status', 'PENDING')
                additional_conditions = config.get('additional_conditions', [])
                print(f"   ‚Ä¢ {node_id[:8]}... - {config['name']} (requires: {required_status})")
                if additional_conditions:
                    for condition in additional_conditions:
                        print(f"     + Additional: {condition['node_id'][:8]}... must be {condition['required_status']}")
            
            print(f"üìã Task list contains {len(task_list)} tasks")
            
            matching_configured_nodes = []
            
            for node_id in configured_node_ids:
                config = node_config[node_id]
                required_status = config.get('required_status', 'PENDING')
                current_status = node_status_map.get(node_id, 'NOT_FOUND')
                
                # Check primary condition
                if current_status != required_status:
                    continue
                    
                # Check additional conditions
                additional_conditions = config.get('additional_conditions', [])
                all_conditions_met = True
                
                for condition in additional_conditions:
                    condition_node_id = condition['node_id']
                    condition_required_status = condition['required_status']
                    condition_current_status = node_status_map.get(condition_node_id, 'NOT_FOUND')
                    
                    print(f"üîç Checking additional condition: {condition_node_id[:8]}... ")
                    print(f"   Required: {condition_required_status}, Current: {condition_current_status}")
                    
                    if condition_current_status != condition_required_status:
                        all_conditions_met = False
                        print(f"‚ùå Additional condition not met for {node_id[:8]}...")
                        break
                    else:
                        print(f"‚úÖ Additional condition met")
                
                if all_conditions_met:
                    matching_configured_nodes.append({
                        'node_id': node_id,
                        'config': config,
                        'strategy': config['strategy'],
                        'matched_status': current_status,
                        'required_status': required_status,
                        'additional_conditions_met': True
                    })
                    print(f"‚úÖ Full match found: {node_id[:8]}... ({config['name']}) - Status: {current_status}")
            
            # Return first matching configured node
            if matching_configured_nodes:
                first_matching = matching_configured_nodes[0]
                return {
                    'found': True,
                    'node_id': first_matching['node_id'],
                    'node_config': first_matching['config'],
                    'strategy': first_matching['strategy'],
                    'matched_status': first_matching['matched_status'],
                    'required_status': first_matching['required_status'],
                    'all_tasks': task_list,
                    'all_matching_configured': matching_configured_nodes,
                    'node_status_map': node_status_map
                }
            else:
                print(f"‚ùå No nodes matching all conditions found")
                return {
                    'found': False,
                    'node_id': None,
                    'node_config': None,
                    'strategy': None,
                    'matched_status': None,
                    'all_tasks': task_list,
                    'all_matching_configured': [],
                    'node_status_map': node_status_map
                }
            
        except Exception as e:
            print(f"‚ùå Error checking nodes: {e}")
            return {
                'found': False,
                'error': str(e),
                'all_tasks': [],
                'all_matching_configured': []
            }
    
    def validate_amount_value(self, amount_value) -> dict:
        """Validate v√† convert amount value"""
        try:
            if amount_value is None:
                return {'valid': False, 'amount': None, 'error': 'Amount is None'}
                
            # Convert to float first, then int
            amount_float = float(amount_value)
            amount_int = int(amount_float)
            
            if amount_int <= 0:
                return {'valid': False, 'amount': amount_int, 'error': 'Amount must be positive'}
                
            return {'valid': True, 'amount': amount_int, 'error': None}
            
        except (ValueError, TypeError) as e:
            return {'valid': False, 'amount': None, 'error': f'Invalid amount format: {str(e)}'}
    
    async def process_approval_with_qr_comment(self, instance_code: str, access_token: str) -> bool:
        """
        Enhanced version v·ªõi duplicate detection v√† validation
        X·ª≠ l√Ω approval v·ªõi smart field detection, multiple node support v√† flexible status requirements
        """
        try:
            # L·∫•y instance details
            api_response = await lark_service.get_approval_instance(instance_code, access_token)
            if not api_response:
                return False
            
            # Check nodes v·ªõi required status
            node_check_result = self.check_pending_allowed_node_in_task_list(api_response)
            
            if not node_check_result['found']:
                print(f"‚è≠Ô∏è Skipping QR generation - no matching configured nodes found")
                return True  # Return True v√¨ kh√¥ng ph·∫£i l·ªói, ch·ªâ l√† skip
            
            matching_node_id = node_check_result['node_id']
            node_config = node_check_result['node_config']
            node_strategy = node_check_result['strategy']
            matched_status = node_check_result.get('matched_status', 'UNKNOWN')
            required_status = node_check_result.get('required_status', 'PENDING')
            
            print(f"‚úÖ Processing node: {node_config['name']} (strategy: {node_strategy})")
            print(f"   Status: {matched_status} (required: {required_status})")
            
            # Extract form data
            if 'data' not in api_response or 'form' not in api_response['data']:
                print("‚ùå Kh√¥ng t√¨m th·∫•y form data")
                return False
                
            form_str = api_response['data']['form']
            form_data = json.loads(form_str)
            
            # NEW: Run validations if enabled
            if settings.ENABLE_AMOUNT_VALIDATION or settings.ENABLE_WORKFLOW_ALERTS:
                task_list = api_response.get('data', {}).get('task_list', [])
                validation_results = validation_service.run_all_validations(
                    form_data, task_list, matching_node_id
                )
                
                # Log validation results
                for result in validation_results:
                    print(f"üîç Validation: {result.message}")
                    if not result.is_valid and settings.ENABLE_WORKFLOW_ALERTS:
                        # TODO: Implement alert system (email, Slack, etc.)
                        print(f"üö® ALERT: {result.message}")
            
            # Smart field detection theo node strategy
            amount_result = self.amount_detector.get_amount_and_type_for_node(matching_node_id, form_data)
            
            if not amount_result['success']:
                print(f"‚ùå Cannot determine amount/type: {amount_result.get('reason', 'Unknown error')}")
                if 'error' in amount_result:
                    print(f"    Error details: {amount_result['error']}")
                return False
            
            qr_type = amount_result['qr_type']
            amount_value = amount_result['amount']
            field_used = amount_result['field_used']
            
            # Check duplicate TR∆Ø·ªöC KHI t·∫°o QR
            if cache_service.is_qr_recently_generated(
                instance_code, matching_node_id, qr_type, 
                settings.QR_CACHE_DURATION_MINUTES
            ):
                print(f"‚ö†Ô∏è DUPLICATE DETECTED: QR {qr_type.upper()} for node {node_config['name']} already generated recently")
                print(f"   ‚Üí SKIPPING QR generation to prevent duplicate")
                return True  # Return success v√¨ kh√¥ng ph·∫£i l·ªói, ch·ªâ l√† skip duplicate
            
            print(f"üí∞ QR Generation Details:")
            print(f"   - Type: {qr_type}")
            print(f"   - Amount: {amount_value:,} VND")
            print(f"   - Field used: {field_used}")
            print(f"   - Node strategy: {node_strategy}")
            print(f"   - Trigger status: {matched_status}")
            
            # Validate amount
            amount_validation = self.validate_amount_value(amount_value)
            if not amount_validation['valid']:
                print(f"‚ùå Invalid amount: {amount_validation['error']}")
                return False
                
            amount_int = amount_validation['amount']
            
            # Extract th√¥ng tin ng√¢n h√†ng
            bank_id = self.field_extractor.extract_field_value(form_data, 'Ng√¢n h√†ng')
            account_no = self.field_extractor.extract_field_value(form_data, 'S·ªë t√†i kho·∫£n ng√¢n h√†ng')
            account_name = self.field_extractor.extract_field_value(form_data, 'T√™n ng∆∞·ªùi th·ª• h∆∞·ªüng')
            
            # Ki·ªÉm tra th√¥ng tin ng√¢n h√†ng
            if not all([bank_id, account_no, account_name]):
                missing_fields = []
                if not bank_id: missing_fields.append('Ng√¢n h√†ng')
                if not account_no: missing_fields.append('S·ªë t√†i kho·∫£n ng√¢n h√†ng')
                if not account_name: missing_fields.append('T√™n ng∆∞·ªùi th·ª• h∆∞·ªüng')
                
                print(f"‚ùå Thi·∫øu th√¥ng tin ng√¢n h√†ng: {', '.join(missing_fields)}")
                return False
            
            # Generate QR description theo type
            description = vietqr_service.generate_qr_description(qr_type, instance_code)
            
            print(f"üè¶ T·∫°o VietQR v·ªõi th√¥ng tin:")
            print(f"   - Ng√¢n h√†ng: {bank_id}")
            print(f"   - S·ªë TK: {account_no}")
            print(f"   - T√™n: {account_name}")
            print(f"   - S·ªë ti·ªÅn: {amount_int:,} VND")
            print(f"   - M√¥ t·∫£: {description}")
            
            # T·∫°o VietQR code trong b·ªô nh·ªõ
            qr_image_buffer = vietqr_service.create_qr_in_memory(
                bank_id=bank_id,
                account_no=account_no,
                amount=amount_int,
                description=description,
                account_name=account_name
            )
            
            if not qr_image_buffer:
                print("‚ùå Kh√¥ng th·ªÉ t·∫°o VietQR code")
                return False
            
            # Upload ·∫£nh l√™n Lark Approval
            filename = f"{instance_code}_{qr_type}_qr.png"
            upload_result = await lark_service.upload_image_to_approval(qr_image_buffer, filename, access_token)
            
            if not upload_result['success']:
                print(f"‚ùå Upload th·∫•t b·∫°i: {upload_result['error']}")
                return False
            
            # ƒê√°nh d·∫•u ƒë√£ t·∫°o QR SAU KHI upload th√†nh c√¥ng
            cache_service.mark_qr_as_generated(instance_code, matching_node_id, qr_type)
            
            # Enhanced comment v·ªõi type v√† status info
            comment_result = await lark_service.create_enhanced_comment_with_image(
                instance_code=instance_code,
                file_url=upload_result['file_url'],
                file_code=upload_result['file_code'],
                filename=filename,
                qr_type=qr_type,
                amount=amount_int,
                node_name=node_config['name'],
                access_token=access_token
            )
            
            if comment_result['success']:
                print(f"‚úÖ Ho√†n th√†nh x·ª≠ l√Ω approval {instance_code}")
                print(f"üí∞ Lo·∫°i: {qr_type.upper()} | S·ªë ti·ªÅn: {amount_int:,} VND")
                print(f"üè∑Ô∏è Node: {node_config['name']} | Status: {matched_status}")
                print(f"üìã Field: {field_used} | Strategy: {node_strategy}")
                print(f"üí¨ Comment ID: {comment_result['comment_id']}")
                return True
            else:
                print(f"‚ùå T·∫°o comment th·∫•t b·∫°i: {comment_result['error']}")
                return False
                
        except Exception as e:
            print(f"‚ùå L·ªói x·ª≠ l√Ω approval: {e}")
            import traceback
            traceback.print_exc()
            return False

# Global processor instance
qr_processor = QRProcessor()

============================================================

============================================================
FILE: app\services\validation_service.py
============================================================
"""
Validation Service - D√†nh cho c√°c validation rules m·ªü r·ªông trong t∆∞∆°ng lai
V√≠ d·ª•: ki·ªÉm tra t·ªïng t·∫°m ·ª©ng + thanh to√°n = th√†nh ti·ªÅn
"""
from typing import Dict, List, Any, Optional
from app.models.approval import ValidationResult

class ValidationService:
    def __init__(self):
        self.validation_rules = {
            "amount_sum_validation": self.validate_amount_sum,
            "workflow_status_validation": self.validate_workflow_status,
            "field_consistency_validation": self.validate_field_consistency
        }
    
    def validate_amount_sum(self, form_data: List[Dict], **kwargs) -> ValidationResult:
        """
        Ki·ªÉm tra t·ªïng t·∫°m ·ª©ng + thanh to√°n c√≥ b·∫±ng th√†nh ti·ªÅn kh√¥ng
        
        Args:
            form_data: Form data t·ª´ approval
            **kwargs: Additional parameters
            
        Returns:
            ValidationResult: K·∫øt qu·∫£ validation
        """
        try:
            from app.utils.field_extractor import FieldExtractor
            extractor = FieldExtractor()
            
            # Extract c√°c fields c·∫ßn thi·∫øt
            advance_amount = extractor.extract_field_value(form_data, "S·ªë ti·ªÅn t·∫°m ·ª©ng")
            payment_amount = extractor.extract_field_value(form_data, "S·ªë ti·ªÅn thanh to√°n")
            total_amount = extractor.extract_field_value(form_data, "Th√†nh ti·ªÅn")
            
            # Convert sang float
            advance = float(advance_amount) if advance_amount else 0
            payment = float(payment_amount) if payment_amount else 0
            total = float(total_amount) if total_amount else 0
            
            calculated_sum = advance + payment
            
            if abs(calculated_sum - total) < 0.01:  # Allow small floating point differences
                return ValidationResult(
                    is_valid=True,
                    validation_type="amount_sum_validation",
                    message=f"‚úÖ T·ªïng s·ªë ti·ªÅn h·ª£p l·ªá: {advance:,} + {payment:,} = {total:,}",
                    details={
                        "advance_amount": advance,
                        "payment_amount": payment,
                        "total_amount": total,
                        "calculated_sum": calculated_sum
                    }
                )
            else:
                return ValidationResult(
                    is_valid=False,
                    validation_type="amount_sum_validation",
                    message=f"‚ùå T·ªïng s·ªë ti·ªÅn kh√¥ng kh·ªõp: {advance:,} + {payment:,} = {calculated_sum:,} ‚â† {total:,}",
                    details={
                        "advance_amount": advance,
                        "payment_amount": payment,
                        "total_amount": total,
                        "calculated_sum": calculated_sum,
                        "difference": abs(calculated_sum - total)
                    }
                )
                
        except Exception as e:
            return ValidationResult(
                is_valid=False,
                validation_type="amount_sum_validation",
                message=f"‚ùå L·ªói validation: {str(e)}",
                details={"error": str(e)}
            )
    
    def validate_workflow_status(self, task_list: List[Dict], node_id: str, **kwargs) -> ValidationResult:
        """
        Ki·ªÉm tra workflow status - c·∫£nh b√°o n·∫øu node ƒë√£ duy·ªát m√† b·ªã thu h·ªìi
        
        Args:
            task_list: Task list t·ª´ approval
            node_id: Node ID c·∫ßn ki·ªÉm tra
            **kwargs: Additional parameters
            
        Returns:
            ValidationResult: K·∫øt qu·∫£ validation
        """
        try:
            # T√¨m node trong task list
            target_node = None
            for task in task_list:
                if task.get('node_id') == node_id:
                    target_node = task
                    break
            
            if not target_node:
                return ValidationResult(
                    is_valid=True,  # Kh√¥ng t√¨m th·∫•y node kh√¥ng ph·∫£i l·ªói
                    validation_type="workflow_status_validation",
                    message=f"Node {node_id[:8]}... kh√¥ng t√¨m th·∫•y trong task list",
                    details={"node_id": node_id, "found": False}
                )
            
            current_status = target_node.get('status', 'UNKNOWN')
            
            # Logic ki·ªÉm tra thu h·ªìi
            if current_status in ['REJECTED', 'CANCELED', 'WITHDRAWN']:
                # Ki·ªÉm tra xem tr∆∞·ªõc ƒë√≥ c√≥ ƒë∆∞·ª£c approve kh√¥ng
                # (Logic n√†y c√≥ th·ªÉ ph·ª©c t·∫°p h∆°n t√πy theo business rule)
                return ValidationResult(
                    is_valid=False,
                    validation_type="workflow_status_validation",
                    message=f"‚ö†Ô∏è C·∫¢NH B√ÅO: Node {node_id[:8]}... c√≥ status {current_status} - c√≥ th·ªÉ ƒë√£ b·ªã thu h·ªìi",
                    details={
                        "node_id": node_id,
                        "current_status": current_status,
                        "alert_type": "potential_withdrawal"
                    }
                )
            
            return ValidationResult(
                is_valid=True,
                validation_type="workflow_status_validation",
                message=f"‚úÖ Node {node_id[:8]}... c√≥ status b√¨nh th∆∞·ªùng: {current_status}",
                details={
                    "node_id": node_id,
                    "current_status": current_status
                }
            )
            
        except Exception as e:
            return ValidationResult(
                is_valid=False,
                validation_type="workflow_status_validation",
                message=f"‚ùå L·ªói ki·ªÉm tra workflow status: {str(e)}",
                details={"error": str(e)}
            )
    
    def validate_field_consistency(self, form_data: List[Dict], **kwargs) -> ValidationResult:
        """
        Ki·ªÉm tra t√≠nh nh·∫•t qu√°n c·ªßa c√°c fields
        V√≠ d·ª•: Ng√†y b·∫Øt ƒë·∫ßu ph·∫£i tr∆∞·ªõc ng√†y k·∫øt th√∫c
        """
        try:
            # Placeholder cho logic validation kh√°c
            return ValidationResult(
                is_valid=True,
                validation_type="field_consistency_validation",
                message="‚úÖ Field consistency check passed",
                details={"checked": True}
            )
            
        except Exception as e:
            return ValidationResult(
                is_valid=False,
                validation_type="field_consistency_validation",
                message=f"‚ùå L·ªói ki·ªÉm tra field consistency: {str(e)}",
                details={"error": str(e)}
            )
    
    def run_validation(self, validation_type: str, **kwargs) -> ValidationResult:
        """
        Ch·∫°y m·ªôt validation rule c·ª• th·ªÉ
        
        Args:
            validation_type: Lo·∫°i validation c·∫ßn ch·∫°y
            **kwargs: Parameters cho validation
            
        Returns:
            ValidationResult: K·∫øt qu·∫£ validation
        """
        if validation_type in self.validation_rules:
            return self.validation_rules[validation_type](**kwargs)
        else:
            return ValidationResult(
                is_valid=False,
                validation_type=validation_type,
                message=f"‚ùå Unknown validation type: {validation_type}",
                details={"available_types": list(self.validation_rules.keys())}
            )
    
    def run_all_validations(self, form_data: List[Dict], task_list: List[Dict], 
                           node_id: str) -> List[ValidationResult]:
        """
        Ch·∫°y t·∫•t c·∫£ validations
        
        Args:
            form_data: Form data t·ª´ approval
            task_list: Task list t·ª´ approval
            node_id: Node ID ƒëang x·ª≠ l√Ω
            
        Returns:
            List[ValidationResult]: Danh s√°ch k·∫øt qu·∫£ validation
        """
        results = []
        
        # Amount sum validation
        results.append(self.run_validation(
            "amount_sum_validation", 
            form_data=form_data
        ))
        
        # Workflow status validation
        results.append(self.run_validation(
            "workflow_status_validation", 
            task_list=task_list, 
            node_id=node_id
        ))
        
        # Field consistency validation
        results.append(self.run_validation(
            "field_consistency_validation", 
            form_data=form_data
        ))
        
        return results

# Global service instance
validation_service = ValidationService()

============================================================

============================================================
FILE: app\services\vietqr_service.py
============================================================
import requests
from urllib.parse import quote
from PIL import Image
from io import BytesIO
from app.config.settings import settings

class VietQRService:
    def __init__(self):
        self.base_url = settings.VIETQR_BASE_URL
    
    def create_qr_in_memory(self, bank_id: str, account_no: str, amount: int, 
                           description: str, account_name: str, 
                           template: str = None) -> BytesIO:
        """
        T·∫°o QR code v·ªõi s·ªë ti·ªÅn v√† n·ªôi dung, tr·∫£ v·ªÅ BytesIO object
        
        Args:
            bank_id (str): M√£ ng√¢n h√†ng
            account_no (str): S·ªë t√†i kho·∫£n   
            amount (int): S·ªë ti·ªÅn (VND)
            description (str): N·ªôi dung chuy·ªÉn kho·∫£n
            account_name (str): T√™n t√†i kho·∫£n
            template (str): Template (m·∫∑c ƒë·ªãnh t·ª´ settings)
        
        Returns:
            BytesIO: QR code image data ho·∫∑c None n·∫øu l·ªói
        """
        if template is None:
            template = settings.VIETQR_TEMPLATE
            
        encoded_desc = quote(description)
        encoded_name = quote(account_name)
        
        url = (f"{self.base_url}/{bank_id}-{account_no}-{template}.jpg?"
               f"amount={amount}&addInfo={encoded_desc}&accountName={encoded_name}")
        
        print(f"VietQR URL: {url}")
        
        try:
            response = requests.get(url, timeout=10)
            response.raise_for_status()
            
            # M·ªü ·∫£nh t·ª´ response
            image = Image.open(BytesIO(response.content))
            
            # Chuy·ªÉn ƒë·ªïi sang RGB n·∫øu c·∫ßn
            if image.mode in ('RGBA', 'LA', 'P'):
                image = image.convert('RGB')
            
            # L∆∞u v√†o BytesIO
            img_buffer = BytesIO()
            image.save(img_buffer, format='PNG')
            img_buffer.seek(0)
            
            print(f"‚úÖ T·∫°o VietQR code th√†nh c√¥ng trong b·ªô nh·ªõ")
            return img_buffer
            
        except requests.exceptions.RequestException as e:
            print(f"‚ùå L·ªói khi t·∫£i VietQR code: {e}")
            return None
        except Exception as e:
            print(f"‚ùå L·ªói x·ª≠ l√Ω VietQR: {e}")
            return None

    def generate_qr_description(self, qr_type: str, instance_code: str) -> str:
        """
        T·∫°o description cho QR code d·ª±a tr√™n type
        
        Args:
            qr_type (str): 'advance' ho·∫∑c 'payment'
            instance_code (str): Instance code
            
        Returns:
            str: QR description
        """
        if qr_type == 'advance':
            return f"Tam ung don {instance_code}"
        elif qr_type == 'payment':
            return f"Thanh toan don {instance_code}"
        else:
            return f"Don {instance_code}"  # Fallback

# Global service instance
vietqr_service = VietQRService()

============================================================

============================================================
FILE: app\utils\amount_detector.py
============================================================
from typing import Dict, List, Optional
from app.config.node_config import get_node_config
from app.utils.field_extractor import FieldExtractor

class AmountDetector:
    def __init__(self):
        self.field_extractor = FieldExtractor()
    
    def detect_available_amount_fields(self, form_data: List[Dict], node_config: Dict = None) -> Dict:
        """
        Scan form data ƒë·ªÉ t√¨m amount fields theo config c·ªßa node
        
        Args:
            form_data (list): Form data t·ª´ API response
            node_config (dict): Node configuration (optional)
            
        Returns:
            dict: Detection results v·ªõi c√°c fields v√† values
        """
        try:
            # S·ª≠ d·ª•ng config t·ª´ node thay v√¨ hardcode
            if node_config:
                advance_field = node_config.get('advance_field')
                payment_field = node_config.get('payment_field')
            else:
                # Fallback cho backward compatibility
                advance_field = "S·ªë ti·ªÅn t·∫°m ·ª©ng"
                payment_field = "S·ªë ti·ªÅn thanh to√°n"
            
            # Extract c·∫£ 2 fields (ch·ªâ khi field name kh√¥ng ph·∫£i None)
            advance_value = self.field_extractor.extract_field_value(form_data, advance_field) if advance_field else None
            payment_value = self.field_extractor.extract_field_value(form_data, payment_field) if payment_field else None
            
            # Debug: t√¨m t·∫•t c·∫£ fields c√≥ ch·ª©a "ti·ªÅn" ho·∫∑c "amount" 
            all_amount_fields = self.field_extractor.get_amount_fields(form_data)
            
            result = {
                'advance_amount': advance_value,
                'payment_amount': payment_value,
                'advance_field_found': advance_value is not None,
                'payment_field_found': payment_value is not None,
                'all_amount_fields': all_amount_fields,
                'fields_used': {
                    'advance_field': advance_field,
                    'payment_field': payment_field
                }
            }
            
            print(f"üí∞ Field detection results:")
            if advance_field:
                print(f"   - {advance_field}: {'‚úÖ ' + str(advance_value) if advance_value else '‚ùå Not found'}")
            else:
                print(f"   - Advance field: ‚ùå Not configured")
                
            if payment_field:
                print(f"   - {payment_field}: {'‚úÖ ' + str(payment_value) if payment_value else '‚ùå Not found'}")
            else:
                print(f"   - Payment field: ‚ùå Not configured")
                
            print(f"   - All amount fields: {list(all_amount_fields.keys())}")
            
            return result
            
        except Exception as e:
            print(f"‚ùå Error detecting amount fields: {e}")
            return {
                'advance_amount': None,
                'payment_amount': None,
                'advance_field_found': False,
                'payment_field_found': False,
                'all_amount_fields': {},
                'fields_used': {'advance_field': None, 'payment_field': None},
                'error': str(e)
            }
    
    def determine_qr_type_by_fields(self, field_detection_result: Dict) -> Dict:
        """
        Quy·∫øt ƒë·ªãnh QR type d·ª±a tr√™n fields c√≥ gi√° tr·ªã
        
        Args:
            field_detection_result (dict): K·∫øt qu·∫£ t·ª´ detect_available_amount_fields()
            
        Returns:
            dict: QR type decision result
        """
        try:
            advance_found = field_detection_result.get('advance_field_found', False)
            payment_found = field_detection_result.get('payment_field_found', False)
            advance_amount = field_detection_result.get('advance_amount')
            payment_amount = field_detection_result.get('payment_amount')

            fields_used = field_detection_result.get('fields_used', {})
            advance_field_name = fields_used.get('advance_field', 'S·ªë ti·ªÅn t·∫°m ·ª©ng')
            payment_field_name = fields_used.get('payment_field', 'S·ªë ti·ªÅn thanh to√°n')

            print(f"üéØ Determining QR type: advance={advance_found}, payment={payment_found}")
            
            # Logic priority: advance tr∆∞·ªõc, sau ƒë√≥ payment
            if advance_found and advance_amount:
                try:
                    amount_value = float(advance_amount)
                    if amount_value > 0:
                        return {
                            'qr_type': 'advance',
                            'amount': amount_value,
                            'field_used': advance_field_name,
                            'reason': 'Found valid advance amount'
                        }
                except (ValueError, TypeError):
                    print(f"‚ö†Ô∏è Invalid advance amount: {advance_amount}")
            
            if payment_found and payment_amount:
                try:
                    amount_value = float(payment_amount)
                    if amount_value > 0:
                        return {
                            'qr_type': 'payment', 
                            'amount': amount_value,
                            'field_used': payment_field_name,
                            'reason': 'Found valid payment amount'
                        }
                except (ValueError, TypeError):
                    print(f"‚ö†Ô∏è Invalid payment amount: {payment_amount}")
            
            # Kh√¥ng t√¨m th·∫•y field h·ª£p l·ªá
            return {
                'qr_type': 'none',
                'amount': None,
                'field_used': None,
                'reason': f'No valid amount found (advance_found={advance_found}, payment_found={payment_found})'
            }
            
        except Exception as e:
            print(f"‚ùå Error determining QR type: {e}")
            return {
                'qr_type': 'none',
                'amount': None,
                'field_used': None,
                'reason': f'Error: {str(e)}'
            }
    
    def get_amount_and_type_for_node(self, node_id: str, form_data: List[Dict]) -> Dict:
        """
        L·∫•y amount v√† QR type cho m·ªôt node c·ª• th·ªÉ d·ª±a tr√™n strategy c·ªßa node ƒë√≥
        
        Args:
            node_id (str): Node ID
            form_data (list): Form data t·ª´ API
            
        Returns:
            dict: Processing result v·ªõi success, qr_type, amount, etc.
        """
        try:
            node_config = get_node_config(node_id)
            if not node_config:
                return {
                    'success': False,
                    'qr_type': 'none',
                    'error': f'Node {node_id} not found in configuration'
                }
            
            strategy = node_config['strategy']
            node_name = node_config['name']
            
            print(f"üîç Processing node: {node_name} (strategy: {strategy})")
            
            # Detect available fields
            field_detection = self.detect_available_amount_fields(form_data, node_config)
            
            if strategy == "detect_both_fields":
                # Dual detection: c√≥ th·ªÉ l√† advance ho·∫∑c payment
                qr_decision = self.determine_qr_type_by_fields(field_detection)
                
                return {
                    'success': qr_decision['qr_type'] != 'none',
                    'qr_type': qr_decision['qr_type'],
                    'amount': qr_decision['amount'],
                    'field_used': qr_decision['field_used'],
                    'node_strategy': strategy,
                    'reason': f"Dual detection result: {qr_decision['reason']}",
                    'field_detection': field_detection
                }
                
            elif strategy == "payment_field_only":
                # Payment only: ch·ªâ check payment field
                payment_amount = field_detection.get('payment_amount')
                payment_found = field_detection.get('payment_field_found', False)
                payment_field_name = node_config.get('payment_field')

                if payment_found and payment_amount:
                    try:
                        amount_value = float(payment_amount)
                        if amount_value > 0:
                            return {
                                'success': True,
                                'qr_type': 'payment',
                                'amount': amount_value,
                                'field_used': payment_field_name,
                                'node_strategy': strategy,
                                'reason': 'Payment-only strategy: found valid payment amount',
                                'field_detection': field_detection
                            }
                    except (ValueError, TypeError):
                        pass
                
                return {
                    'success': False,
                    'qr_type': 'none',
                    'amount': None,
                    'field_used': None,
                    'node_strategy': strategy,
                    'reason': f'Payment-only strategy: no valid payment amount (found={payment_found}, value={payment_amount})',
                    'field_detection': field_detection
                }
            
            else:
                return {
                    'success': False,
                    'qr_type': 'none',
                    'error': f'Unknown strategy: {strategy}'
                }
                
        except Exception as e:
            print(f"‚ùå Error processing node {node_id}: {e}")
            return {
                'success': False,
                'qr_type': 'none',
                'error': str(e)
            }

============================================================

============================================================
FILE: app\utils\field_extractor.py
============================================================
from typing import List, Dict, Any, Optional

class FieldExtractor:
    def extract_field_value(self, form_data: List[Dict], field_name: str, debug: bool = False) -> Optional[Any]:
        """
        Enhanced version: Tr√≠ch xu·∫•t gi√° tr·ªã c·ªßa m·ªôt field t·ª´ form data v·ªõi better error handling
        
        Args:
            form_data (list): Form data t·ª´ API
            field_name (str): T√™n field c·∫ßn t√¨m
            debug (bool): In debug info
            
        Returns:
            Gi√° tr·ªã field ho·∫∑c None n·∫øu kh√¥ng t√¨m th·∫•y
        """
        try:
            if debug:
                print(f"üîç Searching for field: '{field_name}'")
                
            # Search in top-level fields
            for field in form_data:
                if field.get('name') == field_name:
                    value = field.get('value')
                    if debug:
                        print(f"‚úÖ Found '{field_name}' in top-level: {value}")
                    return value
                
                # Search in nested fieldList
                if field.get('type') == 'fieldList' and 'value' in field:
                    field_list_values = field['value']
                    if isinstance(field_list_values, list):
                        for field_group in field_list_values:
                            if isinstance(field_group, list):
                                for sub_field in field_group:
                                    if isinstance(sub_field, dict) and sub_field.get('name') == field_name:
                                        value = sub_field.get('value')
                                        if debug:
                                            print(f"‚úÖ Found '{field_name}' in fieldList: {value}")
                                        return value
            
            if debug:
                print(f"‚ùå Field '{field_name}' not found")
                print("Available fields:", [f.get('name') for f in form_data if f.get('name')])
                
            return None
            
        except Exception as e:
            print(f"‚ùå Error extracting field '{field_name}': {e}")
            return None

    def get_all_field_names(self, form_data: List[Dict]) -> List[str]:
        """
        L·∫•y t·∫•t c·∫£ field names t·ª´ form data
        
        Args:
            form_data: Form data t·ª´ API
            
        Returns:
            List[str]: Danh s√°ch t√™n fields
        """
        field_names = []
        
        try:
            for field in form_data:
                field_name = field.get('name')
                if field_name:
                    field_names.append(field_name)
                
                # Check nested fieldList
                if field.get('type') == 'fieldList' and 'value' in field:
                    field_list_values = field['value']
                    if isinstance(field_list_values, list):
                        for field_group in field_list_values:
                            if isinstance(field_group, list):
                                for sub_field in field_group:
                                    if isinstance(sub_field, dict):
                                        sub_field_name = sub_field.get('name')
                                        if sub_field_name:
                                            field_names.append(sub_field_name)
        except Exception as e:
            print(f"‚ùå Error getting field names: {e}")
        
        return list(set(field_names))  # Remove duplicates

    def get_amount_fields(self, form_data: List[Dict]) -> Dict[str, Any]:
        """
        T√¨m t·∫•t c·∫£ fields c√≥ ch·ª©a "ti·ªÅn" ho·∫∑c "amount"
        
        Args:
            form_data: Form data t·ª´ API
            
        Returns:
            Dict[str, Any]: Dict v·ªõi field name l√† key, value l√† gi√° tr·ªã
        """
        amount_fields = {}
        
        try:
            for field in form_data:
                field_name = field.get('name', '').lower()
                if 'ti·ªÅn' in field_name or 'amount' in field_name:
                    amount_fields[field.get('name')] = field.get('value')
        except Exception as e:
            print(f"‚ùå Error getting amount fields: {e}")
        
        return amount_fields

============================================================

============================================================
FILE: app\utils\helpers.py
============================================================
from typing import Optional, Dict, Any
from datetime import datetime
import pandas as pd
import json
import os

def extract_instance_code(event_data: Dict) -> Optional[str]:
    """Tr√≠ch xu·∫•t instance_code t·ª´ event"""
    try:
        event_body = event_data.get("event", {})
        if "instance_code" in event_body:
            return event_body["instance_code"]
            
        if "object" in event_body and "instance_code" in event_body["object"]:
            return event_body["object"]["instance_code"]
            
        return None
    except:
        return None

def get_event_type(event_data: Dict) -> str:
    """L·∫•y event type"""
    try:
        if "header" in event_data:
            return event_data["header"].get("event_type", "unknown")
        
        if "event" in event_data and "type" in event_data["event"]:
            return event_data["event"]["type"]
            
        return event_data.get("type", "unknown")
    except:
        return "unknown"

async def save_event_to_csv(event_data: Dict, events_file: str = "lark_events.csv"):
    """L∆∞u event v√†o CSV"""
    try:
        row_data = {
            "timestamp": datetime.now().isoformat(),
            "event_type": get_event_type(event_data),
            "instance_code": extract_instance_code(event_data),
            "raw_event": json.dumps(event_data, ensure_ascii=False)
        }
        
        df = pd.DataFrame([row_data])
        
        if os.path.exists(events_file):
            df.to_csv(events_file, mode='a', header=False, index=False, encoding='utf-8')
        else:
            df.to_csv(events_file, mode='w', header=True, index=False, encoding='utf-8')
            
        print(f"‚úÖ Event saved to {events_file}")
        
    except Exception as e:
        print(f"‚ùå Error saving event: {e}")

def format_currency(amount: float) -> str:
    """Format s·ªë ti·ªÅn theo ƒë·ªãnh d·∫°ng VND"""
    return f"{amount:,} VND"

def get_short_node_id(node_id: str, length: int = 8) -> str:
    """Get short version of node ID for display"""
    return node_id[:length] + "..." if len(node_id) > length else node_id

============================================================

============================================================
FILE: project_complete_info.txt
============================================================
================================================================================
TH√îNG TIN D·ª∞ √ÅN HO√ÄN CH·ªàNH
================================================================================
Th·ªùi gian t·∫°o: 2025-09-15 15:59:24
Th∆∞ m·ª•c g·ªëc: d:\Atino\extension\webhook-server-approval
================================================================================

üìÅ C·∫§U TR√öC THU M·ª§C
--------------------------------------------------
‚îú‚îÄ‚îÄ üìÅ app/
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ config/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ node_config.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ settings.py
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ models/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ approval.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ event.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ response.py
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ routers/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ config.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ debug.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ manual.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ webhook.py
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ services/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ cache_service.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ lark_service.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ qr_processor.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ validation_service.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ vietqr_service.py
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ utils/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ amount_detector.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ field_extractor.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ helpers.py
‚îú‚îÄ‚îÄ üìÑ .gitignore
‚îú‚îÄ‚îÄ üìÑ Dockerfile
‚îú‚îÄ‚îÄ üìÑ Get detail code.ipynb
‚îú‚îÄ‚îÄ üìÑ project_complete_info.txt
‚îú‚îÄ‚îÄ üìÑ README.md
‚îî‚îÄ‚îÄ üìÑ requirements.txt


üìÑ DANH S√ÅCH T·∫§T C·∫¢ FILE
--------------------------------------------------
.gitignore (594 bytes)
app\config\node_config.py (2877 bytes)
app\config\settings.py (1261 bytes)
app\models\approval.py (1584 bytes)
app\models\event.py (899 bytes)
app\models\response.py (1015 bytes)
app\routers\config.py (1637 bytes)
app\routers\debug.py (3444 bytes)
app\routers\manual.py (2574 bytes)
app\routers\webhook.py (1789 bytes)
app\services\cache_service.py (4384 bytes)
app\services\lark_service.py (8266 bytes)
app\services\qr_processor.py (15166 bytes)
app\services\validation_service.py (8994 bytes)
app\services\vietqr_service.py (3010 bytes)
app\utils\amount_detector.py (10152 bytes)
app\utils\field_extractor.py (4442 bytes)
app\utils\helpers.py (2198 bytes)
Dockerfile (726 bytes)
Get detail code.ipynb (9345 bytes)
project_complete_info.txt (0 bytes)
README.md (779 bytes)
requirements.txt (136 bytes)

T·ªïng c·ªông: 23 file

üíª N·ªòI DUNG T·∫§T C·∫¢ FILE CODE
================================================================================

============================================================
FILE: app\config\node_config.py
============================================================
"""Node configuration for different approval workflows"""

NODE_CONFIG = {
    "30e5338b60587c64c7cef5f6a7211ccb": {
        "name": "truong_phong_duyet",
        "type": "dual_detection",
        "advance_field": "S·ªë ti·ªÅn t·∫°m ·ª©ng",
        "payment_field": "S·ªë ti·ªÅn thanh to√°n",
        "strategy": "detect_both_fields",
        "required_status": "PENDING",
        "description": "Tr∆∞·ªüng ph√≤ng duy·ªát - Auto detect advance/payment"
    },
    "f23535375a26847ef71c1cbf0755f246": {
        "name": "thanh_toan_sau_tam_ung", 
        "type": "payment_only",
        "advance_field": None,
        "payment_field": "S·ªë ti·ªÅn c√≤n ph·∫£i thanh to√°n",
        "strategy": "payment_field_only",
        "required_status": "APPROVED",
        "additional_conditions": [
            {
                "node_id": "ef83b231885a1a77658f32808a199764",
                "required_status": "PENDING",
                "description": "Node ti·∫øp theo ph·∫£i PENDING"
            }
        ],
        "description": "Thanh to√°n sau t·∫°m ·ª©ng - Payment only (trigger on APPROVED + next node PENDING)"
    }
}

def get_node_config(node_id: str) -> dict:
    """
    L·∫•y configuration cho m·ªôt node_id c·ª• th·ªÉ
    
    Args:
        node_id (str): Node ID c·∫ßn l·∫•y config
        
    Returns:
        dict: Node config ho·∫∑c None n·∫øu kh√¥ng t√¨m th·∫•y
    """
    return NODE_CONFIG.get(node_id)

def get_node_strategy(node_id: str) -> str:
    """
    L·∫•y strategy c·ªßa m·ªôt node
    
    Args:
        node_id (str): Node ID
        
    Returns:
        str: Strategy name ho·∫∑c "unknown" n·∫øu kh√¥ng t√¨m th·∫•y
    """
    config = get_node_config(node_id)
    return config.get("strategy", "unknown") if config else "unknown"

def print_node_config_summary():
    """Print summary c·ªßa NODE_CONFIG v·ªõi additional conditions"""
    print("üìã NODE_CONFIG Summary:")
    for node_id, config in NODE_CONFIG.items():
        required_status = config.get('required_status', 'PENDING')
        additional_conditions = config.get('additional_conditions', [])
        
        print(f"   ‚Ä¢ {node_id[:8]}... - {config['name']} ({config['strategy']})")
        print(f"     Fields: advance='{config['advance_field']}', payment='{config['payment_field']}'")
        print(f"     Required Status: {required_status}")
        
        if additional_conditions:
            print(f"     Additional Conditions:")
            for condition in additional_conditions:
                print(f"       - {condition['node_id'][:8]}... must be {condition['required_status']}")

def get_configured_node_ids():
    """Tr·∫£ v·ªÅ list t·∫•t c·∫£ node IDs ƒë∆∞·ª£c c·∫•u h√¨nh"""
    return list(NODE_CONFIG.keys())

# Backward compatibility
ALLOWED_NODE_IDS = get_configured_node_ids()

============================================================

============================================================
FILE: app\config\settings.py
============================================================
import os
from typing import Optional

class Settings:
    # FastAPI settings
    DEBUG: bool = os.getenv("DEBUG", "false").lower() == "true"
    PORT: int = int(os.getenv("PORT", "8000"))
    
    # Lark API settings
    LARK_APP_ID: str = os.getenv("LARK_APP_ID", "cli_a758ffaf41f8502f")
    LARK_APP_SECRET: str = os.getenv("LARK_APP_SECRET", "45Jsgm3TYfEwD2F67BH1LctlYEcCjZpH")
    BASE_URL: str = "https://open.larksuite.com/open-apis"
    APPROVAL_UPLOAD_URL: str = "https://www.larksuite.com/approval/openapi/v2/file/upload"
    
    # VietQR settings
    VIETQR_TEMPLATE: str = "compact2"
    VIETQR_BASE_URL: str = "https://img.vietqr.io/image"
    
    # Cache settings
    QR_CACHE_DURATION_MINUTES: int = 5
    TOKEN_CACHE_BUFFER_SECONDS: int = 300  # 5 minutes buffer
    
    # File settings
    EVENTS_FILE: str = "lark_events.csv"
    
    # Default user for comments
    DEFAULT_USER_ID: str = "cd11b141"
    
    # Validation settings (for future extensions)
    ENABLE_AMOUNT_VALIDATION: bool = os.getenv("ENABLE_AMOUNT_VALIDATION", "false").lower() == "true"
    ENABLE_WORKFLOW_ALERTS: bool = os.getenv("ENABLE_WORKFLOW_ALERTS", "false").lower() == "true"

# Global settings instance
settings = Settings()

============================================================

============================================================
FILE: app\models\approval.py
============================================================
from pydantic import BaseModel
from typing import Optional, List, Dict, Any

class FormField(BaseModel):
    name: Optional[str] = None
    type: Optional[str] = None
    value: Optional[Any] = None

class TaskInfo(BaseModel):
    node_id: Optional[str] = None
    status: Optional[str] = None
    task_id: Optional[str] = None
    node_name: Optional[str] = None

class ApprovalInstance(BaseModel):
    instance_code: str
    status: Optional[str] = None
    form: Optional[str] = None
    task_list: Optional[List[TaskInfo]] = None

class AmountDetectionResult(BaseModel):
    advance_amount: Optional[float] = None
    payment_amount: Optional[float] = None
    advance_field_found: bool = False
    payment_field_found: bool = False
    all_amount_fields: Dict[str, Any] = {}
    fields_used: Dict[str, Optional[str]] = {}

class QRTypeResult(BaseModel):
    qr_type: str  # 'advance', 'payment', 'none'
    amount: Optional[float] = None
    field_used: Optional[str] = None
    reason: str

class NodeProcessingResult(BaseModel):
    success: bool
    qr_type: str = 'none'
    amount: Optional[float] = None
    field_used: Optional[str] = None
    node_strategy: Optional[str] = None
    reason: Optional[str] = None
    error: Optional[str] = None
    field_detection: Optional[AmountDetectionResult] = None

class ValidationResult(BaseModel):
    """Model for validation results - extensible for future validations"""
    is_valid: bool
    validation_type: str
    message: str
    details: Optional[Dict[str, Any]] = None

============================================================

============================================================
FILE: app\models\event.py
============================================================
from pydantic import BaseModel
from typing import Optional, Dict, Any
from datetime import datetime

class EventHeader(BaseModel):
    event_id: Optional[str] = None
    event_type: Optional[str] = None
    create_time: Optional[str] = None
    token: Optional[str] = None
    tenant_key: Optional[str] = None
    app_id: Optional[str] = None

class EventBody(BaseModel):
    instance_code: Optional[str] = None
    type: Optional[str] = None
    object: Optional[Dict[str, Any]] = None

class LarkEvent(BaseModel):
    schema: Optional[str] = None
    header: Optional[EventHeader] = None
    event: Optional[EventBody] = None
    type: Optional[str] = None  # For URL verification
    challenge: Optional[str] = None  # For URL verification

class EventRecord(BaseModel):
    timestamp: datetime
    event_type: str
    instance_code: Optional[str]
    raw_event: str

============================================================

============================================================
FILE: app\models\response.py
============================================================
from pydantic import BaseModel
from typing import Optional, Dict, Any, List

class APIResponse(BaseModel):
    success: bool
    message: Optional[str] = None
    data: Optional[Dict[str, Any]] = None
    error: Optional[str] = None

class UploadResult(BaseModel):
    success: bool
    file_code: Optional[str] = None
    file_url: Optional[str] = None
    error: Optional[str] = None

class CommentResult(BaseModel):
    success: bool
    comment_id: Optional[str] = None
    error: Optional[str] = None

class QRGenerationResult(BaseModel):
    success: bool
    qr_type: Optional[str] = None
    amount: Optional[float] = None
    field_used: Optional[str] = None
    node_name: Optional[str] = None
    comment_id: Optional[str] = None
    error: Optional[str] = None
    processing_info: Optional[Dict[str, Any]] = None

class CacheStatus(BaseModel):
    total_cached_qr: int
    active_cache: Dict[str, Dict[str, Any]]
    cache_duration_minutes: int
    current_time: str

============================================================

============================================================
FILE: app\routers\config.py
============================================================
from fastapi import APIRouter
from app.config.node_config import NODE_CONFIG, get_node_config, get_configured_node_ids
from app.services.cache_service import cache_service

router = APIRouter()

@router.get("/node-ids")
async def get_allowed_node_ids():
    """Xem danh s√°ch allowed node IDs hi·ªán t·∫°i"""
    return {
        "allowed_node_ids": get_configured_node_ids(),
        "total_allowed": len(NODE_CONFIG)
    }

@router.get("/nodes")
async def get_node_configuration():
    """Xem chi ti·∫øt NODE_CONFIG"""
    return {
        "node_config": NODE_CONFIG,
        "total_nodes": len(NODE_CONFIG),
        "configured_node_ids": list(NODE_CONFIG.keys()),
        "strategies": {
            node_id: config["strategy"] 
            for node_id, config in NODE_CONFIG.items()
        }
    }

@router.get("/nodes/{node_id}")
async def get_specific_node_config(node_id: str):
    """Xem config c·ªßa m·ªôt node c·ª• th·ªÉ"""
    config = get_node_config(node_id)
    if config:
        return {
            "node_id": node_id,
            "config": config,
            "short_id": node_id[:8] + "..."
        }
    else:
        return {
            "error": f"Node ID {node_id} not found in configuration",
            "available_nodes": list(NODE_CONFIG.keys())
        }

@router.get("/cache/qr-status")
async def get_qr_cache_status():
    """Xem tr·∫°ng th√°i cache QR generation"""
    return cache_service.get_cache_status()

@router.post("/cache/clear")
async def clear_qr_cache():
    """Clear cache QR generation manually"""
    return cache_service.clear_cache()

============================================================

============================================================
FILE: app\routers\debug.py
============================================================
from fastapi import APIRouter
import json
from app.services.lark_service import lark_service
from app.services.qr_processor import qr_processor
from app.utils.amount_detector import AmountDetector
from app.config.node_config import NODE_CONFIG

router = APIRouter()
amount_detector = AmountDetector()

@router.get("/instance/{instance_code}")
async def debug_instance(instance_code: str):
    """Debug instance v·ªõi NODE_CONFIG"""
    try:
        access_token = await lark_service.get_access_token()
        if not access_token:
            return {"error": "Cannot get access token"}
        
        api_response = await lark_service.get_approval_instance(instance_code, access_token)
        if not api_response:
            return {"error": "Cannot get instance data"}
        
        # S·ª≠ d·ª•ng function v·ªõi NODE_CONFIG
        check_result = qr_processor.check_pending_allowed_node_in_task_list(api_response)
        
        return {
            "instance_code": instance_code,
            "node_check_result": check_result,
            "node_config": NODE_CONFIG,
            "will_generate_qr": check_result['found'],
            "reason": f"Found {check_result.get('strategy', 'unknown')} node with required status" if check_result['found'] else "No matching configured nodes found"
        }
            
    except Exception as e:
        return {"error": str(e)}

@router.get("/instance/{instance_code}/fields")
async def debug_instance_fields(instance_code: str):
    """Debug chi ti·∫øt v·ªÅ fields trong form c·ªßa instance"""
    try:
        access_token = await lark_service.get_access_token()
        if not access_token:
            return {"error": "Cannot get access token"}
        
        api_response = await lark_service.get_approval_instance(instance_code, access_token)
        if not api_response:
            return {"error": "Cannot get instance data"}
            
        if 'data' not in api_response or 'form' not in api_response['data']:
            return {"error": "No form data found"}
            
        form_str = api_response['data']['form']
        form_data = json.loads(form_str)
        
        # Enhanced field detection
        field_detection = amount_detector.detect_available_amount_fields(form_data)
        
        # Test v·ªõi t·∫•t c·∫£ configured nodes
        node_results = {}
        for node_id, config in NODE_CONFIG.items():
            node_result = amount_detector.get_amount_and_type_for_node(node_id, form_data)
            node_results[config['name']] = {
                'node_id': node_id[:8] + '...',
                'strategy': config['strategy'],
                'result': node_result
            }
        
        # Extract t·∫•t c·∫£ field names ƒë·ªÉ debug
        all_fields = []
        for field in form_data:
            field_info = {
                'name': field.get('name'),
                'type': field.get('type'),
                'value': field.get('value')
            }
            all_fields.append(field_info)
        
        return {
            "instance_code": instance_code,
            "field_detection": field_detection,
            "node_processing_results": node_results,
            "all_form_fields": all_fields,
            "total_fields": len(all_fields)
        }
            
    except Exception as e:
        return {"error": str(e)}

============================================================

============================================================
FILE: app\routers\manual.py
============================================================
from fastapi import APIRouter
import json
from app.services.lark_service import lark_service
from app.services.qr_processor import qr_processor
from app.utils.amount_detector import AmountDetector
import os
import pandas as pd
from app.config.settings import settings

router = APIRouter()
amount_detector = AmountDetector()

@router.post("/process/{instance_code}")
async def manual_process_instance(instance_code: str):
    """Enhanced manual processing v·ªõi detailed results"""
    try:
        access_token = await lark_service.get_access_token()
        if not access_token:
            return {"success": False, "error": "Cannot get access token"}
        
        # Get detailed processing info tr∆∞·ªõc khi process
        api_response = await lark_service.get_approval_instance(instance_code, access_token)
        
        processing_info = {"instance_code": instance_code}
        
        if api_response:
            # Get node check info
            node_check = qr_processor.check_pending_allowed_node_in_task_list(api_response)
            processing_info["node_check"] = node_check
            
            # Get field detection info if node found
            if node_check['found'] and 'data' in api_response and 'form' in api_response['data']:
                form_str = api_response['data']['form']
                form_data = json.loads(form_str)
                
                node_id = node_check['node_id']
                amount_result = amount_detector.get_amount_and_type_for_node(node_id, form_data)
                processing_info["amount_detection"] = amount_result
        
        # Process the instance
        result = await qr_processor.process_approval_with_qr_comment(instance_code, access_token)
        
        return {
            "success": result,
            "message": f"{'Successfully processed' if result else 'Failed to process'} instance {instance_code}",
            "processing_info": processing_info
        }
            
    except Exception as e:
        return {"success": False, "error": str(e)}

@router.get("/events")
async def get_events():
    """Xem events ƒë√£ nh·∫≠n"""
    try:
        if os.path.exists(settings.EVENTS_FILE):
            df = pd.read_csv(settings.EVENTS_FILE, encoding='utf-8')
            return {
                "total_events": len(df),
                "latest_events": df.tail(20).to_dict('records')
            }
        return {"message": "No events found"}
    except Exception as e:
        return {"error": str(e)}

============================================================

============================================================
FILE: app\routers\webhook.py
============================================================
from fastapi import APIRouter, Request
from fastapi.responses import JSONResponse
from app.services.lark_service import lark_service
from app.services.qr_processor import qr_processor
from app.utils.helpers import save_event_to_csv, get_event_type, extract_instance_code
from app.config.settings import settings

router = APIRouter()

@router.post("/webhook")
async def handle_lark_webhook(request: Request):
    try:
        data = await request.json()
        print(f"üì® Received webhook: {get_event_type(data)}")
        
        # Handle URL verification
        if data.get("type") == "url_verification":
            return JSONResponse(content={"challenge": data.get("challenge")})
        
        # L∆∞u event v√†o CSV
        await save_event_to_csv(data, settings.EVENTS_FILE)
        
        # X·ª≠ l√Ω approval event
        event_type = get_event_type(data)
        if "approval" in event_type.lower():
            instance_code = extract_instance_code(data)
            if instance_code:
                print(f"üîç Processing approval instance: {instance_code}")
                
                # L·∫•y access token
                access_token = await lark_service.get_access_token()
                if access_token:
                    # X·ª≠ l√Ω t·ª± ƒë·ªông: check node_id -> l·∫•y th√¥ng tin -> t·∫°o QR -> upload -> comment
                    await qr_processor.process_approval_with_qr_comment(instance_code, access_token)
                else:
                    print("‚ùå Kh√¥ng th·ªÉ l·∫•y access token")
        
        return JSONResponse(content={"status": "success"})
        
    except Exception as e:
        print(f"‚ùå Error: {e}")
        return JSONResponse(content={"error": str(e)}, status_code=500)

============================================================

============================================================
FILE: app\services\cache_service.py
============================================================
from datetime import datetime, timedelta
from typing import Dict, Optional

class CacheService:
    def __init__(self):
        self.qr_generation_cache: Dict[str, datetime] = {}
    
    def generate_cache_key(self, instance_code: str, node_id: str, qr_type: str) -> str:
        """
        T·∫°o cache key ƒë·ªÉ detect duplicate
        
        Args:
            instance_code (str): Instance code
            node_id (str): Node ID (8 k√Ω t·ª± ƒë·∫ßu)
            qr_type (str): 'advance' ho·∫∑c 'payment'
            
        Returns:
            str: Unique cache key
        """
        short_node_id = node_id[:8] if len(node_id) > 8 else node_id
        return f"{instance_code}_{short_node_id}_{qr_type}"

    def is_qr_recently_generated(self, instance_code: str, node_id: str, qr_type: str, 
                               cache_duration_minutes: int = 5) -> bool:
        """
        Check xem QR ƒë√£ ƒë∆∞·ª£c t·∫°o trong th·ªùi gian g·∫ßn ƒë√¢y ch∆∞a
        
        Returns:
            bool: True n·∫øu ƒë√£ t·∫°o g·∫ßn ƒë√¢y, False n·∫øu ch∆∞a ho·∫∑c ƒë√£ h·∫øt h·∫°n
        """
        try:
            cache_key = self.generate_cache_key(instance_code, node_id, qr_type)
            
            if cache_key not in self.qr_generation_cache:
                print(f"üÜï Cache miss: {cache_key} - ch∆∞a t·∫°o QR")
                return False
            
            generated_time = self.qr_generation_cache[cache_key]
            current_time = datetime.now()
            time_diff = current_time - generated_time
            
            if time_diff > timedelta(minutes=cache_duration_minutes):
                del self.qr_generation_cache[cache_key] 
                print(f"‚è∞ Cache expired: {cache_key} ({time_diff.total_seconds()/60:.1f} minutes ago)")
                return False
            
            print(f"üîí Cache hit: {cache_key} - QR ƒë√£ t·∫°o {time_diff.total_seconds()/60:.1f} ph√∫t tr∆∞·ªõc")
            return True
            
        except Exception as e:
            print(f"‚ùå Error checking cache: {e}")
            return False

    def mark_qr_as_generated(self, instance_code: str, node_id: str, qr_type: str):
        """ƒê√°nh d·∫•u QR ƒë√£ ƒë∆∞·ª£c t·∫°o"""
        try:
            cache_key = self.generate_cache_key(instance_code, node_id, qr_type)
            self.qr_generation_cache[cache_key] = datetime.now()
            
            print(f"üîí Marked QR as generated: {cache_key}")
            print(f"üìä Cache size: {len(self.qr_generation_cache)} entries")
            
        except Exception as e:
            print(f"‚ùå Error marking cache: {e}")

    def get_cache_status(self) -> Dict:
        """L·∫•y tr·∫°ng th√°i cache"""
        try:
            current_time = datetime.now()
            active_cache = {}
            
            for cache_key, generated_time in self.qr_generation_cache.items():
                time_diff = current_time - generated_time
                minutes_ago = time_diff.total_seconds() / 60
                
                active_cache[cache_key] = {
                    'generated_at': generated_time.isoformat(),
                    'minutes_ago': round(minutes_ago, 1),
                    'will_expire_in_minutes': max(0, 5 - minutes_ago)
                }
            
            return {
                'total_cached_qr': len(self.qr_generation_cache),
                'active_cache': active_cache,
                'cache_duration_minutes': 5,
                'current_time': current_time.isoformat()
            }
            
        except Exception as e:
            return {"error": str(e)}

    def clear_cache(self) -> Dict:
        """Clear t·∫•t c·∫£ cache"""
        try:
            old_count = len(self.qr_generation_cache)
            old_keys = list(self.qr_generation_cache.keys())
            
            self.qr_generation_cache.clear()
            
            return {
                'message': f'Successfully cleared {old_count} cache entries',
                'cleared_keys': old_keys,
                'current_cache_size': len(self.qr_generation_cache)
            }
            
        except Exception as e:
            return {"success": False, "error": str(e)}

# Global cache instance
cache_service = CacheService()

============================================================

============================================================
FILE: app\services\lark_service.py
============================================================
import requests
import json
from datetime import datetime
from typing import Optional, Dict, Any
from app.config.settings import settings

class LarkService:
    def __init__(self):
        self.access_token_cache = {"token": None, "expires_at": None}
    
    async def get_access_token(self) -> Optional[str]:
        """L·∫•y access token t·ª´ LarkSuite v·ªõi caching"""
        current_time = datetime.now().timestamp()
        
        if (self.access_token_cache["token"] and 
            self.access_token_cache["expires_at"] and 
            current_time < self.access_token_cache["expires_at"]):
            return self.access_token_cache["token"]
        
        try:
            url = f"{settings.BASE_URL}/auth/v3/tenant_access_token/internal"
            payload = {
                "app_id": settings.LARK_APP_ID,
                "app_secret": settings.LARK_APP_SECRET
            }
            
            response = requests.post(url, json=payload, timeout=10)
            data = response.json()
            
            if data.get("code") == 0:
                token = data["tenant_access_token"]
                expires_in = data.get("expire", 7200)
                
                self.access_token_cache["token"] = token
                self.access_token_cache["expires_at"] = current_time + expires_in - settings.TOKEN_CACHE_BUFFER_SECONDS
                
                print(f"‚úÖ Got access token")
                return token
            else:
                print(f"‚ùå Failed to get token: {data}")
                return None
                
        except Exception as e:
            print(f"‚ùå Error getting token: {e}")
            return None

    async def get_approval_instance(self, instance_code: str, access_token: str) -> Optional[Dict]:
        """L·∫•y th√¥ng tin approval instance"""
        try:
            url = f"{settings.BASE_URL}/approval/v4/instances/{instance_code}"
            headers = {"Authorization": f"Bearer {access_token}"}
            
            print(f"üîç L·∫•y th√¥ng tin instance: {instance_code}")
            response = requests.get(url, headers=headers, timeout=10)
            
            if response.status_code != 200:
                print(f"‚ùå L·ªói API call: {response.status_code}")
                return None
                
            api_response = response.json()
            
            if api_response.get("code") != 0:
                print(f"‚ùå API response error: {api_response}")
                return None
                
            return api_response
            
        except Exception as e:
            print(f"‚ùå Error getting approval instance: {e}")
            return None

    async def upload_image_to_approval(self, image_buffer, filename: str, access_token: str) -> Dict:
        """Upload ·∫£nh l√™n Lark Approval API"""
        try:
            image_buffer.seek(0)
            
            files = {
                'name': (None, filename),
                'type': (None, 'image'),
                'content': (filename, image_buffer, 'image/png')
            }
            
            headers = {
                'Authorization': f'Bearer {access_token}'
            }
            
            print(f"üì§ ƒêang upload ·∫£nh: {filename}")
            response = requests.post(settings.APPROVAL_UPLOAD_URL, files=files, headers=headers)
            
            if response.status_code == 200:
                data = response.json()
                if data.get('code') == 0:
                    file_code = data['data']['code']
                    file_url = data['data']['url']
                    print(f'‚úÖ Upload ·∫£nh th√†nh c√¥ng! File code: {file_code}')
                    return {
                        'success': True,
                        'file_code': file_code,
                        'file_url': file_url
                    }
                else:
                    error_msg = f"API error: {data.get('msg')} (code: {data.get('code')})"
                    print(f'‚ùå Upload th·∫•t b·∫°i: {error_msg}')
                    return {'success': False, 'error': error_msg}
            else:
                error_msg = f"HTTP error: {response.status_code}"
                print(f'‚ùå Upload th·∫•t b·∫°i: {error_msg}')
                return {'success': False, 'error': error_msg}
                
        except Exception as e:
            error_msg = f"Exception: {str(e)}"
            print(f"‚ùå L·ªói upload: {error_msg}")
            return {'success': False, 'error': error_msg}

    async def create_enhanced_comment_with_image(self, instance_code: str, file_url: str, file_code: str, 
                                               filename: str, qr_type: str, amount: int, node_name: str,
                                               access_token: str, user_id: str = None) -> Dict:
        """T·∫°o comment v·ªõi ·∫£nh v√† th√¥ng tin chi ti·∫øt"""
        try:
            if user_id is None:
                user_id = settings.DEFAULT_USER_ID
                
            create_comment_url = f'{settings.BASE_URL}/approval/v4/instances/{instance_code}/comments'
            
            params = {
                "user_id": user_id,
                "user_id_type": "user_id"
            }
            
            # Enhanced comment text v·ªõi type info
            qr_type_display = {
                'advance': 'T·∫†M ·ª®NG',
                'payment': 'THANH TO√ÅN'
            }
            
            comment_text = f"""üè¶ M√£ VietQR {qr_type_display.get(qr_type, qr_type.upper())}
            üí∞ S·ªë ti·ªÅn: {amount:,} VND
            üìã Node: {node_name}
            üìÑ Instance: {instance_code}"""

            # Estimate file size
            try:
                file_size = len(filename) * 100  # Rough estimate
            except:
                file_size = 50000  # Default estimate
            
            content_data = {
                "text": comment_text,
                "files": [{
                    "url": file_url,
                    "fileSize": file_size,
                    "title": filename,
                    "type": "image",
                    "extra": file_code
                }]
            }
            
            request_body = {
                "content": json.dumps(content_data, ensure_ascii=False)
            }
            
            headers_comment = {
                'Authorization': f'Bearer {access_token}',
                'Content-Type': 'application/json'
            }
            
            print(f"üì§ ƒêang t·∫°o enhanced comment cho instance: {instance_code}")
            print(f"   Comment: {comment_text.replace(chr(10), ' | ')}")
            
            response = requests.post(
                create_comment_url, 
                params=params,
                json=request_body, 
                headers=headers_comment
            )
            
            if response.status_code == 200:
                comment_result = response.json()
                if comment_result.get('code') == 0:
                    comment_id = comment_result.get("data", {}).get("comment_id", "N/A")
                    print(f'‚úÖ T·∫°o enhanced comment th√†nh c√¥ng! Comment ID: {comment_id}')
                    return {'success': True, 'comment_id': comment_id}
                else:
                    error_msg = f"API error: {comment_result.get('msg')} (code: {comment_result.get('code')})"
                    print(f'‚ùå T·∫°o comment th·∫•t b·∫°i: {error_msg}')
                    return {'success': False, 'error': error_msg}
            else:
                error_msg = f"HTTP error: {response.status_code}"
                print(f'‚ùå T·∫°o comment th·∫•t b·∫°i: {error_msg}')
                return {'success': False, 'error': error_msg}
                
        except Exception as e:
            error_msg = f"Exception: {str(e)}"
            print(f"‚ùå L·ªói t·∫°o enhanced comment: {error_msg}")
            return {'success': False, 'error': error_msg}

# Global service instance
lark_service = LarkService()

============================================================

============================================================
FILE: app\services\qr_processor.py
============================================================
"""
QR Processing Service - Main business logic for QR generation and processing
"""
import json
from typing import Dict, Optional, List
from app.config.settings import settings
from app.config.node_config import NODE_CONFIG, get_node_config
from app.services.lark_service import lark_service
from app.services.vietqr_service import vietqr_service
from app.services.cache_service import cache_service
from app.services.validation_service import validation_service
from app.utils.field_extractor import FieldExtractor
from app.utils.amount_detector import AmountDetector
from app.models.approval import NodeProcessingResult

class QRProcessor:
    def __init__(self):
        self.field_extractor = FieldExtractor()
        self.amount_detector = AmountDetector()
    
    def check_pending_allowed_node_in_task_list(self, api_response: dict, node_config: dict = None) -> dict:
        """
        Ki·ªÉm tra node c√≥ status ph√π h·ª£p + additional conditions
        """
        if node_config is None:
            node_config = NODE_CONFIG
            
        try:
            data = api_response.get('data', {})
            task_list = data.get('task_list', [])
            configured_node_ids = list(node_config.keys())
            
            # T·∫°o dict ƒë·ªÉ lookup status c·ªßa t·∫•t c·∫£ nodes
            node_status_map = {}
            for task in task_list:
                node_id = task.get('node_id')
                status = task.get('status', 'UNKNOWN')
                if node_id:
                    node_status_map[node_id] = status
            
            print(f"üîç Checking nodes with additional conditions:")
            for node_id, config in node_config.items():
                required_status = config.get('required_status', 'PENDING')
                additional_conditions = config.get('additional_conditions', [])
                print(f"   ‚Ä¢ {node_id[:8]}... - {config['name']} (requires: {required_status})")
                if additional_conditions:
                    for condition in additional_conditions:
                        print(f"     + Additional: {condition['node_id'][:8]}... must be {condition['required_status']}")
            
            print(f"üìã Task list contains {len(task_list)} tasks")
            
            matching_configured_nodes = []
            
            for node_id in configured_node_ids:
                config = node_config[node_id]
                required_status = config.get('required_status', 'PENDING')
                current_status = node_status_map.get(node_id, 'NOT_FOUND')
                
                # Check primary condition
                if current_status != required_status:
                    continue
                    
                # Check additional conditions
                additional_conditions = config.get('additional_conditions', [])
                all_conditions_met = True
                
                for condition in additional_conditions:
                    condition_node_id = condition['node_id']
                    condition_required_status = condition['required_status']
                    condition_current_status = node_status_map.get(condition_node_id, 'NOT_FOUND')
                    
                    print(f"üîç Checking additional condition: {condition_node_id[:8]}... ")
                    print(f"   Required: {condition_required_status}, Current: {condition_current_status}")
                    
                    if condition_current_status != condition_required_status:
                        all_conditions_met = False
                        print(f"‚ùå Additional condition not met for {node_id[:8]}...")
                        break
                    else:
                        print(f"‚úÖ Additional condition met")
                
                if all_conditions_met:
                    matching_configured_nodes.append({
                        'node_id': node_id,
                        'config': config,
                        'strategy': config['strategy'],
                        'matched_status': current_status,
                        'required_status': required_status,
                        'additional_conditions_met': True
                    })
                    print(f"‚úÖ Full match found: {node_id[:8]}... ({config['name']}) - Status: {current_status}")
            
            # Return first matching configured node
            if matching_configured_nodes:
                first_matching = matching_configured_nodes[0]
                return {
                    'found': True,
                    'node_id': first_matching['node_id'],
                    'node_config': first_matching['config'],
                    'strategy': first_matching['strategy'],
                    'matched_status': first_matching['matched_status'],
                    'required_status': first_matching['required_status'],
                    'all_tasks': task_list,
                    'all_matching_configured': matching_configured_nodes,
                    'node_status_map': node_status_map
                }
            else:
                print(f"‚ùå No nodes matching all conditions found")
                return {
                    'found': False,
                    'node_id': None,
                    'node_config': None,
                    'strategy': None,
                    'matched_status': None,
                    'all_tasks': task_list,
                    'all_matching_configured': [],
                    'node_status_map': node_status_map
                }
            
        except Exception as e:
            print(f"‚ùå Error checking nodes: {e}")
            return {
                'found': False,
                'error': str(e),
                'all_tasks': [],
                'all_matching_configured': []
            }
    
    def validate_amount_value(self, amount_value) -> dict:
        """Validate v√† convert amount value"""
        try:
            if amount_value is None:
                return {'valid': False, 'amount': None, 'error': 'Amount is None'}
                
            # Convert to float first, then int
            amount_float = float(amount_value)
            amount_int = int(amount_float)
            
            if amount_int <= 0:
                return {'valid': False, 'amount': amount_int, 'error': 'Amount must be positive'}
                
            return {'valid': True, 'amount': amount_int, 'error': None}
            
        except (ValueError, TypeError) as e:
            return {'valid': False, 'amount': None, 'error': f'Invalid amount format: {str(e)}'}
    
    async def process_approval_with_qr_comment(self, instance_code: str, access_token: str) -> bool:
        """
        Enhanced version v·ªõi duplicate detection v√† validation
        X·ª≠ l√Ω approval v·ªõi smart field detection, multiple node support v√† flexible status requirements
        """
        try:
            # L·∫•y instance details
            api_response = await lark_service.get_approval_instance(instance_code, access_token)
            if not api_response:
                return False
            
            # Check nodes v·ªõi required status
            node_check_result = self.check_pending_allowed_node_in_task_list(api_response)
            
            if not node_check_result['found']:
                print(f"‚è≠Ô∏è Skipping QR generation - no matching configured nodes found")
                return True  # Return True v√¨ kh√¥ng ph·∫£i l·ªói, ch·ªâ l√† skip
            
            matching_node_id = node_check_result['node_id']
            node_config = node_check_result['node_config']
            node_strategy = node_check_result['strategy']
            matched_status = node_check_result.get('matched_status', 'UNKNOWN')
            required_status = node_check_result.get('required_status', 'PENDING')
            
            print(f"‚úÖ Processing node: {node_config['name']} (strategy: {node_strategy})")
            print(f"   Status: {matched_status} (required: {required_status})")
            
            # Extract form data
            if 'data' not in api_response or 'form' not in api_response['data']:
                print("‚ùå Kh√¥ng t√¨m th·∫•y form data")
                return False
                
            form_str = api_response['data']['form']
            form_data = json.loads(form_str)
            
            # NEW: Run validations if enabled
            if settings.ENABLE_AMOUNT_VALIDATION or settings.ENABLE_WORKFLOW_ALERTS:
                task_list = api_response.get('data', {}).get('task_list', [])
                validation_results = validation_service.run_all_validations(
                    form_data, task_list, matching_node_id
                )
                
                # Log validation results
                for result in validation_results:
                    print(f"üîç Validation: {result.message}")
                    if not result.is_valid and settings.ENABLE_WORKFLOW_ALERTS:
                        # TODO: Implement alert system (email, Slack, etc.)
                        print(f"üö® ALERT: {result.message}")
            
            # Smart field detection theo node strategy
            amount_result = self.amount_detector.get_amount_and_type_for_node(matching_node_id, form_data)
            
            if not amount_result['success']:
                print(f"‚ùå Cannot determine amount/type: {amount_result.get('reason', 'Unknown error')}")
                if 'error' in amount_result:
                    print(f"    Error details: {amount_result['error']}")
                return False
            
            qr_type = amount_result['qr_type']
            amount_value = amount_result['amount']
            field_used = amount_result['field_used']
            
            # Check duplicate TR∆Ø·ªöC KHI t·∫°o QR
            if cache_service.is_qr_recently_generated(
                instance_code, matching_node_id, qr_type, 
                settings.QR_CACHE_DURATION_MINUTES
            ):
                print(f"‚ö†Ô∏è DUPLICATE DETECTED: QR {qr_type.upper()} for node {node_config['name']} already generated recently")
                print(f"   ‚Üí SKIPPING QR generation to prevent duplicate")
                return True  # Return success v√¨ kh√¥ng ph·∫£i l·ªói, ch·ªâ l√† skip duplicate
            
            print(f"üí∞ QR Generation Details:")
            print(f"   - Type: {qr_type}")
            print(f"   - Amount: {amount_value:,} VND")
            print(f"   - Field used: {field_used}")
            print(f"   - Node strategy: {node_strategy}")
            print(f"   - Trigger status: {matched_status}")
            
            # Validate amount
            amount_validation = self.validate_amount_value(amount_value)
            if not amount_validation['valid']:
                print(f"‚ùå Invalid amount: {amount_validation['error']}")
                return False
                
            amount_int = amount_validation['amount']
            
            # Extract th√¥ng tin ng√¢n h√†ng
            bank_id = self.field_extractor.extract_field_value(form_data, 'Ng√¢n h√†ng')
            account_no = self.field_extractor.extract_field_value(form_data, 'S·ªë t√†i kho·∫£n ng√¢n h√†ng')
            account_name = self.field_extractor.extract_field_value(form_data, 'T√™n ng∆∞·ªùi th·ª• h∆∞·ªüng')
            
            # Ki·ªÉm tra th√¥ng tin ng√¢n h√†ng
            if not all([bank_id, account_no, account_name]):
                missing_fields = []
                if not bank_id: missing_fields.append('Ng√¢n h√†ng')
                if not account_no: missing_fields.append('S·ªë t√†i kho·∫£n ng√¢n h√†ng')
                if not account_name: missing_fields.append('T√™n ng∆∞·ªùi th·ª• h∆∞·ªüng')
                
                print(f"‚ùå Thi·∫øu th√¥ng tin ng√¢n h√†ng: {', '.join(missing_fields)}")
                return False
            
            # Generate QR description theo type
            description = vietqr_service.generate_qr_description(qr_type, instance_code)
            
            print(f"üè¶ T·∫°o VietQR v·ªõi th√¥ng tin:")
            print(f"   - Ng√¢n h√†ng: {bank_id}")
            print(f"   - S·ªë TK: {account_no}")
            print(f"   - T√™n: {account_name}")
            print(f"   - S·ªë ti·ªÅn: {amount_int:,} VND")
            print(f"   - M√¥ t·∫£: {description}")
            
            # T·∫°o VietQR code trong b·ªô nh·ªõ
            qr_image_buffer = vietqr_service.create_qr_in_memory(
                bank_id=bank_id,
                account_no=account_no,
                amount=amount_int,
                description=description,
                account_name=account_name
            )
            
            if not qr_image_buffer:
                print("‚ùå Kh√¥ng th·ªÉ t·∫°o VietQR code")
                return False
            
            # Upload ·∫£nh l√™n Lark Approval
            filename = f"{instance_code}_{qr_type}_qr.png"
            upload_result = await lark_service.upload_image_to_approval(qr_image_buffer, filename, access_token)
            
            if not upload_result['success']:
                print(f"‚ùå Upload th·∫•t b·∫°i: {upload_result['error']}")
                return False
            
            # ƒê√°nh d·∫•u ƒë√£ t·∫°o QR SAU KHI upload th√†nh c√¥ng
            cache_service.mark_qr_as_generated(instance_code, matching_node_id, qr_type)
            
            # Enhanced comment v·ªõi type v√† status info
            comment_result = await lark_service.create_enhanced_comment_with_image(
                instance_code=instance_code,
                file_url=upload_result['file_url'],
                file_code=upload_result['file_code'],
                filename=filename,
                qr_type=qr_type,
                amount=amount_int,
                node_name=node_config['name'],
                access_token=access_token
            )
            
            if comment_result['success']:
                print(f"‚úÖ Ho√†n th√†nh x·ª≠ l√Ω approval {instance_code}")
                print(f"üí∞ Lo·∫°i: {qr_type.upper()} | S·ªë ti·ªÅn: {amount_int:,} VND")
                print(f"üè∑Ô∏è Node: {node_config['name']} | Status: {matched_status}")
                print(f"üìã Field: {field_used} | Strategy: {node_strategy}")
                print(f"üí¨ Comment ID: {comment_result['comment_id']}")
                return True
            else:
                print(f"‚ùå T·∫°o comment th·∫•t b·∫°i: {comment_result['error']}")
                return False
                
        except Exception as e:
            print(f"‚ùå L·ªói x·ª≠ l√Ω approval: {e}")
            import traceback
            traceback.print_exc()
            return False

# Global processor instance
qr_processor = QRProcessor()

============================================================

============================================================
FILE: app\services\validation_service.py
============================================================
"""
Validation Service - D√†nh cho c√°c validation rules m·ªü r·ªông trong t∆∞∆°ng lai
V√≠ d·ª•: ki·ªÉm tra t·ªïng t·∫°m ·ª©ng + thanh to√°n = th√†nh ti·ªÅn
"""
from typing import Dict, List, Any, Optional
from app.models.approval import ValidationResult

class ValidationService:
    def __init__(self):
        self.validation_rules = {
            "amount_sum_validation": self.validate_amount_sum,
            "workflow_status_validation": self.validate_workflow_status,
            "field_consistency_validation": self.validate_field_consistency
        }
    
    def validate_amount_sum(self, form_data: List[Dict], **kwargs) -> ValidationResult:
        """
        Ki·ªÉm tra t·ªïng t·∫°m ·ª©ng + thanh to√°n c√≥ b·∫±ng th√†nh ti·ªÅn kh√¥ng
        
        Args:
            form_data: Form data t·ª´ approval
            **kwargs: Additional parameters
            
        Returns:
            ValidationResult: K·∫øt qu·∫£ validation
        """
        try:
            from app.utils.field_extractor import FieldExtractor
            extractor = FieldExtractor()
            
            # Extract c√°c fields c·∫ßn thi·∫øt
            advance_amount = extractor.extract_field_value(form_data, "S·ªë ti·ªÅn t·∫°m ·ª©ng")
            payment_amount = extractor.extract_field_value(form_data, "S·ªë ti·ªÅn thanh to√°n")
            total_amount = extractor.extract_field_value(form_data, "Th√†nh ti·ªÅn")
            
            # Convert sang float
            advance = float(advance_amount) if advance_amount else 0
            payment = float(payment_amount) if payment_amount else 0
            total = float(total_amount) if total_amount else 0
            
            calculated_sum = advance + payment
            
            if abs(calculated_sum - total) < 0.01:  # Allow small floating point differences
                return ValidationResult(
                    is_valid=True,
                    validation_type="amount_sum_validation",
                    message=f"‚úÖ T·ªïng s·ªë ti·ªÅn h·ª£p l·ªá: {advance:,} + {payment:,} = {total:,}",
                    details={
                        "advance_amount": advance,
                        "payment_amount": payment,
                        "total_amount": total,
                        "calculated_sum": calculated_sum
                    }
                )
            else:
                return ValidationResult(
                    is_valid=False,
                    validation_type="amount_sum_validation",
                    message=f"‚ùå T·ªïng s·ªë ti·ªÅn kh√¥ng kh·ªõp: {advance:,} + {payment:,} = {calculated_sum:,} ‚â† {total:,}",
                    details={
                        "advance_amount": advance,
                        "payment_amount": payment,
                        "total_amount": total,
                        "calculated_sum": calculated_sum,
                        "difference": abs(calculated_sum - total)
                    }
                )
                
        except Exception as e:
            return ValidationResult(
                is_valid=False,
                validation_type="amount_sum_validation",
                message=f"‚ùå L·ªói validation: {str(e)}",
                details={"error": str(e)}
            )
    
    def validate_workflow_status(self, task_list: List[Dict], node_id: str, **kwargs) -> ValidationResult:
        """
        Ki·ªÉm tra workflow status - c·∫£nh b√°o n·∫øu node ƒë√£ duy·ªát m√† b·ªã thu h·ªìi
        
        Args:
            task_list: Task list t·ª´ approval
            node_id: Node ID c·∫ßn ki·ªÉm tra
            **kwargs: Additional parameters
            
        Returns:
            ValidationResult: K·∫øt qu·∫£ validation
        """
        try:
            # T√¨m node trong task list
            target_node = None
            for task in task_list:
                if task.get('node_id') == node_id:
                    target_node = task
                    break
            
            if not target_node:
                return ValidationResult(
                    is_valid=True,  # Kh√¥ng t√¨m th·∫•y node kh√¥ng ph·∫£i l·ªói
                    validation_type="workflow_status_validation",
                    message=f"Node {node_id[:8]}... kh√¥ng t√¨m th·∫•y trong task list",
                    details={"node_id": node_id, "found": False}
                )
            
            current_status = target_node.get('status', 'UNKNOWN')
            
            # Logic ki·ªÉm tra thu h·ªìi
            if current_status in ['REJECTED', 'CANCELED', 'WITHDRAWN']:
                # Ki·ªÉm tra xem tr∆∞·ªõc ƒë√≥ c√≥ ƒë∆∞·ª£c approve kh√¥ng
                # (Logic n√†y c√≥ th·ªÉ ph·ª©c t·∫°p h∆°n t√πy theo business rule)
                return ValidationResult(
                    is_valid=False,
                    validation_type="workflow_status_validation",
                    message=f"‚ö†Ô∏è C·∫¢NH B√ÅO: Node {node_id[:8]}... c√≥ status {current_status} - c√≥ th·ªÉ ƒë√£ b·ªã thu h·ªìi",
                    details={
                        "node_id": node_id,
                        "current_status": current_status,
                        "alert_type": "potential_withdrawal"
                    }
                )
            
            return ValidationResult(
                is_valid=True,
                validation_type="workflow_status_validation",
                message=f"‚úÖ Node {node_id[:8]}... c√≥ status b√¨nh th∆∞·ªùng: {current_status}",
                details={
                    "node_id": node_id,
                    "current_status": current_status
                }
            )
            
        except Exception as e:
            return ValidationResult(
                is_valid=False,
                validation_type="workflow_status_validation",
                message=f"‚ùå L·ªói ki·ªÉm tra workflow status: {str(e)}",
                details={"error": str(e)}
            )
    
    def validate_field_consistency(self, form_data: List[Dict], **kwargs) -> ValidationResult:
        """
        Ki·ªÉm tra t√≠nh nh·∫•t qu√°n c·ªßa c√°c fields
        V√≠ d·ª•: Ng√†y b·∫Øt ƒë·∫ßu ph·∫£i tr∆∞·ªõc ng√†y k·∫øt th√∫c
        """
        try:
            # Placeholder cho logic validation kh√°c
            return ValidationResult(
                is_valid=True,
                validation_type="field_consistency_validation",
                message="‚úÖ Field consistency check passed",
                details={"checked": True}
            )
            
        except Exception as e:
            return ValidationResult(
                is_valid=False,
                validation_type="field_consistency_validation",
                message=f"‚ùå L·ªói ki·ªÉm tra field consistency: {str(e)}",
                details={"error": str(e)}
            )
    
    def run_validation(self, validation_type: str, **kwargs) -> ValidationResult:
        """
        Ch·∫°y m·ªôt validation rule c·ª• th·ªÉ
        
        Args:
            validation_type: Lo·∫°i validation c·∫ßn ch·∫°y
            **kwargs: Parameters cho validation
            
        Returns:
            ValidationResult: K·∫øt qu·∫£ validation
        """
        if validation_type in self.validation_rules:
            return self.validation_rules[validation_type](**kwargs)
        else:
            return ValidationResult(
                is_valid=False,
                validation_type=validation_type,
                message=f"‚ùå Unknown validation type: {validation_type}",
                details={"available_types": list(self.validation_rules.keys())}
            )
    
    def run_all_validations(self, form_data: List[Dict], task_list: List[Dict], 
                           node_id: str) -> List[ValidationResult]:
        """
        Ch·∫°y t·∫•t c·∫£ validations
        
        Args:
            form_data: Form data t·ª´ approval
            task_list: Task list t·ª´ approval
            node_id: Node ID ƒëang x·ª≠ l√Ω
            
        Returns:
            List[ValidationResult]: Danh s√°ch k·∫øt qu·∫£ validation
        """
        results = []
        
        # Amount sum validation
        results.append(self.run_validation(
            "amount_sum_validation", 
            form_data=form_data
        ))
        
        # Workflow status validation
        results.append(self.run_validation(
            "workflow_status_validation", 
            task_list=task_list, 
            node_id=node_id
        ))
        
        # Field consistency validation
        results.append(self.run_validation(
            "field_consistency_validation", 
            form_data=form_data
        ))
        
        return results

# Global service instance
validation_service = ValidationService()

============================================================

============================================================
FILE: app\services\vietqr_service.py
============================================================
import requests
from urllib.parse import quote
from PIL import Image
from io import BytesIO
from app.config.settings import settings

class VietQRService:
    def __init__(self):
        self.base_url = settings.VIETQR_BASE_URL
    
    def create_qr_in_memory(self, bank_id: str, account_no: str, amount: int, 
                           description: str, account_name: str, 
                           template: str = None) -> BytesIO:
        """
        T·∫°o QR code v·ªõi s·ªë ti·ªÅn v√† n·ªôi dung, tr·∫£ v·ªÅ BytesIO object
        
        Args:
            bank_id (str): M√£ ng√¢n h√†ng
            account_no (str): S·ªë t√†i kho·∫£n   
            amount (int): S·ªë ti·ªÅn (VND)
            description (str): N·ªôi dung chuy·ªÉn kho·∫£n
            account_name (str): T√™n t√†i kho·∫£n
            template (str): Template (m·∫∑c ƒë·ªãnh t·ª´ settings)
        
        Returns:
            BytesIO: QR code image data ho·∫∑c None n·∫øu l·ªói
        """
        if template is None:
            template = settings.VIETQR_TEMPLATE
            
        encoded_desc = quote(description)
        encoded_name = quote(account_name)
        
        url = (f"{self.base_url}/{bank_id}-{account_no}-{template}.jpg?"
               f"amount={amount}&addInfo={encoded_desc}&accountName={encoded_name}")
        
        print(f"VietQR URL: {url}")
        
        try:
            response = requests.get(url, timeout=10)
            response.raise_for_status()
            
            # M·ªü ·∫£nh t·ª´ response
            image = Image.open(BytesIO(response.content))
            
            # Chuy·ªÉn ƒë·ªïi sang RGB n·∫øu c·∫ßn
            if image.mode in ('RGBA', 'LA', 'P'):
                image = image.convert('RGB')
            
            # L∆∞u v√†o BytesIO
            img_buffer = BytesIO()
            image.save(img_buffer, format='PNG')
            img_buffer.seek(0)
            
            print(f"‚úÖ T·∫°o VietQR code th√†nh c√¥ng trong b·ªô nh·ªõ")
            return img_buffer
            
        except requests.exceptions.RequestException as e:
            print(f"‚ùå L·ªói khi t·∫£i VietQR code: {e}")
            return None
        except Exception as e:
            print(f"‚ùå L·ªói x·ª≠ l√Ω VietQR: {e}")
            return None

    def generate_qr_description(self, qr_type: str, instance_code: str) -> str:
        """
        T·∫°o description cho QR code d·ª±a tr√™n type
        
        Args:
            qr_type (str): 'advance' ho·∫∑c 'payment'
            instance_code (str): Instance code
            
        Returns:
            str: QR description
        """
        if qr_type == 'advance':
            return f"Tam ung don {instance_code}"
        elif qr_type == 'payment':
            return f"Thanh toan don {instance_code}"
        else:
            return f"Don {instance_code}"  # Fallback

# Global service instance
vietqr_service = VietQRService()

============================================================

============================================================
FILE: app\utils\amount_detector.py
============================================================
from typing import Dict, List, Optional
from app.config.node_config import get_node_config
from app.utils.field_extractor import FieldExtractor

class AmountDetector:
    def __init__(self):
        self.field_extractor = FieldExtractor()
    
    def detect_available_amount_fields(self, form_data: List[Dict], node_config: Dict = None) -> Dict:
        """
        Scan form data ƒë·ªÉ t√¨m amount fields theo config c·ªßa node
        
        Args:
            form_data (list): Form data t·ª´ API response
            node_config (dict): Node configuration (optional)
            
        Returns:
            dict: Detection results v·ªõi c√°c fields v√† values
        """
        try:
            # S·ª≠ d·ª•ng config t·ª´ node thay v√¨ hardcode
            if node_config:
                advance_field = node_config.get('advance_field')
                payment_field = node_config.get('payment_field')
            else:
                # Fallback cho backward compatibility
                advance_field = "S·ªë ti·ªÅn t·∫°m ·ª©ng"
                payment_field = "S·ªë ti·ªÅn thanh to√°n"
            
            # Extract c·∫£ 2 fields (ch·ªâ khi field name kh√¥ng ph·∫£i None)
            advance_value = self.field_extractor.extract_field_value(form_data, advance_field) if advance_field else None
            payment_value = self.field_extractor.extract_field_value(form_data, payment_field) if payment_field else None
            
            # Debug: t√¨m t·∫•t c·∫£ fields c√≥ ch·ª©a "ti·ªÅn" ho·∫∑c "amount" 
            all_amount_fields = self.field_extractor.get_amount_fields(form_data)
            
            result = {
                'advance_amount': advance_value,
                'payment_amount': payment_value,
                'advance_field_found': advance_value is not None,
                'payment_field_found': payment_value is not None,
                'all_amount_fields': all_amount_fields,
                'fields_used': {
                    'advance_field': advance_field,
                    'payment_field': payment_field
                }
            }
            
            print(f"üí∞ Field detection results:")
            if advance_field:
                print(f"   - {advance_field}: {'‚úÖ ' + str(advance_value) if advance_value else '‚ùå Not found'}")
            else:
                print(f"   - Advance field: ‚ùå Not configured")
                
            if payment_field:
                print(f"   - {payment_field}: {'‚úÖ ' + str(payment_value) if payment_value else '‚ùå Not found'}")
            else:
                print(f"   - Payment field: ‚ùå Not configured")
                
            print(f"   - All amount fields: {list(all_amount_fields.keys())}")
            
            return result
            
        except Exception as e:
            print(f"‚ùå Error detecting amount fields: {e}")
            return {
                'advance_amount': None,
                'payment_amount': None,
                'advance_field_found': False,
                'payment_field_found': False,
                'all_amount_fields': {},
                'fields_used': {'advance_field': None, 'payment_field': None},
                'error': str(e)
            }
    
    def determine_qr_type_by_fields(self, field_detection_result: Dict) -> Dict:
        """
        Quy·∫øt ƒë·ªãnh QR type d·ª±a tr√™n fields c√≥ gi√° tr·ªã
        
        Args:
            field_detection_result (dict): K·∫øt qu·∫£ t·ª´ detect_available_amount_fields()
            
        Returns:
            dict: QR type decision result
        """
        try:
            advance_found = field_detection_result.get('advance_field_found', False)
            payment_found = field_detection_result.get('payment_field_found', False)
            advance_amount = field_detection_result.get('advance_amount')
            payment_amount = field_detection_result.get('payment_amount')

            fields_used = field_detection_result.get('fields_used', {})
            advance_field_name = fields_used.get('advance_field', 'S·ªë ti·ªÅn t·∫°m ·ª©ng')
            payment_field_name = fields_used.get('payment_field', 'S·ªë ti·ªÅn thanh to√°n')

            print(f"üéØ Determining QR type: advance={advance_found}, payment={payment_found}")
            
            # Logic priority: advance tr∆∞·ªõc, sau ƒë√≥ payment
            if advance_found and advance_amount:
                try:
                    amount_value = float(advance_amount)
                    if amount_value > 0:
                        return {
                            'qr_type': 'advance',
                            'amount': amount_value,
                            'field_used': advance_field_name,
                            'reason': 'Found valid advance amount'
                        }
                except (ValueError, TypeError):
                    print(f"‚ö†Ô∏è Invalid advance amount: {advance_amount}")
            
            if payment_found and payment_amount:
                try:
                    amount_value = float(payment_amount)
                    if amount_value > 0:
                        return {
                            'qr_type': 'payment', 
                            'amount': amount_value,
                            'field_used': payment_field_name,
                            'reason': 'Found valid payment amount'
                        }
                except (ValueError, TypeError):
                    print(f"‚ö†Ô∏è Invalid payment amount: {payment_amount}")
            
            # Kh√¥ng t√¨m th·∫•y field h·ª£p l·ªá
            return {
                'qr_type': 'none',
                'amount': None,
                'field_used': None,
                'reason': f'No valid amount found (advance_found={advance_found}, payment_found={payment_found})'
            }
            
        except Exception as e:
            print(f"‚ùå Error determining QR type: {e}")
            return {
                'qr_type': 'none',
                'amount': None,
                'field_used': None,
                'reason': f'Error: {str(e)}'
            }
    
    def get_amount_and_type_for_node(self, node_id: str, form_data: List[Dict]) -> Dict:
        """
        L·∫•y amount v√† QR type cho m·ªôt node c·ª• th·ªÉ d·ª±a tr√™n strategy c·ªßa node ƒë√≥
        
        Args:
            node_id (str): Node ID
            form_data (list): Form data t·ª´ API
            
        Returns:
            dict: Processing result v·ªõi success, qr_type, amount, etc.
        """
        try:
            node_config = get_node_config(node_id)
            if not node_config:
                return {
                    'success': False,
                    'qr_type': 'none',
                    'error': f'Node {node_id} not found in configuration'
                }
            
            strategy = node_config['strategy']
            node_name = node_config['name']
            
            print(f"üîç Processing node: {node_name} (strategy: {strategy})")
            
            # Detect available fields
            field_detection = self.detect_available_amount_fields(form_data, node_config)
            
            if strategy == "detect_both_fields":
                # Dual detection: c√≥ th·ªÉ l√† advance ho·∫∑c payment
                qr_decision = self.determine_qr_type_by_fields(field_detection)
                
                return {
                    'success': qr_decision['qr_type'] != 'none',
                    'qr_type': qr_decision['qr_type'],
                    'amount': qr_decision['amount'],
                    'field_used': qr_decision['field_used'],
                    'node_strategy': strategy,
                    'reason': f"Dual detection result: {qr_decision['reason']}",
                    'field_detection': field_detection
                }
                
            elif strategy == "payment_field_only":
                # Payment only: ch·ªâ check payment field
                payment_amount = field_detection.get('payment_amount')
                payment_found = field_detection.get('payment_field_found', False)
                payment_field_name = node_config.get('payment_field')

                if payment_found and payment_amount:
                    try:
                        amount_value = float(payment_amount)
                        if amount_value > 0:
                            return {
                                'success': True,
                                'qr_type': 'payment',
                                'amount': amount_value,
                                'field_used': payment_field_name,
                                'node_strategy': strategy,
                                'reason': 'Payment-only strategy: found valid payment amount',
                                'field_detection': field_detection
                            }
                    except (ValueError, TypeError):
                        pass
                
                return {
                    'success': False,
                    'qr_type': 'none',
                    'amount': None,
                    'field_used': None,
                    'node_strategy': strategy,
                    'reason': f'Payment-only strategy: no valid payment amount (found={payment_found}, value={payment_amount})',
                    'field_detection': field_detection
                }
            
            else:
                return {
                    'success': False,
                    'qr_type': 'none',
                    'error': f'Unknown strategy: {strategy}'
                }
                
        except Exception as e:
            print(f"‚ùå Error processing node {node_id}: {e}")
            return {
                'success': False,
                'qr_type': 'none',
                'error': str(e)
            }

============================================================

============================================================
FILE: README.md
============================================================
# Lark Approval QR Generator

Enhanced QR Generator cho Lark Approval workflows v·ªõi ki·∫øn tr√∫c modular, h·ªó tr·ª£ validation v√† alerting system.

## üöÄ Features

- ‚ú® **Modular Architecture**: D·ªÖ m·ªü r·ªông v√† maintain
- üîÑ **Multiple Node Strategies**: H·ªó tr·ª£ dual detection v√† payment-only
- üö´ **Duplicate Prevention**: Cache system ngƒÉn t·∫°o QR tr√πng l·∫∑p  
- üìä **Validation Service**: Ki·ªÉm tra t·ªïng ti·ªÅn, workflow status
- ‚ö†Ô∏è **Alert System**: C·∫£nh b√°o khi c√≥ vi ph·∫°m workflow
- üè¶ **VietQR Integration**: T·ª± ƒë·ªông t·∫°o m√£ QR thanh to√°n
- üì± **Smart Field Detection**: T·ª± ƒë·ªông detect fields theo node config
- ‚òÅÔ∏è **Cloud Ready**: S·∫µn s√†ng deploy l√™n Cloud Run

## üìÅ Project Structure


============================================================

============================================================
FILE: requirements.txt
============================================================
fastapi==0.104.1
uvicorn[standard]==0.24.0
requests==2.31.0
pandas==2.1.3
Pillow==10.1.0
python-multipart==0.0.6
pydantic==2.5.0

============================================================


üìä TH·ªêNG K√ä
------------------------------
T·ªïng s·ªë file: 23
File code: 20
C√°c lo·∫°i file code:
  .md: 1 file
  .py: 17 file
  .txt: 2 file
