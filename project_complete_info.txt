================================================================================
TH√îNG TIN D·ª∞ √ÅN HO√ÄN CH·ªàNH
================================================================================
Th·ªùi gian t·∫°o: 2025-10-03 14:17:39
Th∆∞ m·ª•c g·ªëc: d:\Atino\extension\webhook-server-approval
================================================================================

üìÅ C·∫§U TR√öC THU M·ª§C
--------------------------------------------------
‚îú‚îÄ‚îÄ üìÅ app/
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ api/
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ core/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÅ bootstrap/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ application.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÅ config/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ field_constants.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ node_config.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ settings.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÅ events/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ event_registry.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÅ infrastructure/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ cache_service.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ event_bus.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ lark_service.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÅ models/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ event.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ response.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ shared.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÅ routers/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ monitoring.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ webhook.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÅ utils/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ amount_detector.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ field_extractor.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ helpers.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ __init__.py
‚îÇ   ‚îî‚îÄ‚îÄ üìÅ domains/
‚îÇ       ‚îú‚îÄ‚îÄ üìÅ notification/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ üìÅ models/
‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ __init__.py
‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ notification.py
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ üìÅ services/
‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ __init__.py
‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ lark_webhook_service.py
‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ notification_coordinator.py
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ __init__.py
‚îÇ       ‚îú‚îÄ‚îÄ üìÅ qr_generation/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ üìÅ handlers/
‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ __init__.py
‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ qr_event_handler.py
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ üìÅ models/
‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ __init__.py
‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ qr.py
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ üìÅ routers/
‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ qr.py
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ üìÅ services/
‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ __init__.py
‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ amount_detector.py
‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ qr_processor.py
‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ vietqr_service.py
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ __init__.py
‚îÇ       ‚îú‚îÄ‚îÄ üìÅ validation/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ üìÅ handlers/
‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ __init__.py
‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ validation_event_handler.py
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ üìÅ models/
‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ __init__.py
‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ validation.py
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ üìÅ routers/
‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ notification.py
‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ validation.py
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ üìÅ services/
‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ __init__.py
‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ validation_service.py
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ __init__.py
‚îÇ       ‚îî‚îÄ‚îÄ üìÑ __init__.py
‚îú‚îÄ‚îÄ üìÑ .gitignore
‚îú‚îÄ‚îÄ üìÑ Dockerfile
‚îú‚îÄ‚îÄ üìÑ Get detail code.ipynb
‚îú‚îÄ‚îÄ üìÑ lark_events.csv
‚îú‚îÄ‚îÄ üìÑ project_complete_info.txt
‚îú‚îÄ‚îÄ üìÑ README.md
‚îî‚îÄ‚îÄ üìÑ requirements.txt


üìÑ DANH S√ÅCH T·∫§T C·∫¢ FILE
--------------------------------------------------
.gitignore (594 bytes)
app\core\__init__.py (376 bytes)
app\core\bootstrap\application.py (8435 bytes)
app\core\config\__init__.py (271 bytes)
app\core\config\field_constants.py (1232 bytes)
app\core\config\node_config.py (5382 bytes)
app\core\config\settings.py (3520 bytes)
app\core\events\event_registry.py (2702 bytes)
app\core\infrastructure\__init__.py (176 bytes)
app\core\infrastructure\cache_service.py (11934 bytes)
app\core\infrastructure\event_bus.py (5703 bytes)
app\core\infrastructure\lark_service.py (11949 bytes)
app\core\models\event.py (899 bytes)
app\core\models\response.py (1015 bytes)
app\core\models\shared.py (553 bytes)
app\core\routers\monitoring.py (1619 bytes)
app\core\routers\webhook.py (2919 bytes)
app\core\utils\__init__.py (332 bytes)
app\core\utils\amount_detector.py (10162 bytes)
app\core\utils\field_extractor.py (12805 bytes)
app\core\utils\helpers.py (2198 bytes)
app\domains\__init__.py (593 bytes)
app\domains\notification\__init__.py (262 bytes)
app\domains\notification\models\__init__.py (425 bytes)
app\domains\notification\models\notification.py (1578 bytes)
app\domains\notification\services\__init__.py (235 bytes)
app\domains\notification\services\lark_webhook_service.py (12787 bytes)
app\domains\notification\services\notification_coordinator.py (8726 bytes)
app\domains\qr_generation\__init__.py (251 bytes)
app\domains\qr_generation\handlers\__init__.py (82 bytes)
app\domains\qr_generation\handlers\qr_event_handler.py (6616 bytes)
app\domains\qr_generation\models\__init__.py (359 bytes)
app\domains\qr_generation\models\qr.py (1571 bytes)
app\domains\qr_generation\routers\qr.py (1789 bytes)
app\domains\qr_generation\services\__init__.py (214 bytes)
app\domains\qr_generation\services\amount_detector.py (15034 bytes)
app\domains\qr_generation\services\qr_processor.py (17581 bytes)
app\domains\qr_generation\services\vietqr_service.py (6971 bytes)
app\domains\validation\__init__.py (301 bytes)
app\domains\validation\handlers\__init__.py (106 bytes)
app\domains\validation\handlers\validation_event_handler.py (10972 bytes)
app\domains\validation\models\__init__.py (289 bytes)
app\domains\validation\models\validation.py (2871 bytes)
app\domains\validation\routers\notification.py (1283 bytes)
app\domains\validation\routers\validation.py (1756 bytes)
app\domains\validation\services\__init__.py (135 bytes)
app\domains\validation\services\validation_service.py (15465 bytes)
Dockerfile (1896 bytes)
Get detail code.ipynb (10463 bytes)
lark_events.csv (111947 bytes)
project_complete_info.txt (0 bytes)
README.md (7974 bytes)
requirements.txt (136 bytes)

T·ªïng c·ªông: 53 file

üíª N·ªòI DUNG T·∫§T C·∫¢ FILE CODE
================================================================================

============================================================
FILE: app\core\__init__.py
============================================================
"""
Core infrastructure exports
"""
from app.core.config import *
from app.core.infrastructure import *
from app.core.utils import *

__all__ = [
    # Configuration
    "settings", "NODE_CONFIG",
    
    # Infrastructure  
    "event_bus", "cache_service", "lark_service",
    
    # Utils
    "extract_instance_code", "get_event_type", "format_currency"
]

============================================================

============================================================
FILE: app\core\bootstrap\application.py
============================================================
import asyncio
from datetime import datetime
from app.core.events.event_registry import event_registry
from app.core.config.settings import settings


class ApplicationBootstrap:
    """
    Bootstrap to√†n b·ªô ·ª©ng d·ª•ng theo ki·∫øn tr√∫c DDD (Domain-Driven Design).
    
    L·ªõp n√†y ch·ªãu tr√°ch nhi·ªám kh·ªüi t·∫°o v√† c·∫•u h√¨nh t·∫•t c·∫£ c√°c th√†nh ph·∫ßn c·∫ßn thi·∫øt
    c·ªßa ·ª©ng d·ª•ng bao g·ªìm event handlers, infrastructure services v√† ki·ªÉm tra
    s·ª©c kh·ªèe h·ªá th·ªëng.
    
    Attributes:
        startup_time (datetime): Th·ªùi ƒëi·ªÉm b·∫Øt ƒë·∫ßu kh·ªüi t·∫°o ·ª©ng d·ª•ng
        is_initialized (bool): Tr·∫°ng th√°i kh·ªüi t·∫°o c·ªßa ·ª©ng d·ª•ng
    """
    
    def __init__(self):
        """Kh·ªüi t·∫°o ApplicationBootstrap v·ªõi tr·∫°ng th√°i ban ƒë·∫ßu."""
        self.startup_time = None
        self.is_initialized = False
        
    async def initialize(self):
        """
        Kh·ªüi t·∫°o to√†n b·ªô ·ª©ng d·ª•ng theo th·ª© t·ª± ∆∞u ti√™n.
        
        Qu√° tr√¨nh kh·ªüi t·∫°o bao g·ªìm:
        1. ƒêƒÉng k√Ω event handlers
        2. Kh·ªüi t·∫°o infrastructure services  
        3. Ki·ªÉm tra s·ª©c kh·ªèe h·ªá th·ªëng
        
        Raises:
            Exception: Khi c√≥ l·ªói trong qu√° tr√¨nh kh·ªüi t·∫°o
        """
        print("üöÄ B·∫Øt ƒë·∫ßu kh·ªüi t·∫°o ·ª©ng d·ª•ng...")
        self.startup_time = datetime.now()
        
        try:
            # 1. ƒêƒÉng k√Ω c√°c event handlers
            await self._register_event_handlers()
            
            # 2. Kh·ªüi t·∫°o c√°c infrastructure services
            await self._initialize_infrastructure()
            
            # 3. Ki·ªÉm tra s·ª©c kh·ªèe h·ªá th·ªëng
            await self._validate_system_health()
            
            # ƒê√°nh d·∫•u ·ª©ng d·ª•ng ƒë√£ kh·ªüi t·∫°o th√†nh c√¥ng
            self.is_initialized = True
            elapsed = (datetime.now() - self.startup_time).total_seconds()
            
            print(f"‚úÖ Kh·ªüi t·∫°o ·ª©ng d·ª•ng ho√†n t·∫•t trong {elapsed:.2f}s")
            
        except Exception as e:
            print(f"‚ùå Kh·ªüi t·∫°o ·ª©ng d·ª•ng th·∫•t b·∫°i: {e}")
            raise
    
    async def _register_event_handlers(self):
        """
        ƒêƒÉng k√Ω t·∫•t c·∫£ event handlers t·ª´ domain layer.
        
        Method n√†y s·ª≠ d·ª•ng event_registry ƒë·ªÉ t·ª± ƒë·ªông ƒëƒÉng k√Ω t·∫•t c·∫£
        handlers ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a trong c√°c domain modules.
        
        Raises:
            Exception: Khi kh√¥ng th·ªÉ ƒëƒÉng k√Ω event handlers
        """
        print("üìù ƒêang ƒëƒÉng k√Ω event handlers...")
        
        try:
            # G·ªçi registry ƒë·ªÉ ƒëƒÉng k√Ω t·∫•t c·∫£ domain handlers
            event_registry.register_domain_handlers()
            
            # L·∫•y th√¥ng tin tr·∫°ng th√°i ƒëƒÉng k√Ω ƒë·ªÉ log
            status = event_registry.get_registration_status()
            print(f"   ‚Ä¢ ƒê√£ ƒëƒÉng k√Ω {status['total_handlers']} handlers cho {status['total_event_types']} lo·∫°i event")
            
        except Exception as e:
            print(f"‚ùå ƒêƒÉng k√Ω event handlers th·∫•t b·∫°i: {e}")
            raise
    
    async def _initialize_infrastructure(self):
        """
        Kh·ªüi t·∫°o v√† ki·ªÉm tra c√°c infrastructure services.
        
        Bao g·ªìm:
        - Lark API service (k·∫øt n·ªëi ƒë·∫øn Lark/Feishu)
        - Cache service (Redis ho·∫∑c in-memory cache)
        - Notification service (webhook alerts)
        
        Raises:
            Exception: Khi kh√¥ng th·ªÉ kh·ªüi t·∫°o infrastructure services
        """
        print("üèóÔ∏è ƒêang kh·ªüi t·∫°o infrastructure services...")
        
        try:
            # Ki·ªÉm tra k·∫øt n·ªëi Lark API
            from app.core.infrastructure.lark_service import lark_service
            
            print("   ‚Ä¢ ƒêang ki·ªÉm tra k·∫øt n·ªëi Lark API...")
            token = await lark_service.get_access_token()
            if token:
                print("   ‚úÖ K·∫øt n·ªëi Lark API th√†nh c√¥ng")
            else:
                print("   ‚ö†Ô∏è K·∫øt n·ªëi Lark API th·∫•t b·∫°i - ki·ªÉm tra l·∫°i th√¥ng tin x√°c th·ª±c")
            
            # Kh·ªüi t·∫°o cache service
            from app.core.infrastructure.cache_service import cache_service
            print("   ‚Ä¢ Cache service ƒë√£ ƒë∆∞·ª£c kh·ªüi t·∫°o")
            print(f"   ‚Ä¢ Th·ªùi gian cache QR code: {settings.QR_CACHE_DURATION_MINUTES} ph√∫t")
            
            # Ki·ªÉm tra notification service n·∫øu ƒë∆∞·ª£c b·∫≠t
            if settings.ENABLE_VALIDATION_ALERTS:
                print("   ‚Ä¢ C·∫£nh b√°o validation ƒë√£ ƒë∆∞·ª£c b·∫≠t")
                if settings.LARK_WEBHOOK_URL:
                    print("   ‚úÖ Webhook URL ƒë√£ ƒë∆∞·ª£c c·∫•u h√¨nh")
                else:
                    print("   ‚ö†Ô∏è Ch∆∞a c·∫•u h√¨nh webhook URL")
            else:
                print("   ‚Ä¢ C·∫£nh b√°o validation ƒë√£ ƒë∆∞·ª£c t·∫Øt")
            
        except Exception as e:
            print(f"‚ùå Kh·ªüi t·∫°o infrastructure th·∫•t b·∫°i: {e}")
            raise
    
    async def _validate_system_health(self):
        """
        Ki·ªÉm tra s·ª©c kh·ªèe t·ªïng th·ªÉ c·ªßa h·ªá th·ªëng.
        
        Validates:
        - Event bus ho·∫°t ƒë·ªông b√¨nh th∆∞·ªùng
        - Node configuration ƒë√£ ƒë∆∞·ª£c load
        - Environment variables c·∫ßn thi·∫øt ƒë√£ ƒë∆∞·ª£c c·∫•u h√¨nh
        
        Raises:
            Exception: Khi ph√°t hi·ªán v·∫•n ƒë·ªÅ nghi√™m tr·ªçng v·ªõi h·ªá th·ªëng
        """
        print("üîç ƒêang ki·ªÉm tra s·ª©c kh·ªèe h·ªá th·ªëng...")
        
        try:
            # Ki·ªÉm tra event bus
            from app.core.infrastructure.event_bus import event_bus
            handler_count = len(event_bus.handlers.get("approval.instance.updated", []))
            print(f"   ‚Ä¢ Event bus: {handler_count} handlers ƒë√£ ƒëƒÉng k√Ω cho approval events")
            
            # Ki·ªÉm tra node configuration
            from app.core.config.node_config import NODE_CONFIG
            print(f"   ‚Ä¢ C·∫•u h√¨nh node: {len(NODE_CONFIG)} nodes ƒë√£ ƒë∆∞·ª£c c·∫•u h√¨nh")
            
            # Ki·ªÉm tra c√°c environment variables b·∫Øt bu·ªôc
            required_vars = ["LARK_APP_ID", "LARK_APP_SECRET"]
            missing_vars = []
            
            # Duy·ªát qua t·ª´ng bi·∫øn m√¥i tr∆∞·ªùng b·∫Øt bu·ªôc
            for var in required_vars:
                if not getattr(settings, var, None):
                    missing_vars.append(var)
            
            # B√°o c√°o k·∫øt qu·∫£ ki·ªÉm tra environment variables
            if missing_vars:
                print(f"   ‚ö†Ô∏è Thi·∫øu c√°c bi·∫øn m√¥i tr∆∞·ªùng: {', '.join(missing_vars)}")
            else:
                print("   ‚úÖ T·∫•t c·∫£ bi·∫øn m√¥i tr∆∞·ªùng b·∫Øt bu·ªôc ƒë·ªÅu c√≥")
            
            print("   ‚úÖ Ki·ªÉm tra s·ª©c kh·ªèe h·ªá th·ªëng ho√†n t·∫•t")
            
        except Exception as e:
            print(f"‚ùå Ki·ªÉm tra s·ª©c kh·ªèe h·ªá th·ªëng th·∫•t b·∫°i: {e}")
            raise
    
    def get_startup_info(self) -> dict:
        """
        L·∫•y th√¥ng tin chi ti·∫øt v·ªÅ qu√° tr√¨nh kh·ªüi ƒë·ªông ·ª©ng d·ª•ng.
        
        Returns:
            dict: Dictionary ch·ª©a th√¥ng tin startup bao g·ªìm:
                - startup_time: Th·ªùi ƒëi·ªÉm b·∫Øt ƒë·∫ßu kh·ªüi t·∫°o
                - is_initialized: Tr·∫°ng th√°i kh·ªüi t·∫°o
                - uptime_seconds: Th·ªùi gian ho·∫°t ƒë·ªông (gi√¢y)
                - event_handlers: Th√¥ng tin v·ªÅ event handlers ƒë√£ ƒëƒÉng k√Ω
                - architecture: Lo·∫°i ki·∫øn tr√∫c ƒë∆∞·ª£c s·ª≠ d·ª•ng
                - version: Phi√™n b·∫£n ·ª©ng d·ª•ng
        """
        return {
            "startup_time": self.startup_time.isoformat() if self.startup_time else None,
            "is_initialized": self.is_initialized,
            "uptime_seconds": (datetime.now() - self.startup_time).total_seconds() if self.startup_time else 0,
            "event_handlers": event_registry.get_registration_status(),
            "architecture": "DDD",
            "version": "2.0.0"
        }


app_bootstrap = ApplicationBootstrap()

============================================================

============================================================
FILE: app\core\config\__init__.py
============================================================
from .settings import settings
from .node_config import NODE_CONFIG, get_node_config, get_configured_node_ids
from .field_constants import FFN

__all__ = [
    "settings", 
    "NODE_CONFIG", 
    "get_node_config", 
    "get_configured_node_ids",
    "FFN"
]

============================================================

============================================================
FILE: app\core\config\field_constants.py
============================================================
# app/core/config/field_constants.py

class FormFieldNames:
    """
    Single Source of Truth for all Lark Approval form field names.
    T·∫≠p trung t·∫•t c·∫£ t√™n tr∆∞·ªùng c·ªßa form ph√™ duy·ªát Lark t·∫°i m·ªôt n∆°i duy nh·∫•t.
    """
    
    # === Tr∆∞·ªùng Ti·ªÅn T·ªá C·∫•p Cao (Top-level Amount Fields) ===
    ADVANCE_AMOUNT = "S·ªë ti·ªÅn t·∫°m ·ª©ng"
    PAYMENT_AMOUNT = "S·ªë ti·ªÅn thanh to√°n"
    REMAINING_PAYMENT_AMOUNT = "S·ªë ti·ªÅn c√≤n ph·∫£i thanh to√°n"
    TOTAL_PAYMENT_AMOUNT = "Total s·ªë ti·ªÅn thanh to√°n"

    # === Tr∆∞·ªùng Trong FieldList K·∫ø To√°n (Accounting FieldList Fields) ===
    ACCOUNTING_ADVANCE_INFO = "K·∫ø to√°n - Th√¥ng tin t·∫°m ·ª©ng"
    ACCOUNTING_PAYMENT_INFO = "K·∫ø to√°n - Th√¥ng tin thanh to√°n"
    EXPENDITURE_AMOUNT = "S·ªë ti·ªÅn chi" # D√πng chung cho c·∫£ t·∫°m ·ª©ng v√† thanh to√°n

    # === Tr∆∞·ªùng Th√¥ng Tin Ng√¢n H√†ng (Bank Information Fields) ===
    BANK_NAME = "Ng√¢n h√†ng"
    BANK_ACCOUNT_NUMBER = "S·ªë t√†i kho·∫£n ng√¢n h√†ng"
    BENEFICIARY_NAME = "T√™n ng∆∞·ªùi th·ª• h∆∞·ªüng"

# T·∫°o m·ªôt instance ƒë·ªÉ d·ªÖ d√†ng import v√† s·ª≠ d·ª•ng
# from app.core.config.field_constants import FFN
FFN = FormFieldNames()
============================================================

============================================================
FILE: app\core\config\node_config.py
============================================================
from .field_constants import FFN

# C·∫•u h√¨nh chi ti·∫øt cho t·ª´ng node trong approval workflow
NODE_CONFIG = {
    # Node tr∆∞·ªüng ph√≤ng duy·ªát - C√≥ th·ªÉ detect c·∫£ advance v√† payment (Kh√¥ng b·∫Øt ƒë∆∞·ª£c node submit, node n√†y lu√¥n l√† node ti·∫øp theo)
    "30e5338b60587c64c7cef5f6a7211ccb": {
        "name": "truong_phong_duyet",
        "type": "dual_detection",                   # Lo·∫°i node h·ªó tr·ª£ c·∫£ advance v√† payment
        "advance_field": FFN.ADVANCE_AMOUNT,        # T√™n field ch·ª©a s·ªë ti·ªÅn t·∫°m ·ª©ng
        "payment_field": FFN.PAYMENT_AMOUNT,        # T√™n field ch·ª©a s·ªë ti·ªÅn thanh to√°n
        "strategy": "detect_both_fields",           # Strategy t·ª± ƒë·ªông detect lo·∫°i QR d·ª±a tr√™n fields
        "required_status": "PENDING",               # Status c·∫ßn thi·∫øt ƒë·ªÉ trigger QR generation
        "description": "Tr∆∞·ªüng ph√≤ng duy·ªát - Auto detect advance/payment"
    },
    
    # Node thanh to√°n
    "f23535375a26847ef71c1cbf0755f246": {
        "name": "thanh_toan_sau_tam_ung", 
        "type": "payment_only",                          # Lo·∫°i node ch·ªâ x·ª≠ l√Ω payment
        "advance_field": None,                           # Kh√¥ng c√≥ field advance
        "payment_field": FFN.REMAINING_PAYMENT_AMOUNT,   # Field ch·ª©a s·ªë ti·ªÅn c·∫ßn thanh to√°n
        "strategy": "payment_field_only",                # Strategy ch·ªâ x·ª≠ l√Ω payment field
        "required_status": "APPROVED",                   # Node n√†y c·∫ßn status APPROVED
        
        # ƒêi·ªÅu ki·ªán b·ªï sung ƒë·ªÉ trigger QR generation
        "additional_conditions": [
            {
                "node_id": "ef83b231885a1a77658f32808a199764",  # Node ti·∫øp theo
                "required_status": "PENDING",                   # Node ti·∫øp theo ph·∫£i PENDING
                "description": "Node ti·∫øp theo ph·∫£i PENDING"    # M√¥ t·∫£ ƒëi·ªÅu ki·ªán
            }
        ],
        "description": "Thanh to√°n sau t·∫°m ·ª©ng - Payment only (trigger on APPROVED + next node PENDING)"
    }
}


def get_node_config(node_id: str) -> dict:
    """
    L·∫•y configuration chi ti·∫øt cho m·ªôt node_id c·ª• th·ªÉ.
    
    Args:
        node_id (str): Node ID c·∫ßn l·∫•y configuration
        
    Returns:
        dict: Dictionary ch·ª©a c·∫•u h√¨nh node bao g·ªìm:
            - name: T√™n node
            - type: Lo·∫°i node (dual_detection, payment_only, etc.)
            - advance_field: T√™n field ch·ª©a s·ªë ti·ªÅn t·∫°m ·ª©ng
            - payment_field: T√™n field ch·ª©a s·ªë ti·ªÅn thanh to√°n
            - strategy: Chi·∫øn l∆∞·ª£c x·ª≠ l√Ω (detect_both_fields, payment_field_only, etc.)
            - required_status: Status c·∫ßn thi·∫øt ƒë·ªÉ trigger
            - additional_conditions: C√°c ƒëi·ªÅu ki·ªán b·ªï sung (optional)
            - description: M√¥ t·∫£ node
        Tr·∫£ v·ªÅ None n·∫øu kh√¥ng t√¨m th·∫•y node_id
    """
    return NODE_CONFIG.get(node_id)


def get_node_strategy(node_id: str) -> str:
    """
    L·∫•y strategy x·ª≠ l√Ω c·ªßa m·ªôt node c·ª• th·ªÉ.
    
    Args:
        node_id (str): Node ID c·∫ßn l·∫•y strategy
        
    Returns:
        str: T√™n strategy c·ªßa node nh∆∞:
            - "detect_both_fields": T·ª± ƒë·ªông detect advance/payment
            - "payment_field_only": Ch·ªâ x·ª≠ l√Ω payment
            - "unknown": N·∫øu kh√¥ng t√¨m th·∫•y node ho·∫∑c strategy
    """
    config = get_node_config(node_id)
    return config.get("strategy", "unknown") if config else "unknown"


def print_node_config_summary():
    """
    In ra t√≥m t·∫Øt chi ti·∫øt c·ªßa NODE_CONFIG bao g·ªìm additional conditions.
    
    Function n√†y hi·ªÉn th·ªã th√¥ng tin t·ªïng quan v·ªÅ t·∫•t c·∫£ nodes ƒë∆∞·ª£c c·∫•u h√¨nh,
    bao g·ªìm strategy, fields, required status v√† c√°c ƒëi·ªÅu ki·ªán b·ªï sung.
    """
    print("üìã T√≥m t·∫Øt c·∫•u h√¨nh NODE_CONFIG:")
    
    # Duy·ªát qua t·ª´ng node trong configuration
    for node_id, config in NODE_CONFIG.items():
        required_status = config.get('required_status', 'PENDING')
        additional_conditions = config.get('additional_conditions', [])
        
        # Hi·ªÉn th·ªã th√¥ng tin c∆° b·∫£n c·ªßa node
        print(f"   ‚Ä¢ {node_id[:8]}... - {config['name']} ({config['strategy']})")
        print(f"     C√°c tr∆∞·ªùng: advance='{config['advance_field']}', payment='{config['payment_field']}'")
        print(f"     Status y√™u c·∫ßu: {required_status}")
        
        # Hi·ªÉn th·ªã c√°c ƒëi·ªÅu ki·ªán b·ªï sung n·∫øu c√≥
        if additional_conditions:
            print(f"     ƒêi·ªÅu ki·ªán b·ªï sung:")
            for condition in additional_conditions:
                condition_node_short = condition['node_id'][:8]
                condition_status = condition['required_status']
                print(f"       - {condition_node_short}... ph·∫£i c√≥ status {condition_status}")


def get_configured_node_ids():
    """
    L·∫•y danh s√°ch t·∫•t c·∫£ node IDs ƒë√£ ƒë∆∞·ª£c c·∫•u h√¨nh.
    
    Returns:
        List[str]: Danh s√°ch t·∫•t c·∫£ node IDs c√≥ trong NODE_CONFIG
    """
    return list(NODE_CONFIG.keys())


# Backward compatibility - Gi·ªØ l·∫°i t√™n c≈© ƒë·ªÉ kh√¥ng break existing code
ALLOWED_NODE_IDS = get_configured_node_ids()

============================================================

============================================================
FILE: app\core\config\settings.py
============================================================
import os
from typing import Optional


class Settings:
    """
    C·∫•u h√¨nh to√†n b·ªô ·ª©ng d·ª•ng t·ª´ environment variables v√† default values.
    
    Settings class qu·∫£n l√Ω t·∫•t c·∫£ c√°c c·∫•u h√¨nh c·∫ßn thi·∫øt cho ·ª©ng d·ª•ng bao g·ªìm:
    - FastAPI server configuration
    - Lark/Feishu API credentials v√† endpoints
    - VietQR service configuration
    - Webhook v√† notification settings
    - Cache v√† performance settings
    - File storage settings
    - Validation v√† alert settings
    
    T·∫•t c·∫£ settings c√≥ th·ªÉ ƒë∆∞·ª£c override b·∫±ng environment variables.
    """
    
    # ===== FASTAPI SERVER SETTINGS =====
    # C·∫•u h√¨nh cho FastAPI web server
    DEBUG: bool = os.getenv("DEBUG", "false").lower() == "true"  # B·∫≠t/t·∫Øt debug mode
    PORT: int = int(os.getenv("PORT", "8000"))                   # Port ƒë·ªÉ ch·∫°y server
    
    # ===== LARK/FEISHU API SETTINGS =====
    # Th√¥ng tin x√°c th·ª±c v√† endpoints cho Lark API
    LARK_APP_ID: str = os.getenv("LARK_APP_ID", "cli_a758ffaf41f8502f")
    LARK_APP_SECRET: str = os.getenv("LARK_APP_SECRET", "45Jsgm3TYfEwD2F67BH1LctlYEcCjZpH")
    
    # Base URL cho t·∫•t c·∫£ Lark API calls
    BASE_URL: str = "https://open.larksuite.com/open-apis"
    
    # Endpoint chuy√™n d·ª•ng cho upload file l√™n approval system
    APPROVAL_UPLOAD_URL: str = "https://www.larksuite.com/approval/openapi/v2/file/upload"
    
    # ===== VIETQR SERVICE SETTINGS =====
    # C·∫•u h√¨nh cho VietQR API ƒë·ªÉ generate QR codes
    VIETQR_TEMPLATE: str = "compact2"                           # Template layout cho QR code
    VIETQR_BASE_URL: str = "https://img.vietqr.io/image"       # Base URL c·ªßa VietQR service
    
    # ===== WEBHOOK & NOTIFICATION SETTINGS =====
    # C·∫•u h√¨nh webhook ƒë·ªÉ g·ª≠i notifications
    LARK_WEBHOOK_URL: str = os.getenv(
        "LARK_WEBHOOK_URL", 
        "https://open.larksuite.com/open-apis/bot/v2/hook/6a53a060-40d7-4716-9a90-970a6cbdaf64"
    )
    
    # B·∫≠t/t·∫Øt validation alerts qua webhook
    ENABLE_VALIDATION_ALERTS: bool = os.getenv("ENABLE_VALIDATION_ALERTS", "true").lower() == "true"

    # ===== CACHE & PERFORMANCE SETTINGS =====
    # C·∫•u h√¨nh cache ƒë·ªÉ t·ªëi ∆∞u performance v√† tr√°nh duplicate requests
    QR_CACHE_DURATION_MINUTES: int = 5      # Th·ªùi gian cache QR generation (ph√∫t)
    TOKEN_CACHE_BUFFER_SECONDS: int = 300   # Buffer time tr∆∞·ªõc khi token h·∫øt h·∫°n (5 ph√∫t)

    # ===== FILE STORAGE SETTINGS =====
    # C·∫•u h√¨nh file storage cho logging v√† data persistence
    EVENTS_FILE: str = "lark_events.csv"    # File l∆∞u tr·ªØ event logs
    
    # ===== USER & AUTHENTICATION SETTINGS =====
    # User ID m·∫∑c ƒë·ªãnh ƒë·ªÉ t·∫°o comments trong Lark approval
    DEFAULT_USER_ID: str = "cd11b141"
    
    # ===== VALIDATION & MONITORING SETTINGS =====
    # C·∫•u h√¨nh c√°c t√≠nh nƒÉng validation v√† monitoring (cho future extensions)
    
    # B·∫≠t/t·∫Øt validation s·ªë ti·ªÅn trong approval workflow
    ENABLE_AMOUNT_VALIDATION: bool = os.getenv("ENABLE_AMOUNT_VALIDATION", "true").lower() == "true"
    
    # B·∫≠t/t·∫Øt alerts cho workflow errors v√† anomalies
    ENABLE_WORKFLOW_ALERTS: bool = os.getenv("ENABLE_WORKFLOW_ALERTS", "true").lower() == "true"


# Global settings instance - s·ª≠ d·ª•ng trong to√†n b·ªô ·ª©ng d·ª•ng
# Import settings t·ª´ module n√†y ƒë·ªÉ truy c·∫≠p t·∫•t c·∫£ configuration
settings = Settings()

============================================================

============================================================
FILE: app\core\events\event_registry.py
============================================================
"""
Event Registry - Central registration for all domain event handlers
"""
from typing import Dict, List, Callable
from app.core.infrastructure.event_bus import event_bus

class EventRegistry:
    """Central registry for domain event handlers"""
    
    def __init__(self):
        self.registered_handlers: Dict[str, List[str]] = {}
    
    def register_handler(self, event_type: str, handler: Callable, domain: str = "core"):
        """Register a handler for an event type"""
        try:
            event_bus.subscribe(event_type, handler)
            
            # Track registration for monitoring
            if event_type not in self.registered_handlers:
                self.registered_handlers[event_type] = []
            
            handler_info = f"{domain}.{handler.__name__}"
            self.registered_handlers[event_type].append(handler_info)
            
            print(f"‚úÖ Registered {handler_info} for event: {event_type}")
            
        except Exception as e:
            print(f"‚ùå Failed to register handler {handler.__name__}: {e}")
    
    def register_domain_handlers(self):
        """Register all domain handlers"""
        print("üîß Registering domain event handlers...")
        
        try:
            # QR Generation Domain Handlers
            from app.domains.qr_generation.handlers import qr_event_handler
            self.register_handler(
                "approval.instance.updated", 
                qr_event_handler.handle_approval_event,
                "qr_generation"
            )
            
            # Validation Domain Handlers  
            from app.domains.validation.handlers import validation_event_handler
            self.register_handler(
                "approval.instance.updated",
                validation_event_handler.handle_approval_event, 
                "validation"
            )
            
            print(f"‚úÖ Successfully registered handlers for {len(self.registered_handlers)} event types")
            
        except Exception as e:
            print(f"‚ùå Error registering domain handlers: {e}")
            raise
    
    def get_registration_status(self) -> Dict:
        """Get current registration status"""
        total_handlers = sum(len(handlers) for handlers in self.registered_handlers.values())
        
        return {
            "total_event_types": len(self.registered_handlers),
            "total_handlers": total_handlers,
            "registrations": self.registered_handlers,
            "event_bus_handlers": len(event_bus.handlers)
        }

# Global registry instance
event_registry = EventRegistry()

============================================================

============================================================
FILE: app\core\infrastructure\__init__.py
============================================================
from .event_bus import event_bus
from .cache_service import cache_service
from .lark_service import lark_service

__all__ = ["event_bus", "cache_service", "lark_service"]

============================================================

============================================================
FILE: app\core\infrastructure\cache_service.py
============================================================
from datetime import datetime, timedelta
from typing import Dict, Optional


class CacheService:
    """
    Service qu·∫£n l√Ω cache cho QR code generation v√† validation alerts.
    
    CacheService gi√∫p tr√°nh tr√πng l·∫∑p b·∫±ng c√°ch cache th·ªùi ƒëi·ªÉm t·∫°o QR codes
    v√† g·ª≠i validation alerts. Service n√†y s·ª≠ d·ª•ng in-memory cache v·ªõi
    automatic expiration ƒë·ªÉ ti·∫øt ki·ªám b·ªô nh·ªõ.
    
    Attributes:
        qr_generation_cache (Dict[str, datetime]): Cache th·ªùi ƒëi·ªÉm t·∫°o QR codes
        validation_alert_cache (Dict[str, datetime]): Cache th·ªùi ƒëi·ªÉm g·ª≠i validation alerts
    """
    
    def __init__(self):
        """Kh·ªüi t·∫°o CacheService v·ªõi c√°c cache dictionary r·ªóng."""
        self.qr_generation_cache: Dict[str, datetime] = {}
        self.validation_alert_cache: Dict[str, datetime] = {}
    
    def generate_cache_key(self, instance_code: str, node_id: str, qr_type: str) -> str:
        """
        T·∫°o cache key unique cho QR code ƒë·ªÉ detect duplicates.
        
        Args:
            instance_code (str): M√£ instance c·ªßa approval workflow
            node_id (str): ID c·ªßa node trong workflow
            qr_type (str): Lo·∫°i QR code (payment, advance, etc.)
            
        Returns:
            str: Cache key format: {instance_code}_{short_node_id}_{qr_type}
        """
        # R√∫t ng·∫Øn node_id ƒë·ªÉ cache key kh√¥ng qu√° d√†i
        short_node_id = node_id[:8] if len(node_id) > 8 else node_id
        return f"{instance_code}_{short_node_id}_{qr_type}"

    def generate_validation_cache_key(self, instance_code: str, validation_type: str) -> str:
        """
        T·∫°o cache key cho validation alerts ƒë·ªÉ tr√°nh spam alerts.
        
        Args:
            instance_code (str): M√£ instance c·ªßa approval workflow
            validation_type (str): Lo·∫°i validation (amount_mismatch, workflow_error, etc.)
            
        Returns:
            str: Cache key format: validation_{instance_code}_{validation_type}
        """
        return f"validation_{instance_code}_{validation_type}"

    def is_qr_recently_generated(self, instance_code: str, node_id: str, qr_type: str, 
                               cache_duration_minutes: int = 5) -> bool:
        """
        Ki·ªÉm tra xem QR code ƒë√£ ƒë∆∞·ª£c t·∫°o trong kho·∫£ng th·ªùi gian g·∫ßn ƒë√¢y ch∆∞a.
        
        Args:
            instance_code (str): M√£ instance c·ªßa approval workflow
            node_id (str): ID c·ªßa node trong workflow
            qr_type (str): Lo·∫°i QR code
            cache_duration_minutes (int, optional): Th·ªùi gian cache t√≠nh b·∫±ng ph√∫t. M·∫∑c ƒë·ªãnh 5 ph√∫t.
            
        Returns:
            bool: True n·∫øu QR ƒë√£ ƒë∆∞·ª£c t·∫°o g·∫ßn ƒë√¢y, False n·∫øu ch∆∞a ho·∫∑c ƒë√£ h·∫øt h·∫°n
        """
        try:
            cache_key = self.generate_cache_key(instance_code, node_id, qr_type)
            
            # Ki·ªÉm tra xem cache key c√≥ t·ªìn t·∫°i kh√¥ng
            if cache_key not in self.qr_generation_cache:
                print(f"üÜï Cache miss: {cache_key} - ch∆∞a t·ª´ng t·∫°o QR")
                return False
            
            # T√≠nh th·ªùi gian ƒë√£ tr·∫£i qua k·ªÉ t·ª´ l·∫ßn t·∫°o QR cu·ªëi
            generated_time = self.qr_generation_cache[cache_key]
            current_time = datetime.now()
            time_diff = current_time - generated_time
            
            # N·∫øu ƒë√£ qu√° th·ªùi gian cache th√¨ x√≥a entry v√† return False
            if time_diff > timedelta(minutes=cache_duration_minutes):
                del self.qr_generation_cache[cache_key] 
                print(f"‚è∞ Cache ƒë√£ h·∫øt h·∫°n: {cache_key} ({time_diff.total_seconds()/60:.1f} ph√∫t tr∆∞·ªõc)")
                return False
            
            print(f"üîí Cache hit: {cache_key} - QR ƒë√£ t·∫°o {time_diff.total_seconds()/60:.1f} ph√∫t tr∆∞·ªõc")
            return True
            
        except Exception as e:
            print(f"‚ùå L·ªói khi ki·ªÉm tra cache: {e}")
            return False

    def is_validation_alert_recently_sent(self, instance_code: str, validation_type: str,
                                        cache_duration_minutes: int = 10) -> bool:
        """
        Ki·ªÉm tra xem validation alert ƒë√£ ƒë∆∞·ª£c g·ª≠i trong kho·∫£ng th·ªùi gian g·∫ßn ƒë√¢y ch∆∞a.
        
        Args:
            instance_code (str): M√£ instance c·ªßa approval workflow
            validation_type (str): Lo·∫°i validation error
            cache_duration_minutes (int, optional): Th·ªùi gian cache t√≠nh b·∫±ng ph√∫t. M·∫∑c ƒë·ªãnh 10 ph√∫t.
            
        Returns:
            bool: True n·∫øu alert ƒë√£ ƒë∆∞·ª£c g·ª≠i g·∫ßn ƒë√¢y, False n·∫øu ch∆∞a ho·∫∑c ƒë√£ h·∫øt h·∫°n
        """
        try:
            cache_key = self.generate_validation_cache_key(instance_code, validation_type)
            
            # Ki·ªÉm tra xem cache key c√≥ t·ªìn t·∫°i kh√¥ng
            if cache_key not in self.validation_alert_cache:
                print(f"üÜï Validation cache miss: {cache_key} - ch∆∞a t·ª´ng g·ª≠i alert")
                return False
            
            # T√≠nh th·ªùi gian ƒë√£ tr·∫£i qua k·ªÉ t·ª´ l·∫ßn g·ª≠i alert cu·ªëi
            sent_time = self.validation_alert_cache[cache_key]
            current_time = datetime.now()
            time_diff = current_time - sent_time
            
            # N·∫øu ƒë√£ qu√° th·ªùi gian cache th√¨ x√≥a entry v√† return False
            if time_diff > timedelta(minutes=cache_duration_minutes):
                del self.validation_alert_cache[cache_key]
                print(f"‚è∞ Validation cache ƒë√£ h·∫øt h·∫°n: {cache_key} ({time_diff.total_seconds()/60:.1f} ph√∫t tr∆∞·ªõc)")
                return False
            
            print(f"üîí Validation cache hit: {cache_key} - Alert ƒë√£ g·ª≠i {time_diff.total_seconds()/60:.1f} ph√∫t tr∆∞·ªõc")
            return True
            
        except Exception as e:
            print(f"‚ùå L·ªói khi ki·ªÉm tra validation cache: {e}")
            return False

    def mark_qr_as_generated(self, instance_code: str, node_id: str, qr_type: str):
        """
        ƒê√°nh d·∫•u QR code ƒë√£ ƒë∆∞·ª£c t·∫°o b·∫±ng c√°ch l∆∞u timestamp v√†o cache.
        
        Args:
            instance_code (str): M√£ instance c·ªßa approval workflow
            node_id (str): ID c·ªßa node trong workflow
            qr_type (str): Lo·∫°i QR code
        """
        try:
            cache_key = self.generate_cache_key(instance_code, node_id, qr_type)
            self.qr_generation_cache[cache_key] = datetime.now()
            
            print(f"üîí ƒê√£ ƒë√°nh d·∫•u QR ƒë∆∞·ª£c t·∫°o: {cache_key}")
            print(f"üìä K√≠ch th∆∞·ªõc QR Cache: {len(self.qr_generation_cache)} entries")
            
        except Exception as e:
            print(f"‚ùå L·ªói khi ƒë√°nh d·∫•u cache: {e}")

    def mark_validation_alert_as_sent(self, instance_code: str, validation_type: str):
        """
        ƒê√°nh d·∫•u validation alert ƒë√£ ƒë∆∞·ª£c g·ª≠i b·∫±ng c√°ch l∆∞u timestamp v√†o cache.
        
        Args:
            instance_code (str): M√£ instance c·ªßa approval workflow
            validation_type (str): Lo·∫°i validation error
        """
        try:
            cache_key = self.generate_validation_cache_key(instance_code, validation_type)
            self.validation_alert_cache[cache_key] = datetime.now()
            
            print(f"üîí ƒê√£ ƒë√°nh d·∫•u validation alert ƒë∆∞·ª£c g·ª≠i: {cache_key}")
            print(f"üìä K√≠ch th∆∞·ªõc Validation Cache: {len(self.validation_alert_cache)} entries")
            
        except Exception as e:
            print(f"‚ùå L·ªói khi ƒë√°nh d·∫•u validation cache: {e}")

    def get_cache_status(self) -> Dict:
        """
        L·∫•y tr·∫°ng th√°i chi ti·∫øt c·ªßa t·∫•t c·∫£ cache (QR v√† validation).
        
        Returns:
            Dict: Dictionary ch·ª©a th√¥ng tin chi ti·∫øt v·ªÅ:
                - qr_cache: Th√¥ng tin v·ªÅ QR generation cache
                - validation_cache: Th√¥ng tin v·ªÅ validation alert cache
                - current_time: Th·ªùi gian hi·ªán t·∫°i
        """
        try:
            current_time = datetime.now()
            
            # T√≠nh to√°n tr·∫°ng th√°i QR Cache
            active_qr_cache = {}
            for cache_key, generated_time in self.qr_generation_cache.items():
                time_diff = current_time - generated_time
                minutes_ago = time_diff.total_seconds() / 60
                
                active_qr_cache[cache_key] = {
                    'generated_at': generated_time.isoformat(),
                    'minutes_ago': round(minutes_ago, 1),
                    'will_expire_in_minutes': max(0, 5 - minutes_ago)  # 5 ph√∫t cho QR
                }
            
            # T√≠nh to√°n tr·∫°ng th√°i Validation Cache
            active_validation_cache = {}
            for cache_key, sent_time in self.validation_alert_cache.items():
                time_diff = current_time - sent_time
                minutes_ago = time_diff.total_seconds() / 60
                
                active_validation_cache[cache_key] = {
                    'sent_at': sent_time.isoformat(),
                    'minutes_ago': round(minutes_ago, 1),
                    'will_expire_in_minutes': max(0, 10 - minutes_ago)  # 10 ph√∫t cho validation
                }
            
            return {
                'qr_cache': {
                    'total_cached_qr': len(self.qr_generation_cache),
                    'active_cache': active_qr_cache,
                    'cache_duration_minutes': 5
                },
                'validation_cache': {
                    'total_cached_alerts': len(self.validation_alert_cache),
                    'active_cache': active_validation_cache,
                    'cache_duration_minutes': 10
                },
                'current_time': current_time.isoformat()
            }
            
        except Exception as e:
            return {"error": str(e)}

    def clear_cache(self) -> Dict:
        """
        X√≥a t·∫•t c·∫£ cache entries (c·∫£ QR v√† validation) v√† tr·∫£ v·ªÅ th√¥ng tin chi ti·∫øt.
        
        Returns:
            Dict: Dictionary ch·ª©a:
                - message: Th√¥ng b√°o k·∫øt qu·∫£
                - cleared_qr_keys: Danh s√°ch QR cache keys ƒë√£ b·ªã x√≥a
                - cleared_validation_keys: Danh s√°ch validation cache keys ƒë√£ b·ªã x√≥a
                - current_cache_sizes: K√≠ch th∆∞·ªõc cache hi·ªán t·∫°i (sau khi clear)
        """
        try:
            # L∆∞u l·∫°i th√¥ng tin tr∆∞·ªõc khi clear
            old_qr_count = len(self.qr_generation_cache)
            old_validation_count = len(self.validation_alert_cache)
            old_qr_keys = list(self.qr_generation_cache.keys())
            old_validation_keys = list(self.validation_alert_cache.keys())
            
            # Clear t·∫•t c·∫£ cache
            self.qr_generation_cache.clear()
            self.validation_alert_cache.clear()
            
            return {
                'message': f'ƒê√£ x√≥a th√†nh c√¥ng {old_qr_count} QR cache entries v√† {old_validation_count} validation cache entries',
                'cleared_qr_keys': old_qr_keys,
                'cleared_validation_keys': old_validation_keys,
                'current_qr_cache_size': len(self.qr_generation_cache),
                'current_validation_cache_size': len(self.validation_alert_cache)
            }
            
        except Exception as e:
            return {"success": False, "error": str(e)}


cache_service = CacheService()

============================================================

============================================================
FILE: app\core\infrastructure\event_bus.py
============================================================
# app/services/event_bus.py
import asyncio
from typing import Dict, List, Callable, Any
from datetime import datetime


class EventBus:
    """
    Event Bus system ƒë·ªÉ qu·∫£n l√Ω v√† ph√¢n ph·ªëi events trong ·ª©ng d·ª•ng.
    
    EventBus cho ph√©p c√°c component ƒëƒÉng k√Ω handlers cho c√°c lo·∫°i event kh√°c nhau
    v√† publish events ƒë·ªÉ th·ª±c thi t·∫•t c·∫£ handlers ƒë√£ ƒëƒÉng k√Ω m·ªôt c√°ch b·∫•t ƒë·ªìng b·ªô.
    
    Attributes:
        handlers (Dict[str, List[Callable]]): Dictionary ch·ª©a danh s√°ch handlers cho t·ª´ng event type
        event_history (List[Dict]): L·ªãch s·ª≠ t·∫•t c·∫£ events ƒë√£ ƒë∆∞·ª£c publish
    """
    
    def __init__(self):
        """Kh·ªüi t·∫°o EventBus v·ªõi handlers v√† event history r·ªóng."""
        self.handlers: Dict[str, List[Callable]] = {}
        self.event_history: List[Dict] = []
    
    def subscribe(self, event_type: str, handler: Callable):
        """
        ƒêƒÉng k√Ω handler cho m·ªôt event type c·ª• th·ªÉ.
        
        Args:
            event_type (str): Lo·∫°i event c·∫ßn l·∫Øng nghe
            handler (Callable): H√†m x·ª≠ l√Ω s·∫Ω ƒë∆∞·ª£c g·ªçi khi event ƒë∆∞·ª£c publish
            
        Note:
            Handler ph·∫£i l√† async function v√† nh·∫≠n event_data l√†m tham s·ªë
        """
        # Kh·ªüi t·∫°o danh s√°ch handlers cho event type n·∫øu ch∆∞a t·ªìn t·∫°i
        if event_type not in self.handlers:
            self.handlers[event_type] = []
        
        # Th√™m handler v√†o danh s√°ch
        self.handlers[event_type].append(handler)
        print(f"üìù ƒê√£ ƒëƒÉng k√Ω handler cho event: {event_type}")
    
    async def publish(self, event_type: str, event_data: Dict[str, Any]):
        """
        Publish event v√† th·ª±c thi t·∫•t c·∫£ handlers ƒë√£ ƒëƒÉng k√Ω song song.
        
        Args:
            event_type (str): Lo·∫°i event c·∫ßn publish
            event_data (Dict[str, Any]): D·ªØ li·ªáu s·∫Ω ƒë∆∞·ª£c truy·ªÅn cho c√°c handlers
            
        Returns:
            List: Danh s√°ch k·∫øt qu·∫£ t·ª´ t·∫•t c·∫£ handlers (bao g·ªìm c·∫£ exceptions)
        """
        print(f"üì¢ ƒêang publish event: {event_type}")
        
        # L∆∞u l·ªãch s·ª≠ event
        event_record = {
            "timestamp": datetime.now().isoformat(),
            "event_type": event_type,
            "data": event_data,
            "handlers_count": len(self.handlers.get(event_type, []))
        }
        self.event_history.append(event_record)
        
        # Th·ª±c thi t·∫•t c·∫£ handlers ƒë·ªìng th·ªùi
        if event_type in self.handlers:
            tasks = []
            
            # T·∫°o task cho m·ªói handler
            for handler in self.handlers[event_type]:
                task = asyncio.create_task(
                    self._run_handler_safe(handler, event_data)
                )
                tasks.append(task)
            
            # ƒê·ª£i t·∫•t c·∫£ handlers ho√†n th√†nh (k·ªÉ c·∫£ khi c√≥ l·ªói)
            results = await asyncio.gather(*tasks, return_exceptions=True)
            
            # Ghi log k·∫øt qu·∫£ t·ª´ m·ªói handler
            for i, result in enumerate(results):
                handler_name = self.handlers[event_type][i].__name__
                if isinstance(result, Exception):
                    print(f"‚ùå Handler {handler_name} th·∫•t b·∫°i: {result}")
                else:
                    print(f"‚úÖ Handler {handler_name} ho√†n th√†nh: {result}")
            
            return results
        else:
            print(f"‚ö†Ô∏è Kh√¥ng c√≥ handler n√†o ƒë∆∞·ª£c ƒëƒÉng k√Ω cho event: {event_type}")
            return []
    
    async def _run_handler_safe(self, handler: Callable, event_data: Dict) -> Dict:
        """
        Th·ª±c thi handler v·ªõi error handling v√† monitoring th·ªùi gian.
        
        Args:
            handler (Callable): Handler function c·∫ßn th·ª±c thi
            event_data (Dict): D·ªØ li·ªáu event ƒë∆∞·ª£c truy·ªÅn cho handler
            
        Returns:
            Dict: Th√¥ng tin k·∫øt qu·∫£ bao g·ªìm success status, result/error, v√† th·ªùi gian th·ª±c thi
        """
        handler_name = handler.__name__
        try:
            print(f"üöÄ B·∫Øt ƒë·∫ßu th·ª±c thi handler: {handler_name}")
            start_time = datetime.now()
            
            # G·ªçi handler (ph·∫£i l√† async function)
            result = await handler(event_data)
            
            # T√≠nh th·ªùi gian th·ª±c thi
            end_time = datetime.now()
            duration = (end_time - start_time).total_seconds()
            
            return {
                "handler": handler_name,
                "success": True,
                "result": result,
                "duration_seconds": duration
            }
            
        except Exception as e:
            print(f"‚ùå Handler {handler_name} g·∫∑p l·ªói: {e}")
            return {
                "handler": handler_name,
                "success": False,
                "error": str(e),
                "duration_seconds": 0
            }
    
    def get_event_history(self, limit: int = 50) -> List[Dict]:
        """
        L·∫•y l·ªãch s·ª≠ c√°c events ƒë√£ ƒë∆∞·ª£c publish.
        
        Args:
            limit (int, optional): S·ªë l∆∞·ª£ng events g·∫ßn nh·∫•t c·∫ßn l·∫•y. M·∫∑c ƒë·ªãnh l√† 50.
            
        Returns:
            List[Dict]: Danh s√°ch c√°c event records theo th·ª© t·ª± th·ªùi gian (m·ªõi nh·∫•t cu·ªëi)
        """
        return self.event_history[-limit:]


event_bus = EventBus()

============================================================

============================================================
FILE: app\core\infrastructure\lark_service.py
============================================================
import requests
import json
from datetime import datetime
from typing import Optional, Dict
from app.core.config.settings import settings


class LarkService:
    """
    Service t∆∞∆°ng t√°c v·ªõi Lark/Feishu API ƒë·ªÉ qu·∫£n l√Ω approval instances.
    
    LarkService cung c·∫•p c√°c ch·ª©c nƒÉng ch√≠nh:
    - X√°c th·ª±c v√† qu·∫£n l√Ω access tokens v·ªõi caching
    - L·∫•y th√¥ng tin approval instances
    - Upload h√¨nh ·∫£nh l√™n Lark
    - T·∫°o comments v·ªõi attachments
    
    Attributes:
        access_token_cache (Dict): Cache l∆∞u tr·ªØ access token v√† th·ªùi gian h·∫øt h·∫°n
    """
    
    def __init__(self):
        """Kh·ªüi t·∫°o LarkService v·ªõi token cache r·ªóng."""
        self.access_token_cache = {"token": None, "expires_at": None}
    
    async def get_access_token(self) -> Optional[str]:
        """
        L·∫•y access token t·ª´ LarkSuite API v·ªõi caching mechanism.
        
        Method n√†y s·∫Ω s·ª≠ d·ª•ng cached token n·∫øu c√≤n hi·ªáu l·ª±c, otherwise
        s·∫Ω g·ªçi API ƒë·ªÉ l·∫•y token m·ªõi v√† cache l·∫°i.
        
        Returns:
            Optional[str]: Access token n·∫øu th√†nh c√¥ng, None n·∫øu th·∫•t b·∫°i
        """
        current_time = datetime.now().timestamp()
        
        # Ki·ªÉm tra xem token ƒë√£ cache c√≤n hi·ªáu l·ª±c kh√¥ng
        if (self.access_token_cache["token"] and 
            self.access_token_cache["expires_at"] and 
            current_time < self.access_token_cache["expires_at"]):
            return self.access_token_cache["token"]
        
        try:
            # G·ªçi API ƒë·ªÉ l·∫•y tenant access token m·ªõi
            url = f"{settings.BASE_URL}/auth/v3/tenant_access_token/internal"
            payload = {
                "app_id": settings.LARK_APP_ID,
                "app_secret": settings.LARK_APP_SECRET
            }
            
            response = requests.post(url, json=payload, timeout=10)
            data = response.json()
            
            # Ki·ªÉm tra response t·ª´ API
            if data.get("code") == 0:
                token = data["tenant_access_token"]
                expires_in = data.get("expire", 7200)  # M·∫∑c ƒë·ªãnh 2 ti·∫øng
                
                # Cache token v·ªõi buffer time ƒë·ªÉ tr√°nh token h·∫øt h·∫°n gi·ªØa ch·ª´ng
                self.access_token_cache["token"] = token
                self.access_token_cache["expires_at"] = current_time + expires_in - settings.TOKEN_CACHE_BUFFER_SECONDS
                
                print(f"‚úÖ L·∫•y access token th√†nh c√¥ng")
                return token
            else:
                print(f"‚ùå L·∫•y token th·∫•t b·∫°i: {data}")
                return None
                
        except Exception as e:
            print(f"‚ùå L·ªói khi l·∫•y token: {e}")
            return None

    async def get_approval_instance(self, instance_code: str, access_token: str) -> Optional[Dict]:
        """
        L·∫•y th√¥ng tin chi ti·∫øt c·ªßa approval instance t·ª´ Lark API.
        
        Args:
            instance_code (str): M√£ ƒë·ªãnh danh c·ªßa approval instance
            access_token (str): Access token ƒë·ªÉ x√°c th·ª±c API call
            
        Returns:
            Optional[Dict]: Th√¥ng tin instance n·∫øu th√†nh c√¥ng, None n·∫øu th·∫•t b·∫°i
        """
        try:
            url = f"{settings.BASE_URL}/approval/v4/instances/{instance_code}"
            headers = {"Authorization": f"Bearer {access_token}"}
            
            print(f"üîç ƒêang l·∫•y th√¥ng tin instance: {instance_code}")
            response = requests.get(url, headers=headers, timeout=10)
            
            # Ki·ªÉm tra HTTP status code
            if response.status_code != 200:
                print(f"‚ùå L·ªói HTTP khi g·ªçi API: {response.status_code}")
                return None
                
            api_response = response.json()
            
            # Ki·ªÉm tra Lark API response code
            if api_response.get("code") != 0:
                print(f"‚ùå L·ªói Lark API response: {api_response}")
                return None
                
            return api_response
            
        except Exception as e:
            print(f"‚ùå L·ªói khi l·∫•y th√¥ng tin approval instance: {e}")
            return None

    async def upload_image_to_approval(self, image_buffer, filename: str, access_token: str) -> Dict:
        """
        Upload h√¨nh ·∫£nh l√™n Lark Approval system ƒë·ªÉ s·ª≠ d·ª•ng trong comments.
        
        Args:
            image_buffer: Buffer ch·ª©a d·ªØ li·ªáu h√¨nh ·∫£nh (bytes)
            filename (str): T√™n file c·ªßa h√¨nh ·∫£nh
            access_token (str): Access token ƒë·ªÉ x√°c th·ª±c API call
            
        Returns:
            Dict: Dictionary ch·ª©a:
                - success (bool): Tr·∫°ng th√°i upload
                - file_code (str): M√£ file t·ª´ Lark (n·∫øu success)  
                - file_url (str): URL file t·ª´ Lark (n·∫øu success)
                - error (str): Th√¥ng b√°o l·ªói (n·∫øu failed)
        """
        try:
            # Reset buffer position v·ªÅ ƒë·∫ßu ƒë·ªÉ ƒë·ªçc t·ª´ beginning
            image_buffer.seek(0)
            
            # Chu·∫©n b·ªã multipart form data cho upload
            files = {
                'name': (None, filename),
                'type': (None, 'image'),
                'content': (filename, image_buffer, 'image/png')
            }
            
            headers = {
                'Authorization': f'Bearer {access_token}'
            }
            
            print(f"üì§ ƒêang upload h√¨nh ·∫£nh: {filename}")
            response = requests.post(settings.APPROVAL_UPLOAD_URL, files=files, headers=headers)
            
            # X·ª≠ l√Ω response t·ª´ upload API
            if response.status_code == 200:
                data = response.json()
                if data.get('code') == 0:
                    file_code = data['data']['code']
                    file_url = data['data']['url']
                    print(f'‚úÖ Upload h√¨nh ·∫£nh th√†nh c√¥ng! File code: {file_code}')
                    return {
                        'success': True,
                        'file_code': file_code,
                        'file_url': file_url
                    }
                else:
                    error_msg = f"L·ªói API: {data.get('msg')} (code: {data.get('code')})"
                    print(f'‚ùå Upload th·∫•t b·∫°i: {error_msg}')
                    return {'success': False, 'error': error_msg}
            else:
                error_msg = f"L·ªói HTTP: {response.status_code}"
                print(f'‚ùå Upload th·∫•t b·∫°i: {error_msg}')
                return {'success': False, 'error': error_msg}
                
        except Exception as e:
            error_msg = f"Exception: {str(e)}"
            print(f"‚ùå L·ªói upload: {error_msg}")
            return {'success': False, 'error': error_msg}

    async def create_enhanced_comment_with_image(self, instance_code: str, file_url: str, file_code: str, 
                                               filename: str, qr_type: str, amount: int, node_name: str,
                                               access_token: str, user_id: str = None) -> Dict:
        """
        T·∫°o comment v·ªõi h√¨nh ·∫£nh QR code v√† th√¥ng tin chi ti·∫øt.
        
        Args:
            instance_code (str): M√£ instance c·ªßa approval workflow
            file_url (str): URL c·ªßa file ƒë√£ upload
            file_code (str): Code c·ªßa file t·ª´ Lark system
            filename (str): T√™n file h√¨nh ·∫£nh
            qr_type (str): Lo·∫°i QR ('advance' ho·∫∑c 'payment')
            amount (int): S·ªë ti·ªÅn c·ªßa QR code
            node_name (str): T√™n node trong workflow
            access_token (str): Access token ƒë·ªÉ x√°c th·ª±c
            user_id (str, optional): User ID th·ª±c hi·ªán comment
            
        Returns:
            Dict: Dictionary ch·ª©a:
                - success (bool): Tr·∫°ng th√°i t·∫°o comment
                - comment_id (str): ID c·ªßa comment ƒë∆∞·ª£c t·∫°o (n·∫øu success)
                - error (str): Th√¥ng b√°o l·ªói (n·∫øu failed)
        """
        try:
            # S·ª≠ d·ª•ng default user ID n·∫øu kh√¥ng ƒë∆∞·ª£c cung c·∫•p
            if user_id is None:
                user_id = settings.DEFAULT_USER_ID
                
            create_comment_url = f'{settings.BASE_URL}/approval/v4/instances/{instance_code}/comments'
            
            # Parameters cho API call
            params = {
                "user_id": user_id,
                "user_id_type": "user_id"
            }
            
            # T·∫°o text hi·ªÉn th·ªã cho QR type
            qr_type_display = {
                'advance': 'T·∫†M ·ª®NG',
                'payment': 'THANH TO√ÅN'
            }
            
            # T·∫°o n·ªôi dung comment v·ªõi th√¥ng tin chi ti·∫øt
            comment_text = f"""üè¶ M√£ VietQR {qr_type_display.get(qr_type, qr_type.upper())}
üí∞ S·ªë ti·ªÅn: {amount:,} VND"""

            # ∆Ø·ªõc t√≠nh k√≠ch th∆∞·ªõc file (rough estimate)
            try:
                file_size = len(filename) * 100  # ∆Ø·ªõc t√≠nh d·ª±a tr√™n ƒë·ªô d√†i filename
            except:
                file_size = 50000  # Gi√° tr·ªã m·∫∑c ƒë·ªãnh

            # T·∫°o content data v·ªõi text v√† file attachment
            content_data = {
                "text": comment_text,
                "files": [{
                    "url": file_url,
                    "fileSize": file_size,
                    "title": filename,
                    "type": "image",
                    "extra": file_code
                }]
            }
            
            # Request body v·ªõi JSON content
            request_body = {
                "content": json.dumps(content_data, ensure_ascii=False)
            }
            
            headers_comment = {
                'Authorization': f'Bearer {access_token}',
                'Content-Type': 'application/json'
            }
            
            print(f"üì§ ƒêang t·∫°o enhanced comment cho instance: {instance_code}")
            print(f"   N·ªôi dung: {comment_text.replace(chr(10), ' | ')}")
            
            # G·ªçi API ƒë·ªÉ t·∫°o comment
            response = requests.post(
                create_comment_url, 
                params=params,
                json=request_body, 
                headers=headers_comment
            )
            
            # X·ª≠ l√Ω response t·ª´ comment API
            if response.status_code == 200:
                comment_result = response.json()
                if comment_result.get('code') == 0:
                    comment_id = comment_result.get("data", {}).get("comment_id", "N/A")
                    print(f'‚úÖ T·∫°o enhanced comment th√†nh c√¥ng! Comment ID: {comment_id}')
                    return {'success': True, 'comment_id': comment_id}
                else:
                    error_msg = f"L·ªói API: {comment_result.get('msg')} (code: {comment_result.get('code')})"
                    print(f'‚ùå T·∫°o comment th·∫•t b·∫°i: {error_msg}')
                    return {'success': False, 'error': error_msg}
            else:
                error_msg = f"L·ªói HTTP: {response.status_code}"
                print(f'‚ùå T·∫°o comment th·∫•t b·∫°i: {error_msg}')
                return {'success': False, 'error': error_msg}
                
        except Exception as e:
            error_msg = f"Exception: {str(e)}"
            print(f"‚ùå L·ªói t·∫°o enhanced comment: {error_msg}")
            return {'success': False, 'error': error_msg}


lark_service = LarkService()

============================================================

============================================================
FILE: app\core\models\event.py
============================================================
from pydantic import BaseModel
from typing import Optional, Dict, Any
from datetime import datetime

class EventHeader(BaseModel):
    event_id: Optional[str] = None
    event_type: Optional[str] = None
    create_time: Optional[str] = None
    token: Optional[str] = None
    tenant_key: Optional[str] = None
    app_id: Optional[str] = None

class EventBody(BaseModel):
    instance_code: Optional[str] = None
    type: Optional[str] = None
    object: Optional[Dict[str, Any]] = None

class LarkEvent(BaseModel):
    schema: Optional[str] = None
    header: Optional[EventHeader] = None
    event: Optional[EventBody] = None
    type: Optional[str] = None  # For URL verification
    challenge: Optional[str] = None  # For URL verification

class EventRecord(BaseModel):
    timestamp: datetime
    event_type: str
    instance_code: Optional[str]
    raw_event: str

============================================================

============================================================
FILE: app\core\models\response.py
============================================================
from pydantic import BaseModel
from typing import Optional, Dict, Any, List

class APIResponse(BaseModel):
    success: bool
    message: Optional[str] = None
    data: Optional[Dict[str, Any]] = None
    error: Optional[str] = None

class UploadResult(BaseModel):
    success: bool
    file_code: Optional[str] = None
    file_url: Optional[str] = None
    error: Optional[str] = None

class CommentResult(BaseModel):
    success: bool
    comment_id: Optional[str] = None
    error: Optional[str] = None

class QRGenerationResult(BaseModel):
    success: bool
    qr_type: Optional[str] = None
    amount: Optional[float] = None
    field_used: Optional[str] = None
    node_name: Optional[str] = None
    comment_id: Optional[str] = None
    error: Optional[str] = None
    processing_info: Optional[Dict[str, Any]] = None

class CacheStatus(BaseModel):
    total_cached_qr: int
    active_cache: Dict[str, Dict[str, Any]]
    cache_duration_minutes: int
    current_time: str

============================================================

============================================================
FILE: app\core\models\shared.py
============================================================
from pydantic import BaseModel
from typing import Optional, List, Dict, Any

class FormField(BaseModel):
    name: Optional[str] = None
    type: Optional[str] = None
    value: Optional[Any] = None

class TaskInfo(BaseModel):
    node_id: Optional[str] = None
    status: Optional[str] = None
    task_id: Optional[str] = None
    node_name: Optional[str] = None

class ApprovalInstance(BaseModel):
    instance_code: str
    status: Optional[str] = None
    form: Optional[str] = None
    task_list: Optional[List[TaskInfo]] = None

============================================================

============================================================
FILE: app\core\routers\monitoring.py
============================================================
from fastapi import APIRouter
from app.core.infrastructure.event_bus import event_bus
from app.core.bootstrap.application import app_bootstrap

router = APIRouter()

@router.get("/system/health")
async def get_system_health():
    """System health check v·ªõi DDD architecture"""
    return {
        "status": "healthy" if app_bootstrap.is_initialized else "initializing",
        "application": app_bootstrap.get_startup_info(),
        "event_system": {
            "total_event_types": len(event_bus.handlers),
            "registered_events": list(event_bus.handlers.keys()),
            "total_handlers": sum(len(handlers) for handlers in event_bus.handlers.values())
        }
    }

@router.get("/events/history")
async def get_event_history(limit: int = 50):
    """Event processing history"""
    return {
        "recent_events": event_bus.get_event_history(limit),
        "handlers": {
            event_type: [handler.__name__ for handler in handlers]
            for event_type, handlers in event_bus.handlers.items()
        }
    }

@router.post("/events/test/{instance_code}")
async def test_event_processing(instance_code: str):
    """Test event processing system"""
    event_data = {
        "instance_code": instance_code,
        "event_type": "test_event",
        "timestamp": "manual_test"
    }
    
    results = await event_bus.publish("approval.instance.updated", event_data)
    
    return {
        "test_instance": instance_code,
        "handlers_executed": len(results),
        "results": results,
        "architecture": "DDD"
    }

============================================================

============================================================
FILE: app\core\routers\webhook.py
============================================================
from fastapi import APIRouter, Request
from fastapi.responses import JSONResponse
from app.core.infrastructure.event_bus import event_bus
from app.core.utils.helpers import save_event_to_csv, get_event_type, extract_instance_code
from app.core.config.settings import settings

router = APIRouter()

@router.post("/webhook")
async def handle_lark_webhook(request: Request):
    """
    X·ª≠ l√Ω webhook t·ª´ Lark v·ªõi ki·∫øn tr√∫c DDD

    Ch·ª©c nƒÉng ch√≠nh:
    - Nh·∫≠n v√† x·ª≠ l√Ω c√°c s·ª± ki·ªán webhook t·ª´ Lark
    - X√°c th·ª±c URL verification cho webhook setup
    - L∆∞u tr·ªØ t·∫•t c·∫£ events v√†o file CSV ƒë·ªÉ audit
    - X·ª≠ l√Ω c√°c s·ª± ki·ªán ph√™ duy·ªát qua event bus pattern
    - Tr·∫£ v·ªÅ response ph√π h·ª£p cho t·ª´ng lo·∫°i event

    Args:
        request (Request): HTTP request ch·ª©a webhook data t·ª´ Lark

    Returns:
        JSONResponse: 
            - ƒê·ªëi v·ªõi URL verification: {"challenge": "..."}
            - ƒê·ªëi v·ªõi events th√†nh c√¥ng: {"status": "success", "architecture": "DDD"}
            - ƒê·ªëi v·ªõi l·ªói: {"error": "..."} v·ªõi status 500
    """
    try:
        data = await request.json()
        print(f"üì® Nh·∫≠n ƒë∆∞·ª£c webhook: {get_event_type(data)}")

        # X·ª≠ l√Ω x√°c th·ª±c URL khi setup webhook
        if data.get("type") == "url_verification":
            print("üîê ƒêang x·ª≠ l√Ω URL verification")
            return JSONResponse(content={"challenge": data.get("challenge")})

        print("üíæ ƒêang l∆∞u event v√†o CSV...")
        await save_event_to_csv(data, settings.EVENTS_FILE)

        # X·ª≠ l√Ω c√°c s·ª± ki·ªán ph√™ duy·ªát th√¥ng qua event bus
        event_type = get_event_type(data)
        if "approval" in event_type.lower():
            instance_code = extract_instance_code(data)
            if instance_code:
                print(f"üîç ƒêang x·ª≠ l√Ω instance ph√™ duy·ªát: {instance_code}")

                # Ph√°t h√†nh event qua event bus - s·∫Ω k√≠ch ho·∫°t t·∫•t c·∫£ handlers ƒë√£ ƒëƒÉng k√Ω
                print("üì° ƒêang ph√°t h√†nh event qua event bus...")
                await event_bus.publish("approval.instance.updated", {
                    "instance_code": instance_code,
                    "event_type": event_type,
                    "timestamp": data.get("header", {}).get("create_time"),
                    "raw_data": data
                })
                print("‚úÖ ƒê√£ ph√°t h√†nh event th√†nh c√¥ng")
            else:
                print("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y instance code trong event ph√™ duy·ªát")

        print("üéâ X·ª≠ l√Ω webhook ho√†n t·∫•t")
        return JSONResponse(content={"status": "success", "architecture": "DDD"})

    except Exception as e:
        print(f"‚ùå L·ªói khi x·ª≠ l√Ω webhook: {e}")
        return JSONResponse(content={"error": str(e)}, status_code=500)
============================================================

============================================================
FILE: app\core\utils\__init__.py
============================================================
from .helpers import extract_instance_code, get_event_type, format_currency, get_short_node_id
from .field_extractor import FieldExtractor
from .amount_detector import AmountDetector

__all__ = [
    "extract_instance_code", "get_event_type", "format_currency", "get_short_node_id",
    "FieldExtractor", "AmountDetector"
]

============================================================

============================================================
FILE: app\core\utils\amount_detector.py
============================================================
from typing import Dict, List, Optional
from app.core.config.node_config import get_node_config
from app.core.utils.field_extractor import FieldExtractor

class AmountDetector:
    def __init__(self):
        self.field_extractor = FieldExtractor()
    
    def detect_available_amount_fields(self, form_data: List[Dict], node_config: Dict = None) -> Dict:
        """
        Scan form data ƒë·ªÉ t√¨m amount fields theo config c·ªßa node
        
        Args:
            form_data (list): Form data t·ª´ API response
            node_config (dict): Node configuration (optional)
            
        Returns:
            dict: Detection results v·ªõi c√°c fields v√† values
        """
        try:
            # S·ª≠ d·ª•ng config t·ª´ node thay v√¨ hardcode
            if node_config:
                advance_field = node_config.get('advance_field')
                payment_field = node_config.get('payment_field')
            else:
                # Fallback cho backward compatibility
                advance_field = "S·ªë ti·ªÅn t·∫°m ·ª©ng"
                payment_field = "S·ªë ti·ªÅn thanh to√°n"
            
            # Extract c·∫£ 2 fields (ch·ªâ khi field name kh√¥ng ph·∫£i None)
            advance_value = self.field_extractor.extract_field_value(form_data, advance_field) if advance_field else None
            payment_value = self.field_extractor.extract_field_value(form_data, payment_field) if payment_field else None
            
            # Debug: t√¨m t·∫•t c·∫£ fields c√≥ ch·ª©a "ti·ªÅn" ho·∫∑c "amount" 
            all_amount_fields = self.field_extractor.get_amount_fields(form_data)
            
            result = {
                'advance_amount': advance_value,
                'payment_amount': payment_value,
                'advance_field_found': advance_value is not None,
                'payment_field_found': payment_value is not None,
                'all_amount_fields': all_amount_fields,
                'fields_used': {
                    'advance_field': advance_field,
                    'payment_field': payment_field
                }
            }
            
            print(f"üí∞ Field detection results:")
            if advance_field:
                print(f"   - {advance_field}: {'‚úÖ ' + str(advance_value) if advance_value else '‚ùå Not found'}")
            else:
                print(f"   - Advance field: ‚ùå Not configured")
                
            if payment_field:
                print(f"   - {payment_field}: {'‚úÖ ' + str(payment_value) if payment_value else '‚ùå Not found'}")
            else:
                print(f"   - Payment field: ‚ùå Not configured")
                
            print(f"   - All amount fields: {list(all_amount_fields.keys())}")
            
            return result
            
        except Exception as e:
            print(f"‚ùå Error detecting amount fields: {e}")
            return {
                'advance_amount': None,
                'payment_amount': None,
                'advance_field_found': False,
                'payment_field_found': False,
                'all_amount_fields': {},
                'fields_used': {'advance_field': None, 'payment_field': None},
                'error': str(e)
            }
    
    def determine_qr_type_by_fields(self, field_detection_result: Dict) -> Dict:
        """
        Quy·∫øt ƒë·ªãnh QR type d·ª±a tr√™n fields c√≥ gi√° tr·ªã
        
        Args:
            field_detection_result (dict): K·∫øt qu·∫£ t·ª´ detect_available_amount_fields()
            
        Returns:
            dict: QR type decision result
        """
        try:
            advance_found = field_detection_result.get('advance_field_found', False)
            payment_found = field_detection_result.get('payment_field_found', False)
            advance_amount = field_detection_result.get('advance_amount')
            payment_amount = field_detection_result.get('payment_amount')

            fields_used = field_detection_result.get('fields_used', {})
            advance_field_name = fields_used.get('advance_field', 'S·ªë ti·ªÅn t·∫°m ·ª©ng')
            payment_field_name = fields_used.get('payment_field', 'S·ªë ti·ªÅn thanh to√°n')

            print(f"üéØ Determining QR type: advance={advance_found}, payment={payment_found}")
            
            # Logic priority: advance tr∆∞·ªõc, sau ƒë√≥ payment
            if advance_found and advance_amount:
                try:
                    amount_value = float(advance_amount)
                    if amount_value > 0:
                        return {
                            'qr_type': 'advance',
                            'amount': amount_value,
                            'field_used': advance_field_name,
                            'reason': 'Found valid advance amount'
                        }
                except (ValueError, TypeError):
                    print(f"‚ö†Ô∏è Invalid advance amount: {advance_amount}")
            
            if payment_found and payment_amount:
                try:
                    amount_value = float(payment_amount)
                    if amount_value > 0:
                        return {
                            'qr_type': 'payment', 
                            'amount': amount_value,
                            'field_used': payment_field_name,
                            'reason': 'Found valid payment amount'
                        }
                except (ValueError, TypeError):
                    print(f"‚ö†Ô∏è Invalid payment amount: {payment_amount}")
            
            # Kh√¥ng t√¨m th·∫•y field h·ª£p l·ªá
            return {
                'qr_type': 'none',
                'amount': None,
                'field_used': None,
                'reason': f'No valid amount found (advance_found={advance_found}, payment_found={payment_found})'
            }
            
        except Exception as e:
            print(f"‚ùå Error determining QR type: {e}")
            return {
                'qr_type': 'none',
                'amount': None,
                'field_used': None,
                'reason': f'Error: {str(e)}'
            }
    
    def get_amount_and_type_for_node(self, node_id: str, form_data: List[Dict]) -> Dict:
        """
        L·∫•y amount v√† QR type cho m·ªôt node c·ª• th·ªÉ d·ª±a tr√™n strategy c·ªßa node ƒë√≥
        
        Args:
            node_id (str): Node ID
            form_data (list): Form data t·ª´ API
            
        Returns:
            dict: Processing result v·ªõi success, qr_type, amount, etc.
        """
        try:
            node_config = get_node_config(node_id)
            if not node_config:
                return {
                    'success': False,
                    'qr_type': 'none',
                    'error': f'Node {node_id} not found in configuration'
                }
            
            strategy = node_config['strategy']
            node_name = node_config['name']
            
            print(f"üîç Processing node: {node_name} (strategy: {strategy})")
            
            # Detect available fields
            field_detection = self.detect_available_amount_fields(form_data, node_config)
            
            if strategy == "detect_both_fields":
                # Dual detection: c√≥ th·ªÉ l√† advance ho·∫∑c payment
                qr_decision = self.determine_qr_type_by_fields(field_detection)
                
                return {
                    'success': qr_decision['qr_type'] != 'none',
                    'qr_type': qr_decision['qr_type'],
                    'amount': qr_decision['amount'],
                    'field_used': qr_decision['field_used'],
                    'node_strategy': strategy,
                    'reason': f"Dual detection result: {qr_decision['reason']}",
                    'field_detection': field_detection
                }
                
            elif strategy == "payment_field_only":
                # Payment only: ch·ªâ check payment field
                payment_amount = field_detection.get('payment_amount')
                payment_found = field_detection.get('payment_field_found', False)
                payment_field_name = node_config.get('payment_field')

                if payment_found and payment_amount:
                    try:
                        amount_value = float(payment_amount)
                        if amount_value > 0:
                            return {
                                'success': True,
                                'qr_type': 'payment',
                                'amount': amount_value,
                                'field_used': payment_field_name,
                                'node_strategy': strategy,
                                'reason': 'Payment-only strategy: found valid payment amount',
                                'field_detection': field_detection
                            }
                    except (ValueError, TypeError):
                        pass
                
                return {
                    'success': False,
                    'qr_type': 'none',
                    'amount': None,
                    'field_used': None,
                    'node_strategy': strategy,
                    'reason': f'Payment-only strategy: no valid payment amount (found={payment_found}, value={payment_amount})',
                    'field_detection': field_detection
                }
            
            else:
                return {
                    'success': False,
                    'qr_type': 'none',
                    'error': f'Unknown strategy: {strategy}'
                }
                
        except Exception as e:
            print(f"‚ùå Error processing node {node_id}: {e}")
            return {
                'success': False,
                'qr_type': 'none',
                'error': str(e)
            }

============================================================

============================================================
FILE: app\core\utils\field_extractor.py
============================================================
from typing import List, Dict, Any, Optional

class FieldExtractor:
    def extract_field_value(self, form_data: List[Dict], field_name: str, debug: bool = False) -> Optional[Any]:
        """
        Enhanced version: Tr√≠ch xu·∫•t gi√° tr·ªã c·ªßa m·ªôt field t·ª´ form data v·ªõi better error handling
        
        Args:
            form_data (list): Form data t·ª´ API
            field_name (str): T√™n field c·∫ßn t√¨m
            debug (bool): In debug info
            
        Returns:
            Gi√° tr·ªã field ho·∫∑c None n·∫øu kh√¥ng t√¨m th·∫•y
        """
        try:
            if debug:
                print(f"üîç Searching for field: '{field_name}'")
                
            # Search in top-level fields
            for field in form_data:
                if field.get('name') == field_name:
                    value = field.get('value')
                    if debug:
                        print(f"‚úÖ Found '{field_name}' in top-level: {value}")
                    return value
                
                # Search in nested fieldList
                if field.get('type') == 'fieldList' and 'value' in field:
                    field_list_values = field['value']
                    if isinstance(field_list_values, list):
                        for field_group in field_list_values:
                            if isinstance(field_group, list):
                                for sub_field in field_group:
                                    if isinstance(sub_field, dict) and sub_field.get('name') == field_name:
                                        value = sub_field.get('value')
                                        if debug:
                                            print(f"‚úÖ Found '{field_name}' in fieldList: {value}")
                                        return value
            
            if debug:
                print(f"‚ùå Field '{field_name}' not found")
                print("Available fields:", [f.get('name') for f in form_data if f.get('name')])
                
            return None
            
        except Exception as e:
            print(f"‚ùå Error extracting field '{field_name}': {e}")
            return None

    def get_all_field_names(self, form_data: List[Dict]) -> List[str]:
        """
        L·∫•y t·∫•t c·∫£ field names t·ª´ form data
        
        Args:
            form_data: Form data t·ª´ API
            
        Returns:
            List[str]: Danh s√°ch t√™n fields
        """
        field_names = []
        
        try:
            for field in form_data:
                field_name = field.get('name')
                if field_name:
                    field_names.append(field_name)
                
                # Check nested fieldList
                if field.get('type') == 'fieldList' and 'value' in field:
                    field_list_values = field['value']
                    if isinstance(field_list_values, list):
                        for field_group in field_list_values:
                            if isinstance(field_group, list):
                                for sub_field in field_group:
                                    if isinstance(sub_field, dict):
                                        sub_field_name = sub_field.get('name')
                                        if sub_field_name:
                                            field_names.append(sub_field_name)
        except Exception as e:
            print(f"‚ùå Error getting field names: {e}")
        
        return list(set(field_names))  # Remove duplicates

    def get_amount_fields(self, form_data: List[Dict]) -> Dict[str, Any]:
        """
        T√¨m t·∫•t c·∫£ fields c√≥ ch·ª©a "ti·ªÅn" ho·∫∑c "amount"
        
        Args:
            form_data: Form data t·ª´ API
            
        Returns:
            Dict[str, Any]: Dict v·ªõi field name l√† key, value l√† gi√° tr·ªã
        """
        amount_fields = {}
        
        try:
            for field in form_data:
                field_name = field.get('name', '').lower()
                if 'ti·ªÅn' in field_name or 'amount' in field_name:
                    amount_fields[field.get('name')] = field.get('value')
        except Exception as e:
            print(f"‚ùå Error getting amount fields: {e}")
        
        return amount_fields

    def extract_field_from_fieldlist(self, form_data: List[Dict], fieldlist_name: str, 
                                target_field_name: str, debug: bool = False) -> Optional[Any]:
        """
        Tr√≠ch xu·∫•t gi√° tr·ªã ƒë·∫ßu ti√™n c·ªßa m·ªôt field t·ª´ b√™n trong m·ªôt fieldList c·ª• th·ªÉ.
        
        H√†m n√†y ch·ªâ tr·∫£ v·ªÅ gi√° tr·ªã ƒë·∫ßu ti√™n t√¨m th·∫•y. ƒê·ªÉ l·∫•y t·∫•t c·∫£ gi√° tr·ªã,
        s·ª≠ d·ª•ng `extract_all_values_from_fieldlist`.
        
        Args:
            form_data: Form data t·ª´ API
            fieldlist_name: T√™n fieldList container (vd: "K·∫ø to√°n - Th√¥ng tin t·∫°m ·ª©ng")  
            target_field_name: T√™n field c·∫ßn t√¨m (vd: "S·ªë ti·ªÅn chi")
            debug: In debug info
            
        Returns:
            Gi√° tr·ªã field ho·∫∑c None n·∫øu kh√¥ng t√¨m th·∫•y
        """
        try:
            if debug:
                print(f"üîç Searching for first '{target_field_name}' in fieldList '{fieldlist_name}'")
                
            if not fieldlist_name or not target_field_name:
                if debug: print("‚ùå Invalid parameters: fieldlist_name and target_field_name required")
                return None
                
            for field in form_data:
                if field.get('name') == fieldlist_name and field.get('type') == 'fieldList':
                    field_list_values = field.get('value', [])
                    if debug: print(f"üìã Found fieldList '{fieldlist_name}' with {len(field_list_values)} items")
                    
                    for field_group in field_list_values:
                        if isinstance(field_group, list):
                            for sub_field in field_group:
                                if isinstance(sub_field, dict) and sub_field.get('name') == target_field_name:
                                    value = sub_field.get('value')
                                    if debug: print(f"‚úÖ Found first '{target_field_name}' = {value}")
                                    return value
                    
                    if debug: print(f"‚ùå Field '{target_field_name}' not found in fieldList")
                    return None
            
            if debug:
                print(f"‚ùå fieldList '{fieldlist_name}' not found")
                available = [f.get('name') for f in form_data if f.get('type') == 'fieldList']
                print(f"Available fieldLists: {available}")
            return None
            
        except Exception as e:
            print(f"‚ùå Error extracting field from fieldList: {e}")
            return None
            
    def extract_all_values_from_fieldlist(self, form_data: List[Dict], fieldlist_name: str, 
                                          target_field_name: str, debug: bool = False) -> List[Any]:
        """
        ‚úÖ M·ªöI: Tr√≠ch xu·∫•t T·∫§T C·∫¢ c√°c gi√° tr·ªã c·ªßa m·ªôt field t·ª´ T·∫§T C·∫¢ c√°c d√≤ng trong m·ªôt fieldList.
        
        H·ªØu √≠ch khi c·∫ßn t√≠nh t·ªïng c√°c gi√° tr·ªã trong m·ªôt danh s√°ch, v√≠ d·ª• nh∆∞ t·ªïng "S·ªë ti·ªÅn chi"
        t·ª´ nhi·ªÅu l·∫ßn t·∫°m ·ª©ng c·ªßa k·∫ø to√°n.
        
        Args:
            form_data: Form data t·ª´ API.
            fieldlist_name: T√™n c·ªßa fieldList container (v√≠ d·ª•: "K·∫ø to√°n - Th√¥ng tin t·∫°m ·ª©ng").
            target_field_name: T√™n c·ªßa field c·∫ßn tr√≠ch xu·∫•t gi√° tr·ªã (v√≠ d·ª•: "S·ªë ti·ªÅn chi").
            debug: B·∫≠t/t·∫Øt in th√¥ng tin g·ª° l·ªói.
            
        Returns:
            List[Any]: M·ªôt danh s√°ch ch·ª©a t·∫•t c·∫£ c√°c gi√° tr·ªã t√¨m th·∫•y. Tr·∫£ v·ªÅ list r·ªóng n·∫øu kh√¥ng t√¨m th·∫•y g√¨.
        """
        extracted_values = []
        try:
            if debug:
                print(f"üîç Searching for ALL '{target_field_name}' values in fieldList '{fieldlist_name}'")

            for field in form_data:
                if field.get('name') == fieldlist_name and field.get('type') == 'fieldList':
                    field_list_values = field.get('value', [])
                    if debug:
                        print(f"üìã Found fieldList '{fieldlist_name}' with {len(field_list_values)} rows.")
                    
                    # Duy·ªát qua t·ª´ng d√≤ng (field_group) trong fieldList
                    for i, field_group in enumerate(field_list_values):
                        if isinstance(field_group, list):
                            # Duy·ªát qua t·ª´ng tr∆∞·ªùng (sub_field) trong d√≤ng
                            for sub_field in field_group:
                                if isinstance(sub_field, dict) and sub_field.get('name') == target_field_name:
                                    value = sub_field.get('value')
                                    extracted_values.append(value)
                                    if debug:
                                        print(f"   ‚úÖ Row {i+1}: Found value '{value}'")
                    
                    # Sau khi duy·ªát xong, kh√¥ng c·∫ßn t√¨m n·ªØa
                    if debug:
                        print(f"üìä Total values found: {len(extracted_values)}")
                    return extracted_values
            
            if debug:
                print(f"‚ùå FieldList '{fieldlist_name}' not found in form data.")
            return extracted_values

        except Exception as e:
            print(f"‚ùå Error extracting all values from fieldList: {e}")
            return extracted_values

    def extract_fields_by_prefix(self, form_data: List[Dict], prefix: str, debug: bool = False) -> Dict[str, Any]:
        """
        ‚úÖ M·ªöI: Tr√≠ch xu·∫•t t·∫•t c·∫£ c√°c tr∆∞·ªùng c√≥ t√™n b·∫Øt ƒë·∫ßu b·∫±ng m·ªôt ti·ªÅn t·ªë (prefix) cho tr∆∞·ªõc.
        
        H·ªØu √≠ch ƒë·ªÉ t√¨m c√°c tr∆∞·ªùng ƒë·ªông nh∆∞ "S·ªë ti·ªÅn t·∫°m ·ª©ng l·∫ßn 1:", "S·ªë ti·ªÅn t·∫°m ·ª©ng l·∫ßn 2:",...
        
        Args:
            form_data: Form data t·ª´ API.
            prefix: Ti·ªÅn t·ªë d√πng ƒë·ªÉ t√¨m ki·∫øm (v√≠ d·ª•: "S·ªë ti·ªÅn t·∫°m ·ª©ng l·∫ßn").
            debug: B·∫≠t/t·∫Øt in th√¥ng tin g·ª° l·ªói.
            
        Returns:
            Dict[str, Any]: M·ªôt dictionary v·ªõi key l√† t√™n ƒë·∫ßy ƒë·ªß c·ªßa tr∆∞·ªùng v√† value l√† gi√° tr·ªã c·ªßa n√≥.
        """
        extracted_fields = {}
        try:
            if debug:
                print(f"üîç Searching for all fields with prefix: '{prefix}'")
            
            # Duy·ªát qua t·∫•t c·∫£ c√°c tr∆∞·ªùng ·ªü m·ªçi c·∫•p ƒë·ªô
            for field in form_data:
                field_name = field.get('name')
                
                # Ki·ªÉm tra tr∆∞·ªùng ·ªü c·∫•p cao nh·∫•t
                if field_name and field_name.startswith(prefix):
                    value = field.get('value')
                    extracted_fields[field_name] = value
                    if debug:
                        print(f"   ‚úÖ Found top-level field: '{field_name}' = {value}")
                
                # Ki·ªÉm tra c√°c tr∆∞·ªùng l·ªìng trong fieldList
                if field.get('type') == 'fieldList' and 'value' in field:
                    field_list_values = field.get('value', [])
                    if isinstance(field_list_values, list):
                        for field_group in field_list_values:
                            if isinstance(field_group, list):
                                for sub_field in field_group:
                                    sub_field_name = sub_field.get('name')
                                    if sub_field_name and sub_field_name.startswith(prefix):
                                        value = sub_field.get('value')
                                        extracted_fields[sub_field_name] = value
                                        if debug:
                                            print(f"   ‚úÖ Found nested field: '{sub_field_name}' = {value}")
            
            if debug:
                print(f"üìä Total fields found with prefix: {len(extracted_fields)}")
            return extracted_fields

        except Exception as e:
            print(f"‚ùå Error extracting fields by prefix '{prefix}': {e}")
            return extracted_fields
============================================================

============================================================
FILE: app\core\utils\helpers.py
============================================================
from typing import Optional, Dict, Any
from datetime import datetime
import pandas as pd
import json
import os

def extract_instance_code(event_data: Dict) -> Optional[str]:
    """Tr√≠ch xu·∫•t instance_code t·ª´ event"""
    try:
        event_body = event_data.get("event", {})
        if "instance_code" in event_body:
            return event_body["instance_code"]
            
        if "object" in event_body and "instance_code" in event_body["object"]:
            return event_body["object"]["instance_code"]
            
        return None
    except:
        return None

def get_event_type(event_data: Dict) -> str:
    """L·∫•y event type"""
    try:
        if "header" in event_data:
            return event_data["header"].get("event_type", "unknown")
        
        if "event" in event_data and "type" in event_data["event"]:
            return event_data["event"]["type"]
            
        return event_data.get("type", "unknown")
    except:
        return "unknown"

async def save_event_to_csv(event_data: Dict, events_file: str = "lark_events.csv"):
    """L∆∞u event v√†o CSV"""
    try:
        row_data = {
            "timestamp": datetime.now().isoformat(),
            "event_type": get_event_type(event_data),
            "instance_code": extract_instance_code(event_data),
            "raw_event": json.dumps(event_data, ensure_ascii=False)
        }
        
        df = pd.DataFrame([row_data])
        
        if os.path.exists(events_file):
            df.to_csv(events_file, mode='a', header=False, index=False, encoding='utf-8')
        else:
            df.to_csv(events_file, mode='w', header=True, index=False, encoding='utf-8')
            
        print(f"‚úÖ Event saved to {events_file}")
        
    except Exception as e:
        print(f"‚ùå Error saving event: {e}")

def format_currency(amount: float) -> str:
    """Format s·ªë ti·ªÅn theo ƒë·ªãnh d·∫°ng VND"""
    return f"{amount:,} VND"

def get_short_node_id(node_id: str, length: int = 8) -> str:
    """Get short version of node ID for display"""
    return node_id[:length] + "..." if len(node_id) > length else node_id

============================================================

============================================================
FILE: app\domains\__init__.py
============================================================
"""
Domain package exports
"""
from app.domains.qr_generation import *
from app.domains.validation import *
from app.domains.notification import *

__all__ = [
    # QR Generation Domain
    "QRRequest", "QRResponse", "QRType", 
    "qr_service", "qr_event_handler",
    
    # Validation Domain  
    "ValidationResult", "ValidationResponse", "ValidationType",
    "validation_service", "validation_event_handler",
    
    # Notification Domain
    "NotificationResult", "NotificationType", "NotificationChannel",
    "notification_coordinator", "lark_webhook_service"
]

============================================================

============================================================
FILE: app\domains\notification\__init__.py
============================================================
# app/domains/notification/__init__.py
from .models import *
from .services import *

__all__ = [
    # Models
    "NotificationType", "NotificationResult", "NotificationRequest",
    # Services
    "lark_webhook_service", "notification_coordinator"
]

============================================================

============================================================
FILE: app\domains\notification\models\__init__.py
============================================================
from .notification import (
    NotificationType,
    NotificationChannel,
    NotificationPriority,
    NotificationRequest,
    NotificationResult,
    ValidationAlertRequest,
    CustomAlertRequest
)

__all__ = [
    "NotificationType",
    "NotificationChannel",
    "NotificationPriority",
    "NotificationRequest", 
    "NotificationResult",
    "ValidationAlertRequest",
    "CustomAlertRequest"
]

============================================================

============================================================
FILE: app\domains\notification\models\notification.py
============================================================
from pydantic import BaseModel
from typing import Optional, List, Dict, Any
from enum import Enum

class NotificationType(str, Enum):
    VALIDATION_ALERT = "validation_alert"
    CUSTOM_ALERT = "custom_alert"
    SERVICE_ERROR = "service_error"
    SYSTEM_NOTIFICATION = "system_notification"

class NotificationChannel(str, Enum):
    LARK_WEBHOOK = "lark_webhook"
    EMAIL = "email"
    SMS = "sms"

class NotificationPriority(str, Enum):
    LOW = "low"
    NORMAL = "normal"
    HIGH = "high"
    URGENT = "urgent"

class NotificationRequest(BaseModel):
    notification_type: NotificationType
    channel: NotificationChannel
    title: str
    message: str
    instance_code: Optional[str] = None
    priority: NotificationPriority = NotificationPriority.NORMAL
    metadata: Optional[Dict[str, Any]] = None

class NotificationResult(BaseModel):
    success: bool
    notification_type: NotificationType
    channel: NotificationChannel
    instance_code: Optional[str] = None
    sent_at: Optional[str] = None
    cached: bool = False
    cache_hit: bool = False
    error: Optional[str] = None
    metadata: Optional[Dict[str, Any]] = None

class ValidationAlertRequest(BaseModel):
    instance_code: str
    serial_number: Optional[str] = None
    validation_errors: List[str]
    priority: NotificationPriority = NotificationPriority.HIGH

class CustomAlertRequest(BaseModel):
    title: str
    message: str
    instance_code: Optional[str] = None
    priority: NotificationPriority = NotificationPriority.NORMAL

============================================================

============================================================
FILE: app\domains\notification\services\__init__.py
============================================================
# app/domains/notification/services/__init__.py
from .lark_webhook_service import lark_webhook_service
from .notification_coordinator import notification_coordinator

__all__ = ["lark_webhook_service", "notification_coordinator"]

============================================================

============================================================
FILE: app\domains\notification\services\lark_webhook_service.py
============================================================
"""
Lark Webhook Service - D·ªãch v·ª• g·ª≠i th√¥ng b√°o qua Lark webhook
"""
import requests
import json
from typing import List
from datetime import datetime
from app.core.config.settings import settings
from app.domains.notification.models import (
    NotificationResult, NotificationType, NotificationChannel,
    ValidationAlertRequest, CustomAlertRequest
)


class LarkWebhookService:
    """
    D·ªãch v·ª• g·ª≠i th√¥ng b√°o qua Lark webhook.
    
    Class n√†y cung c·∫•p kh·∫£ nƒÉng g·ª≠i c√°c lo·∫°i th√¥ng b√°o kh√°c nhau ƒë·∫øn
    Lark (FeisHu) th√¥ng qua webhook API:
    
    - Validation alerts: C·∫£nh b√°o khi ph√°t hi·ªán l·ªói validation
    - Custom alerts: Th√¥ng b√°o t√πy ch·ªânh cho c√°c s·ª± ki·ªán ƒë·∫∑c bi·ªát
    
    Service n√†y h·ªó tr·ª£:
    - Format message theo chu·∫©n Lark webhook API
    - Error handling v√† retry logic
    - Tracking k·∫øt qu·∫£ g·ª≠i v·ªõi timestamp
    - Integration v·ªõi notification coordinator
    - Configuration-based enabling/disabling
    
    Attributes:
        webhook_url (str): URL webhook c·ªßa Lark t·ª´ settings
        channel (NotificationChannel): Channel type cho service n√†y
    """
    
    def __init__(self):
        """Kh·ªüi t·∫°o LarkWebhookService v·ªõi c·∫•u h√¨nh t·ª´ settings."""
        self.webhook_url = settings.LARK_WEBHOOK_URL
        self.channel = NotificationChannel.LARK_WEBHOOK
    
    async def send_validation_alert(self, request: ValidationAlertRequest) -> NotificationResult:
        """
        G·ª≠i c·∫£nh b√°o validation error qua Lark webhook.
        
        Method n√†y s·∫Ω format v√† g·ª≠i th√¥ng b√°o c·∫£nh b√°o khi h·ªá th·ªëng
        ph√°t hi·ªán l·ªói validation trong quy tr√¨nh ph√™ duy·ªát.
        
        Quy tr√¨nh x·ª≠ l√Ω:
        1. Ki·ªÉm tra c·∫•u h√¨nh c√≥ enable validation alerts kh√¥ng
        2. Validate webhook URL c√≥ ƒë∆∞·ª£c c·∫•u h√¨nh kh√¥ng
        3. Format message theo template c·∫£nh b√°o validation
        4. G·ª≠i HTTP POST request ƒë·∫øn Lark webhook
        5. Tr·∫£ v·ªÅ k·∫øt qu·∫£ v·ªõi th√¥ng tin chi ti·∫øt
        
        Args:
            request (ValidationAlertRequest): Request ch·ª©a th√¥ng tin validation alert
                - instance_code: M√£ instance c√≥ l·ªói validation
                - validation_errors: Danh s√°ch l·ªói validation
                - priority: M·ª©c ƒë·ªô ∆∞u ti√™n c·ªßa alert
        
        Returns:
            NotificationResult: K·∫øt qu·∫£ g·ª≠i th√¥ng b√°o bao g·ªìm:
                - success: Tr·∫°ng th√°i g·ª≠i th√†nh c√¥ng
                - notification_type: VALIDATION_ALERT
                - channel: LARK_WEBHOOK
                - instance_code: M√£ instance li√™n quan
                - sent_at: Th·ªùi gian g·ª≠i (n·∫øu th√†nh c√¥ng)
                - error: Th√¥ng b√°o l·ªói (n·∫øu th·∫•t b·∫°i)
                - metadata: Th√¥ng tin b·ªï sung (s·ªë l·ªói, priority)
        """
        try:
            # B∆∞·ªõc 1: Ki·ªÉm tra c·∫•u h√¨nh c√≥ enable validation alerts kh√¥ng
            if not settings.ENABLE_VALIDATION_ALERTS:
                print(f"‚ö†Ô∏è T√≠nh nƒÉng c·∫£nh b√°o validation ƒë√£ b·ªã t·∫Øt, b·ªè qua webhook cho {request.instance_code}")
                return NotificationResult(
                    success=True,  # Tr·∫£ v·ªÅ success v√¨ ƒë√£ x·ª≠ l√Ω (disabled)
                    notification_type=NotificationType.VALIDATION_ALERT,
                    channel=self.channel,
                    instance_code=request.instance_code,
                    cached=True,
                    metadata={"disabled": True, "reason": "ENABLE_VALIDATION_ALERTS = False"}
                )
            
            # B∆∞·ªõc 2: Ki·ªÉm tra webhook URL c√≥ ƒë∆∞·ª£c c·∫•u h√¨nh kh√¥ng
            if not self.webhook_url:
                print(f"‚ùå Ch∆∞a c·∫•u h√¨nh webhook URL cho Lark")
                return NotificationResult(
                    success=False,
                    notification_type=NotificationType.VALIDATION_ALERT,
                    channel=self.channel,
                    instance_code=request.instance_code,
                    error="Ch∆∞a c·∫•u h√¨nh webhook URL"
                )
            
            # B∆∞·ªõc 3: Format danh s√°ch l·ªói validation th√†nh text d·ªÖ ƒë·ªçc
            print(f"üìù ƒêang format {len(request.validation_errors)} l·ªói validation...")
            error_messages = "\n".join([f"‚Ä¢ {error}" for error in request.validation_errors])
            
            # T·∫°o message data theo format c·ªßa Lark webhook API
            message_data = {
                "msg_type": "text",
                "content": {
                    "text": f"""‚ö†Ô∏è C·∫¢NH B√ÅO D·ªÆ LI·ªÜU KH√îNG H·ª¢P L·ªÜ
üìÑ Request No.: {request.serial_number}
‚ùå C√°c l·ªói ph√°t hi·ªán:
{error_messages}

üîß Vui l√≤ng ki·ªÉm tra v√† x·ª≠ l√Ω."""
                }
            }
            
            # C·∫•u h√¨nh headers cho HTTP request
            headers = {"Content-Type": "application/json"}
            
            # B∆∞·ªõc 4: G·ª≠i HTTP POST request ƒë·∫øn Lark webhook
            print(f"üö® ƒêang g·ª≠i c·∫£nh b√°o validation qua webhook cho {request.instance_code}")
            response = requests.post(
                self.webhook_url, 
                headers=headers, 
                data=json.dumps(message_data),
                timeout=10  # Timeout 10 gi√¢y ƒë·ªÉ tr√°nh treo
            )
            
            # B∆∞·ªõc 5: X·ª≠ l√Ω response v√† t·∫°o k·∫øt qu·∫£
            success = response.status_code == 200
            sent_at = datetime.now().isoformat() if success else None
            
            if success:
                print(f"‚úÖ G·ª≠i c·∫£nh b√°o validation th√†nh c√¥ng cho {request.instance_code}")
            else:
                print(f"‚ùå G·ª≠i c·∫£nh b√°o validation th·∫•t b·∫°i: HTTP {response.status_code} - {response.text}")
            
            return NotificationResult(
                success=success,
                notification_type=NotificationType.VALIDATION_ALERT,
                channel=self.channel,
                instance_code=request.instance_code,
                sent_at=sent_at,
                error=None if success else f"HTTP {response.status_code}: {response.text}",
                metadata={
                    "errors_count": len(request.validation_errors),
                    "priority": request.priority.value,
                    "response_status": response.status_code
                }
            )
                
        except requests.exceptions.Timeout:
            print(f"‚è∞ Timeout khi g·ª≠i validation webhook (qu√° 10 gi√¢y)")
            return NotificationResult(
                success=False,
                notification_type=NotificationType.VALIDATION_ALERT,
                channel=self.channel,
                instance_code=request.instance_code,
                error="Timeout khi g·ª≠i webhook"
            )
        except requests.exceptions.ConnectionError:
            print(f"üîå L·ªói k·∫øt n·ªëi khi g·ª≠i validation webhook")
            return NotificationResult(
                success=False,
                notification_type=NotificationType.VALIDATION_ALERT,
                channel=self.channel,
                instance_code=request.instance_code,
                error="L·ªói k·∫øt n·ªëi webhook"
            )
        except Exception as e:
            print(f"‚ùå L·ªói kh√¥ng x√°c ƒë·ªãnh khi g·ª≠i validation webhook: {e}")
            return NotificationResult(
                success=False,
                notification_type=NotificationType.VALIDATION_ALERT,
                channel=self.channel,
                instance_code=request.instance_code,
                error=str(e)
            )

    async def send_custom_alert(self, request: CustomAlertRequest) -> NotificationResult:
        """
        G·ª≠i th√¥ng b√°o t√πy ch·ªânh qua Lark webhook.
        
        Method n√†y cho ph√©p g·ª≠i c√°c th√¥ng b√°o t√πy ch·ªânh v·ªõi title v√† message
        do ng∆∞·ªùi d√πng ƒë·ªãnh nghƒ©a, ph√π h·ª£p cho c√°c s·ª± ki·ªán ƒë·∫∑c bi·ªát ho·∫∑c
        th√¥ng b√°o h·ªá th·ªëng.
        
        Args:
            request (CustomAlertRequest): Request ch·ª©a th√¥ng tin custom alert
                - title: Ti√™u ƒë·ªÅ th√¥ng b√°o
                - message: N·ªôi dung th√¥ng b√°o
                - instance_code: M√£ instance li√™n quan (optional)
                - priority: M·ª©c ƒë·ªô ∆∞u ti√™n
        
        Returns:
            NotificationResult: K·∫øt qu·∫£ g·ª≠i th√¥ng b√°o t∆∞∆°ng t·ª± send_validation_alert
        """
        try:
            # B∆∞·ªõc 1: Ki·ªÉm tra c·∫•u h√¨nh v√† webhook URL
            if not settings.ENABLE_VALIDATION_ALERTS or not self.webhook_url:
                print(f"‚ùå Alerts b·ªã t·∫Øt ho·∫∑c ch∆∞a c·∫•u h√¨nh webhook URL")
                return NotificationResult(
                    success=False,
                    notification_type=NotificationType.CUSTOM_ALERT,
                    channel=self.channel,
                    instance_code=request.instance_code,
                    error="Alerts b·ªã t·∫Øt ho·∫∑c ch∆∞a c·∫•u h√¨nh webhook URL"
                )
            
            # B∆∞·ªõc 2: Format message v·ªõi title v√† n·ªôi dung t√πy ch·ªânh
            print(f"üìù ƒêang t·∫°o custom alert: {request.title}")
            alert_text = f"""üîî {request.title}"""
            
            # Th√™m instance code n·∫øu c√≥
            if request.instance_code:
                alert_text += f"\nüìÑ Instance: {request.instance_code}"
                
            alert_text += f"\nüì¢ {request.message}"
            
            # T·∫°o message data cho Lark webhook
            message_data = {
                "msg_type": "text",
                "content": {"text": alert_text}
            }
            
            # B∆∞·ªõc 3: G·ª≠i HTTP request
            print(f"üì§ ƒêang g·ª≠i custom alert qua webhook...")
            headers = {"Content-Type": "application/json"}
            response = requests.post(
                self.webhook_url, 
                headers=headers, 
                data=json.dumps(message_data),
                timeout=10
            )
            
            # B∆∞·ªõc 4: X·ª≠ l√Ω k·∫øt qu·∫£
            success = response.status_code == 200
            sent_at = datetime.now().isoformat() if success else None
            
            if success:
                print(f"‚úÖ G·ª≠i custom alert th√†nh c√¥ng: {request.title}")
            else:
                print(f"‚ùå G·ª≠i custom alert th·∫•t b·∫°i: HTTP {response.status_code} - {response.text}")
            
            return NotificationResult(
                success=success,
                notification_type=NotificationType.CUSTOM_ALERT,
                channel=self.channel,
                instance_code=request.instance_code,
                sent_at=sent_at,
                error=None if success else f"HTTP {response.status_code}: {response.text}",
                metadata={
                    "title": request.title,
                    "priority": request.priority.value,
                    "has_instance_code": request.instance_code is not None,
                    "response_status": response.status_code
                }
            )
            
        except requests.exceptions.Timeout:
            print(f"‚è∞ Timeout khi g·ª≠i custom alert webhook")
            return NotificationResult(
                success=False,
                notification_type=NotificationType.CUSTOM_ALERT,
                channel=self.channel,
                instance_code=request.instance_code,
                error="Timeout khi g·ª≠i webhook"
            )
        except requests.exceptions.ConnectionError:
            print(f"üîå L·ªói k·∫øt n·ªëi khi g·ª≠i custom alert webhook")
            return NotificationResult(
                success=False,
                notification_type=NotificationType.CUSTOM_ALERT,
                channel=self.channel,
                instance_code=request.instance_code,
                error="L·ªói k·∫øt n·ªëi webhook"
            )
        except Exception as e:
            print(f"‚ùå L·ªói khi g·ª≠i custom alert: {e}")
            return NotificationResult(
                success=False,
                notification_type=NotificationType.CUSTOM_ALERT,
                channel=self.channel,
                instance_code=request.instance_code,
                error=str(e)
            )


lark_webhook_service = LarkWebhookService()
============================================================

============================================================
FILE: app\domains\notification\services\notification_coordinator.py
============================================================
"""
Notification Coordinator - B·ªô ƒëi·ªÅu ph·ªëi trung t√¢m cho t·∫•t c·∫£ k√™nh th√¥ng b√°o
"""
from typing import List, Dict, Any
from app.domains.notification.models import (
    NotificationRequest, NotificationResult, NotificationType, 
    NotificationChannel, ValidationAlertRequest, CustomAlertRequest
)
from app.domains.notification.services.lark_webhook_service import lark_webhook_service
from app.core.infrastructure.cache_service import cache_service


class NotificationCoordinator:
    """
    B·ªô ƒëi·ªÅu ph·ªëi trung t√¢m cho t·∫•t c·∫£ c√°c k√™nh th√¥ng b√°o.
    
    Class n√†y ho·∫°t ƒë·ªông nh∆∞ m·ªôt central hub ƒë·ªÉ:
    1. Qu·∫£n l√Ω v√† ƒëi·ªÅu ph·ªëi c√°c k√™nh th√¥ng b√°o kh√°c nhau (Lark, Email, SMS, etc.)
    2. NgƒÉn ch·∫∑n duplicate notifications th√¥ng qua caching mechanism
    3. Route notifications ƒë·∫øn ƒë√∫ng service d·ª±a tr√™n channel v√† type
    4. Cung c·∫•p interface th·ªëng nh·∫•t cho vi·ªác g·ª≠i th√¥ng b√°o
    5. Track v√† log k·∫øt qu·∫£ g·ª≠i th√¥ng b√°o
    
    Supported channels:
    - LARK_WEBHOOK: G·ª≠i th√¥ng b√°o qua Lark webhook
    - C√≥ th·ªÉ m·ªü r·ªông th√™m EMAIL, SMS, SLACK, etc.
    
    Supported notification types:
    - VALIDATION_ALERT: C·∫£nh b√°o validation errors
    - CUSTOM_ALERT: C·∫£nh b√°o t√πy ch·ªânh
    - QR_GENERATION: Th√¥ng b√°o t·∫°o QR (t∆∞∆°ng lai)
    
    Attributes:
        channels (Dict): Map t·ª´ notification channel ƒë·∫øn service implementation
    """
    
    def __init__(self):
        """Kh·ªüi t·∫°o NotificationCoordinator v·ªõi c√°c k√™nh th√¥ng b√°o ƒë∆∞·ª£c h·ªó tr·ª£."""
        # Mapping t·ª´ notification channel ƒë·∫øn service implementation
        # D·ªÖ d√†ng m·ªü r·ªông th√™m channels m·ªõi trong t∆∞∆°ng lai
        self.channels = {
            NotificationChannel.LARK_WEBHOOK: lark_webhook_service
            # C√≥ th·ªÉ th√™m:
            # NotificationChannel.EMAIL: email_service,
            # NotificationChannel.SMS: sms_service,
            # NotificationChannel.SLACK: slack_service,
        }
    
    async def send_notification(self, request: NotificationRequest) -> NotificationResult:
        """
        G·ª≠i th√¥ng b√°o qua k√™nh ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh v·ªõi t√≠nh nƒÉng ch·ªëng tr√πng l·∫∑p.
        
        ƒê√¢y l√† method ch√≠nh c·ªßa coordinator, th·ª±c hi·ªán:
        1. Ki·ªÉm tra duplicate notifications d·ª±a tr√™n cache
        2. Validate v√† route ƒë·∫øn ƒë√∫ng channel service  
        3. G·ªçi method ph√π h·ª£p d·ª±a tr√™n notification type
        4. Cache k·∫øt qu·∫£ ƒë·ªÉ tr√°nh duplicate trong t∆∞∆°ng lai
        5. Tr·∫£ v·ªÅ k·∫øt qu·∫£ chi ti·∫øt cho monitoring
        
        Args:
            request (NotificationRequest): Request ch·ª©a th√¥ng tin notification c·∫ßn g·ª≠i
            
        Returns:
            NotificationResult: K·∫øt qu·∫£ g·ª≠i th√¥ng b√°o bao g·ªìm:
                - success (bool): Tr·∫°ng th√°i g·ª≠i th√†nh c√¥ng
                - notification_type: Lo·∫°i th√¥ng b√°o
                - channel: K√™nh ƒë√£ s·ª≠ d·ª•ng
                - instance_code: M√£ instance li√™n quan
                - cached (bool): C√≥ ƒë∆∞·ª£c cache kh√¥ng
                - cache_hit (bool): C√≥ b·ªã skip do cache kh√¥ng
                - error (str): Th√¥ng b√°o l·ªói n·∫øu c√≥
                - metadata (Dict): Th√¥ng tin b·ªï sung
        """
        
        # B∆∞·ªõc 1: Ki·ªÉm tra duplicate notifications d·ª±a tr√™n cache
        if request.instance_code:
            # T·∫°o cache key duy nh·∫•t cho combination c·ªßa type v√† instance
            cache_key = f"{request.notification_type.value}_{request.instance_code}"
            
            print(f"üîç Ki·ªÉm tra duplicate notification cho: {cache_key}")
            
            # Ki·ªÉm tra xem ƒë√£ g·ª≠i notification t∆∞∆°ng t·ª± g·∫ßn ƒë√¢y ch∆∞a
            if cache_service.is_validation_alert_recently_sent(
                request.instance_code, 
                request.notification_type.value,
                cache_duration_minutes=10
            ):
                print(f"üîÑ PH√ÅT HI·ªÜN TH√îNG B√ÅO TR√ôNG L·∫∂P: {cache_key}")
                print(f"   ‚Üí B·ªé QUA g·ª≠i th√¥ng b√°o ƒë·ªÉ tr√°nh spam")
                
                return NotificationResult(
                    success=True,  # Tr·∫£ v·ªÅ success v√¨ ƒë√£ x·ª≠ l√Ω (cached)
                    notification_type=request.notification_type,
                    channel=request.channel,
                    instance_code=request.instance_code,
                    cached=True,
                    cache_hit=True,
                    metadata={
                        "reason": "duplicate_prevention",
                        "cache_key": cache_key,
                        "cache_duration_minutes": 10
                    }
                )
        
        # B∆∞·ªõc 2: Validate v√† l·∫•y channel service
        print(f"üì° ƒêang ƒë·ªãnh tuy·∫øn ƒë·∫øn k√™nh: {request.channel.value}")
        channel_service = self.channels.get(request.channel)
        
        if not channel_service:
            print(f"‚ùå K√™nh kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£: {request.channel.value}")
            return NotificationResult(
                success=False,
                notification_type=request.notification_type,
                channel=request.channel,
                instance_code=request.instance_code,
                error=f"K√™nh kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£: {request.channel.value}",
                metadata={
                    "available_channels": list(self.channels.keys())
                }
            )
        
        # B∆∞·ªõc 3: Route ƒë·∫øn method ph√π h·ª£p d·ª±a tr√™n notification type
        print(f"üéØ X·ª≠ l√Ω lo·∫°i th√¥ng b√°o: {request.notification_type.value}")
        
        if request.notification_type == NotificationType.VALIDATION_ALERT:
            # X·ª≠ l√Ω validation alert
            print(f"üîî T·∫°o validation alert request...")
            alert_request = ValidationAlertRequest(
                instance_code=request.instance_code,
                validation_errors=[request.message],
                priority=request.priority
            )
            
            print(f"üì§ ƒêang g·ª≠i validation alert qua {request.channel.value}...")
            result = await channel_service.send_validation_alert(alert_request)
        
        elif request.notification_type == NotificationType.CUSTOM_ALERT:
            # X·ª≠ l√Ω custom alert
            print(f"üé® T·∫°o custom alert request...")
            alert_request = CustomAlertRequest(
                title=request.title,
                message=request.message,
                instance_code=request.instance_code,
                priority=request.priority
            )
            
            print(f"üì§ ƒêang g·ª≠i custom alert qua {request.channel.value}...")
            result = await channel_service.send_custom_alert(alert_request)
        
        else:
            # Notification type kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£
            print(f"‚ùå Lo·∫°i th√¥ng b√°o kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£: {request.notification_type.value}")
            return NotificationResult(
                success=False,
                notification_type=request.notification_type,
                channel=request.channel,
                instance_code=request.instance_code,
                error=f"Lo·∫°i th√¥ng b√°o kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£: {request.notification_type.value}",
                metadata={
                    "available_types": [nt.value for nt in NotificationType]
                }
            )
        
        # B∆∞·ªõc 4: X·ª≠ l√Ω k·∫øt qu·∫£ v√† cache n·∫øu th√†nh c√¥ng
        if result.success and request.instance_code:
            print(f"‚úÖ G·ª≠i th√¥ng b√°o th√†nh c√¥ng - ƒë√°nh d·∫•u cache")
            
            # ƒê√°nh d·∫•u ƒë√£ g·ª≠i trong cache ƒë·ªÉ tr√°nh duplicate
            cache_service.mark_validation_alert_as_sent(
                request.instance_code, 
                request.notification_type.value
            )
            
            print(f"üíæ ƒê√£ l∆∞u v√†o cache ƒë·ªÉ tr√°nh duplicate trong 10 ph√∫t")
        elif result.success:
            print(f"‚úÖ G·ª≠i th√¥ng b√°o th√†nh c√¥ng (kh√¥ng c√≥ instance_code ƒë·ªÉ cache)")
        else:
            print(f"‚ùå G·ª≠i th√¥ng b√°o th·∫•t b·∫°i: {getattr(result, 'error', 'L·ªói kh√¥ng x√°c ƒë·ªãnh')}")
        
        return result


# Instance to√†n c·ª•c c·ªßa coordinator ƒë·ªÉ s·ª≠ d·ª•ng trong to√†n b·ªô h·ªá th·ªëng
notification_coordinator = NotificationCoordinator()
============================================================

============================================================
FILE: app\domains\qr_generation\__init__.py
============================================================
from .models import *
from .services import *
from .handlers import *

__all__ = [
    # Models
    "QRType", "BankInfo", "QRGenerationResult",
    # Services  
    "vietqr_service", "qr_processor",
    # Handlers
    "qr_event_handler"
]

============================================================

============================================================
FILE: app\domains\qr_generation\handlers\__init__.py
============================================================
from .qr_event_handler import qr_event_handler

__all__ = ["qr_event_handler"]

============================================================

============================================================
FILE: app\domains\qr_generation\handlers\qr_event_handler.py
============================================================
from typing import Dict
from app.core.infrastructure.lark_service import lark_service
from app.domains.qr_generation.services.qr_processor import qr_processor

class QREventHandler:
    """
    B·ªô x·ª≠ l√Ω s·ª± ki·ªán t·∫°o m√£ QR cho h·ªá th·ªëng ph√™ duy·ªát Lark.
    
    Class n√†y ho·∫°t ƒë·ªông nh∆∞ m·ªôt event handler ƒë·ªôc l·∫≠p, nh·∫≠n v√† x·ª≠ l√Ω
    c√°c s·ª± ki·ªán ph√™ duy·ªát ƒë·ªÉ t·ª± ƒë·ªông t·∫°o m√£ VietQR t∆∞∆°ng ·ª©ng.
    
    Quy tr√¨nh x·ª≠ l√Ω:
    1. Nh·∫≠n s·ª± ki·ªán ph√™ duy·ªát t·ª´ h·ªá th·ªëng
    2. Tr√≠ch xu·∫•t instance_code t·ª´ event data
    3. L·∫•y access token ƒë·ªÉ g·ªçi Lark API
    4. G·ª≠i ƒë·∫øn QRProcessor ƒë·ªÉ x·ª≠ l√Ω t·∫°o QR
    5. Tr·∫£ v·ªÅ k·∫øt qu·∫£ x·ª≠ l√Ω
    
    Attributes:
        name (str): T√™n ƒë·ªãnh danh c·ªßa service ("QR_Generator")
    """
    
    def __init__(self):
        """Kh·ªüi t·∫°o QREventHandler v·ªõi t√™n service."""
        self.name = "QR_Generator"
    
    async def handle_approval_event(self, event_data: Dict) -> Dict:
        """
        X·ª≠ l√Ω s·ª± ki·ªán ph√™ duy·ªát ƒë·ªÉ t·∫°o m√£ QR t·ª± ƒë·ªông.
        
        [N√ÇNG C·∫§P] B·ªï sung logic ki·ªÉm tra tr·∫°ng th√°i ƒë∆°n. S·∫Ω b·ªè qua x·ª≠ l√Ω
        n·∫øu ƒë∆°n ·ªü tr·∫°ng th√°i cu·ªëi c√πng nh∆∞ REJECTED, CANCELED, DELETED.
        
        ƒê√¢y l√† method ch√≠nh c·ªßa handler, ho·∫°t ƒë·ªông ho√†n to√†n ƒë·ªôc l·∫≠p
        v√† kh√¥ng ph·ª• thu·ªôc v√†o c√°c service kh√°c. Method s·∫Ω:
        
        1. Validate d·ªØ li·ªáu ƒë·∫ßu v√†o (instance_code)
        2. L·∫•y access token t·ª´ Lark service
        3. G·ªçi QRProcessor ƒë·ªÉ x·ª≠ l√Ω business logic
        4. Tr·∫£ v·ªÅ k·∫øt qu·∫£ chi ti·∫øt cho monitoring
        
        Args:
            event_data (Dict): D·ªØ li·ªáu s·ª± ki·ªán ch·ª©a th√¥ng tin ph√™ duy·ªát.
                             B·∫Øt bu·ªôc ph·∫£i c√≥ 'instance_code'
        
        Returns:
            Dict: K·∫øt qu·∫£ x·ª≠ l√Ω bao g·ªìm:
                - success (bool): Tr·∫°ng th√°i x·ª≠ l√Ω th√†nh c√¥ng
                - message (str): Th√¥ng b√°o chi ti·∫øt k·∫øt qu·∫£
                - instance_code (str): M√£ instance ƒë√£ x·ª≠ l√Ω (n·∫øu c√≥)
                - service (str): T√™n service th·ª±c hi·ªán
        
        Raises:
            Exception: C√°c l·ªói kh√¥ng x√°c ƒë·ªãnh s·∫Ω ƒë∆∞·ª£c b·∫Øt v√† tr·∫£ v·ªÅ trong response
        """
        try:
            # B∆∞·ªõc 1: Validate v√† tr√≠ch xu·∫•t instance_code t·ª´ event data
            instance_code = event_data.get('instance_code')
            if not instance_code:
                print(f"‚ùå [QR Handler] Thi·∫øu instance_code trong d·ªØ li·ªáu s·ª± ki·ªán")
                return {
                    "success": False,
                    "message": "Kh√¥ng t√¨m th·∫•y instance_code trong d·ªØ li·ªáu s·ª± ki·ªán", 
                    "service": self.name
                }
            
            # [TH√äM M·ªöI] B·∫Øt ƒë·∫ßu kh·ªëi logic ki·ªÉm tra tr·∫°ng th√°i
            FINAL_STATUSES = ['REJECTED', 'CANCELED', 'DELETED']

            # Tr√≠ch xu·∫•t tr·∫°ng th√°i t·ª´ d·ªØ li·ªáu g·ªëc c·ªßa s·ª± ki·ªán ƒë·ªÉ tr√°nh g·ªçi API kh√¥ng c·∫ßn thi·∫øt
            raw_data = event_data.get('raw_data', {})
            instance_status = raw_data.get('event', {}).get('object', {}).get('status')
            
            # Ki·ªÉm tra xem tr·∫°ng th√°i c·ªßa ƒë∆°n c√≥ n·∫±m trong danh s√°ch c·∫ßn b·ªè qua kh√¥ng
            if instance_status and instance_status in FINAL_STATUSES:
                print(f"‚è≠Ô∏è [QR Handler] B·ªè qua instance {instance_code} do c√≥ tr·∫°ng th√°i cu·ªëi c√πng: {instance_status}")
                return {
                    "success": True, # Coi nh∆∞ th√†nh c√¥ng v√¨ ƒë√£ x·ª≠ l√Ω ƒë√∫ng (b·ªè qua)
                    "message": f"B·ªè qua x·ª≠ l√Ω do tr·∫°ng th√°i ƒë∆°n l√† {instance_status}",
                    "instance_code": instance_code,
                    "service": self.name
                }
            # [TH√äM M·ªöI] K·∫øt th√∫c kh·ªëi logic ki·ªÉm tra tr·∫°ng th√°i
            
            print(f"üè¶ [QR Handler] D·ªãch v·ª• QR ƒëang x·ª≠ l√Ω instance: {instance_code} (Tr·∫°ng th√°i: {instance_status or 'N/A'})")
            
            # B∆∞·ªõc 2: L·∫•y access token ƒë·ªÉ g·ªçi Lark API
            print(f"üîë ƒêang l·∫•y access token t·ª´ Lark...")
            access_token = await lark_service.get_access_token()
            if not access_token:
                print(f"‚ùå Kh√¥ng th·ªÉ l·∫•y access token t·ª´ Lark")
                return {
                    "success": False,
                    "message": "Kh√¥ng th·ªÉ l·∫•y access token t·ª´ Lark",
                    "service": self.name
                }
            
            print(f"‚úÖ ƒê√£ l·∫•y access token th√†nh c√¥ng")
            
            # B∆∞·ªõc 3: G·ª≠i ƒë·∫øn QRProcessor ƒë·ªÉ x·ª≠ l√Ω business logic ch√≠nh
            print(f"‚öôÔ∏è B·∫Øt ƒë·∫ßu x·ª≠ l√Ω t·∫°o QR cho {instance_code}...")
            result = await qr_processor.process_approval_with_qr_comment(
                instance_code, access_token
            )
            
            # B∆∞·ªõc 4: T·∫°o response v·ªõi th√¥ng tin chi ti·∫øt
            if result:
                print(f"‚úÖ [QR Handler] Ho√†n th√†nh x·ª≠ l√Ω QR cho {instance_code}")
                return {
                    "success": True,
                    "message": f"X·ª≠ l√Ω QR ho√†n th√†nh th√†nh c√¥ng cho {instance_code}",
                    "instance_code": instance_code,
                    "service": self.name
                }
            else:
                print(f"‚ùå [QR Handler] X·ª≠ l√Ω QR th·∫•t b·∫°i cho {instance_code}")
                return {
                    "success": False,
                    "message": f"X·ª≠ l√Ω QR th·∫•t b·∫°i cho {instance_code}",
                    "instance_code": instance_code,
                    "service": self.name
                }
            
        except Exception as e:
            # B·∫Øt t·∫•t c·∫£ exception kh√¥ng x√°c ƒë·ªãnh ƒë·ªÉ tr√°nh crash service
            print(f"‚ùå L·ªói kh√¥ng x√°c ƒë·ªãnh trong QR Service: {str(e)}")
            import traceback
            print(f"üìã Chi ti·∫øt l·ªói:\n{traceback.format_exc()}")
            
            return {
                "success": False,
                "message": f"L·ªói QR Service: {str(e)}",
                "service": self.name,
                "error_type": type(e).__name__
            }

qr_event_handler = QREventHandler()
============================================================

============================================================
FILE: app\domains\qr_generation\models\__init__.py
============================================================
from .qr import (
    QRType,
    BankInfo,
    AmountDetectionResult,
    QRTypeResult,
    NodeProcessingResult,
    QRGenerationRequest,
    QRGenerationResult
)

__all__ = [
    "QRType",
    "BankInfo", 
    "AmountDetectionResult",
    "QRTypeResult",
    "NodeProcessingResult",
    "QRGenerationRequest",
    "QRGenerationResult"
]

============================================================

============================================================
FILE: app\domains\qr_generation\models\qr.py
============================================================
from pydantic import BaseModel
from typing import Optional, Dict, Any
from enum import Enum

class QRType(str, Enum):
    ADVANCE = "advance"
    PAYMENT = "payment"
    NONE = "none"

class BankInfo(BaseModel):
    bank_id: str
    account_no: str
    account_name: str

class AmountDetectionResult(BaseModel):
    advance_amount: Optional[float] = None
    payment_amount: Optional[float] = None
    advance_field_found: bool = False
    payment_field_found: bool = False
    all_amount_fields: Dict[str, Any] = {}
    fields_used: Dict[str, Optional[str]] = {}

class QRTypeResult(BaseModel):
    qr_type: QRType
    amount: Optional[float] = None
    field_used: Optional[str] = None
    reason: str

class NodeProcessingResult(BaseModel):
    success: bool
    qr_type: QRType = QRType.NONE
    amount: Optional[float] = None
    field_used: Optional[str] = None
    node_strategy: Optional[str] = None
    reason: Optional[str] = None
    error: Optional[str] = None
    field_detection: Optional[AmountDetectionResult] = None

class QRGenerationRequest(BaseModel):
    instance_code: str
    node_id: str
    qr_type: QRType
    amount: int
    bank_info: BankInfo
    description: str

class QRGenerationResult(BaseModel):
    success: bool
    qr_type: Optional[QRType] = None
    amount: Optional[float] = None
    field_used: Optional[str] = None
    node_name: Optional[str] = None
    comment_id: Optional[str] = None
    error: Optional[str] = None
    processing_info: Optional[Dict[str, Any]] = None

============================================================

============================================================
FILE: app\domains\qr_generation\routers\qr.py
============================================================
from fastapi import APIRouter, Depends
from app.domains.qr_generation.models import QRGenerationResult
from app.domains.qr_generation.services.qr_processor import qr_processor
from app.core.infrastructure.lark_service import lark_service

router = APIRouter(prefix="/qr", tags=["QR Generation"])

@router.post("/process/{instance_code}", response_model=QRGenerationResult)
async def manual_process_qr(instance_code: str):
    """Enhanced manual QR processing v·ªõi domain models"""
    try:
        access_token = await lark_service.get_access_token()
        if not access_token:
            return QRGenerationResult(
                success=False,
                error="Cannot get access token"
            )
        
        # Process the instance
        result = await qr_processor.process_approval_with_qr_comment(instance_code, access_token)
        
        return QRGenerationResult(
            success=result,
            processing_info={
                "instance_code": instance_code,
                "processed": result
            }
        )
            
    except Exception as e:
        return QRGenerationResult(
            success=False,
            error=str(e)
        )

@router.get("/cache/status")
async def get_qr_cache_status():
    """Xem tr·∫°ng th√°i QR cache"""
    from app.core.infrastructure.cache_service import cache_service
    cache_status = cache_service.get_cache_status()
    return cache_status.get('qr_cache', {})

@router.post("/cache/clear")
async def clear_qr_cache():
    """Clear QR cache"""
    from app.core.infrastructure.cache_service import cache_service
    result = cache_service.clear_cache()
    return {
        "message": "QR cache cleared",
        "details": result
    }

============================================================

============================================================
FILE: app\domains\qr_generation\services\__init__.py
============================================================
from .vietqr_service import vietqr_service
from .amount_detector import AmountDetector
from .qr_processor import qr_processor

__all__ = [
    "vietqr_service",
    "AmountDetector", 
    "qr_processor"
]

============================================================

============================================================
FILE: app\domains\qr_generation\services\amount_detector.py
============================================================
from typing import Dict, List, Optional
from app.core.config.node_config import get_node_config
from app.core.config.field_constants import FFN
from app.core.utils.field_extractor import FieldExtractor
from app.domains.qr_generation.models import AmountDetectionResult, QRTypeResult, QRType


class AmountDetector:
    """
    B·ªô ph√°t hi·ªán v√† x√°c ƒë·ªãnh s·ªë ti·ªÅn cho vi·ªác t·∫°o m√£ QR.

    Class n√†y ch·ªãu tr√°ch nhi·ªám ph√¢n t√≠ch d·ªØ li·ªáu form ƒë·ªÉ:
    - T√¨m ki·∫øm c√°c tr∆∞·ªùng ch·ª©a th√¥ng tin s·ªë ti·ªÅn
    - X√°c ƒë·ªãnh lo·∫°i QR (t·∫°m ·ª©ng ho·∫∑c thanh to√°n) d·ª±a tr√™n node strategy
    - Validate v√† tr·∫£ v·ªÅ s·ªë ti·ªÅn ph√π h·ª£p cho t·ª´ng node

    H·ªó tr·ª£ nhi·ªÅu chi·∫øn l∆∞·ª£c x·ª≠ l√Ω kh√°c nhau:
    - detect_both_fields: Ph√°t hi·ªán c·∫£ t·∫°m ·ª©ng v√† thanh to√°n
    - payment_field_only: Ch·ªâ x·ª≠ l√Ω tr∆∞·ªùng thanh to√°n

    Attributes:
        field_extractor (FieldExtractor): C√¥ng c·ª• tr√≠ch xu·∫•t d·ªØ li·ªáu t·ª´ form
    """

    def __init__(self):
        """Kh·ªüi t·∫°o AmountDetector v·ªõi FieldExtractor."""
        self.field_extractor = FieldExtractor()

    def detect_available_amount_fields(self, form_data: List[Dict], node_config: Dict = None) -> Dict:
        """
        Qu√©t d·ªØ li·ªáu form ƒë·ªÉ t√¨m c√°c tr∆∞·ªùng s·ªë ti·ªÅn theo c·∫•u h√¨nh node.
        
        Ph∆∞∆°ng th·ª©c n√†y s·∫Ω t√¨m ki·∫øm c√°c tr∆∞·ªùng t·∫°m ·ª©ng v√† thanh to√°n d·ª±a tr√™n
        c·∫•u h√¨nh c·ªßa node. N·∫øu kh√¥ng c√≥ c·∫•u h√¨nh, s·∫Ω s·ª≠ d·ª•ng t√™n tr∆∞·ªùng m·∫∑c ƒë·ªãnh.
        
        Args:
            form_data (List[Dict]): D·ªØ li·ªáu form t·ª´ API response c·ªßa Lark
            node_config (Dict, optional): C·∫•u h√¨nh node ch·ª©a t√™n c√°c tr∆∞·ªùng c·∫ßn t√¨m
            
        Returns:
            Dict: K·∫øt qu·∫£ ph√°t hi·ªán bao g·ªìm:
                - advance_amount: Gi√° tr·ªã s·ªë ti·ªÅn t·∫°m ·ª©ng
                - payment_amount: Gi√° tr·ªã s·ªë ti·ªÅn thanh to√°n  
                - advance_field_found: C√≥ t√¨m th·∫•y tr∆∞·ªùng t·∫°m ·ª©ng kh√¥ng
                - payment_field_found: C√≥ t√¨m th·∫•y tr∆∞·ªùng thanh to√°n kh√¥ng
                - all_amount_fields: T·∫•t c·∫£ tr∆∞·ªùng ch·ª©a t·ª´ kh√≥a ti·ªÅn
                - fields_used: T√™n c√°c tr∆∞·ªùng ƒë√£ s·ª≠ d·ª•ng ƒë·ªÉ t√¨m ki·∫øm
        """
        try:
            # L·∫•y t√™n tr∆∞·ªùng t·ª´ c·∫•u h√¨nh node ho·∫∑c s·ª≠ d·ª•ng gi√° tr·ªã m·∫∑c ƒë·ªãnh
            if node_config:
                advance_field = node_config.get('advance_field')
                payment_field = node_config.get('payment_field')
            else:
                # Gi√° tr·ªã m·∫∑c ƒë·ªãnh ƒë·ªÉ t∆∞∆°ng th√≠ch ng∆∞·ª£c
                advance_field = FFN.ADVANCE_AMOUNT
                payment_field = FFN.PAYMENT_AMOUNT
            
            # Tr√≠ch xu·∫•t gi√° tr·ªã t·ª´ c·∫£ 2 tr∆∞·ªùng (ch·ªâ khi t√™n tr∆∞·ªùng kh√¥ng ph·∫£i None)
            advance_value = None
            payment_value = None
            
            if advance_field:
                advance_value = self.field_extractor.extract_field_value(form_data, advance_field)
            
            if payment_field:
                payment_value = self.field_extractor.extract_field_value(form_data, payment_field)
            
            # Debug: T√¨m t·∫•t c·∫£ tr∆∞·ªùng c√≥ ch·ª©a t·ª´ kh√≥a "ti·ªÅn" ho·∫∑c "amount"
            all_amount_fields = self.field_extractor.get_amount_fields(form_data)
            
            # T·∫°o k·∫øt qu·∫£ chi ti·∫øt
            result = {
                'advance_amount': advance_value,
                'payment_amount': payment_value,
                'advance_field_found': advance_value is not None,
                'payment_field_found': payment_value is not None,
                'all_amount_fields': all_amount_fields,
                'fields_used': {
                    'advance_field': advance_field,
                    'payment_field': payment_field
                }
            }
            
            # Hi·ªÉn th·ªã k·∫øt qu·∫£ ph√°t hi·ªán tr∆∞·ªùng
            print(f"üí∞ K·∫øt qu·∫£ ph√°t hi·ªán tr∆∞·ªùng s·ªë ti·ªÅn:")
            if advance_field:
                status = f"‚úÖ {advance_value}" if advance_value else "‚ùå Kh√¥ng t√¨m th·∫•y"
                print(f"   - {advance_field}: {status}")
            else:
                print(f"   - Tr∆∞·ªùng t·∫°m ·ª©ng: ‚ùå Ch∆∞a ƒë∆∞·ª£c c·∫•u h√¨nh")
                
            if payment_field:
                status = f"‚úÖ {payment_value}" if payment_value else "‚ùå Kh√¥ng t√¨m th·∫•y"
                print(f"   - {payment_field}: {status}")
            else:
                print(f"   - Tr∆∞·ªùng thanh to√°n: ‚ùå Ch∆∞a ƒë∆∞·ª£c c·∫•u h√¨nh")
                
            print(f"   - T·∫•t c·∫£ tr∆∞·ªùng s·ªë ti·ªÅn: {list(all_amount_fields.keys())}")
            
            return result
            
        except Exception as e:
            print(f"‚ùå L·ªói khi ph√°t hi·ªán tr∆∞·ªùng s·ªë ti·ªÅn: {e}")
            return {
                'advance_amount': None,
                'payment_amount': None,
                'advance_field_found': False,
                'payment_field_found': False,
                'all_amount_fields': {},
                'fields_used': {'advance_field': None, 'payment_field': None},
                'error': str(e)
            }

    def determine_qr_type_by_fields(self, field_detection_result: Dict) -> Dict:
        """
        X√°c ƒë·ªãnh lo·∫°i QR d·ª±a tr√™n c√°c tr∆∞·ªùng c√≥ gi√° tr·ªã h·ª£p l·ªá.
        
        Logic ∆∞u ti√™n: T·∫°m ·ª©ng ƒë∆∞·ª£c ∆∞u ti√™n tr∆∞·ªõc, sau ƒë√≥ ƒë·∫øn thanh to√°n.
        Ch·ªâ ch·ªçn tr∆∞·ªùng c√≥ gi√° tr·ªã s·ªë h·ª£p l·ªá v√† l·ªõn h∆°n 0.
        
        Args:
            field_detection_result (Dict): K·∫øt qu·∫£ t·ª´ detect_available_amount_fields()
            
        Returns:
            Dict: K·∫øt qu·∫£ quy·∫øt ƒë·ªãnh lo·∫°i QR bao g·ªìm:
                - qr_type: Lo·∫°i QR ('advance', 'payment', ho·∫∑c 'none')
                - amount: S·ªë ti·ªÅn ƒë√£ ch·ªçn
                - field_used: T√™n tr∆∞·ªùng ƒë√£ s·ª≠ d·ª•ng
                - reason: L√Ω do quy·∫øt ƒë·ªãnh
        """
        try:
            # Tr√≠ch xu·∫•t th√¥ng tin t·ª´ k·∫øt qu·∫£ ph√°t hi·ªán tr∆∞·ªùng
            advance_found = field_detection_result.get('advance_field_found', False)
            payment_found = field_detection_result.get('payment_field_found', False)
            advance_amount = field_detection_result.get('advance_amount')
            payment_amount = field_detection_result.get('payment_amount')

            # L·∫•y t√™n tr∆∞·ªùng ƒë·ªÉ hi·ªÉn th·ªã trong k·∫øt qu·∫£
            fields_used = field_detection_result.get('fields_used', {})
            advance_field_name = fields_used.get('advance_field', FFN.ADVANCE_AMOUNT)
            payment_field_name = fields_used.get('payment_field', FFN.PAYMENT_AMOUNT)

            print(f"üéØ ƒêang x√°c ƒë·ªãnh lo·∫°i QR: t·∫°m_·ª©ng={advance_found}, thanh_to√°n={payment_found}")
            
            # Logic ∆∞u ti√™n: Ki·ªÉm tra t·∫°m ·ª©ng tr∆∞·ªõc
            if advance_found and advance_amount:
                try:
                    amount_value = float(advance_amount)
                    if amount_value > 0:
                        print(f"‚úÖ Ch·ªçn t·∫°m ·ª©ng: {amount_value:,} VND")
                        return {
                            'qr_type': 'advance',
                            'amount': amount_value,
                            'field_used': advance_field_name,
                            'reason': 'T√¨m th·∫•y s·ªë ti·ªÅn t·∫°m ·ª©ng h·ª£p l·ªá'
                        }
                except (ValueError, TypeError):
                    print(f"‚ö†Ô∏è S·ªë ti·ªÅn t·∫°m ·ª©ng kh√¥ng h·ª£p l·ªá: {advance_amount}")
            
            # N·∫øu kh√¥ng c√≥ t·∫°m ·ª©ng, ki·ªÉm tra thanh to√°n
            if payment_found and payment_amount:
                try:
                    amount_value = float(payment_amount)
                    if amount_value > 0:
                        print(f"‚úÖ Ch·ªçn thanh to√°n: {amount_value:,} VND")
                        return {
                            'qr_type': 'payment', 
                            'amount': amount_value,
                            'field_used': payment_field_name,
                            'reason': 'T√¨m th·∫•y s·ªë ti·ªÅn thanh to√°n h·ª£p l·ªá'
                        }
                except (ValueError, TypeError):
                    print(f"‚ö†Ô∏è S·ªë ti·ªÅn thanh to√°n kh√¥ng h·ª£p l·ªá: {payment_amount}")
            
            # Kh√¥ng t√¨m th·∫•y tr∆∞·ªùng h·ª£p l·ªá n√†o
            print(f"‚ùå Kh√¥ng t√¨m th·∫•y s·ªë ti·ªÅn h·ª£p l·ªá")
            return {
                'qr_type': 'none',
                'amount': None,
                'field_used': None,
                'reason': f'Kh√¥ng t√¨m th·∫•y s·ªë ti·ªÅn h·ª£p l·ªá (t·∫°m_·ª©ng={advance_found}, thanh_to√°n={payment_found})'
            }
            
        except Exception as e:
            print(f"‚ùå L·ªói khi x√°c ƒë·ªãnh lo·∫°i QR: {e}")
            return {
                'qr_type': 'none',
                'amount': None,
                'field_used': None,
                'reason': f'L·ªói: {str(e)}'
            }

    def get_amount_and_type_for_node(self, node_id: str, form_data: List[Dict]) -> Dict:
        """
        L·∫•y s·ªë ti·ªÅn v√† lo·∫°i QR cho m·ªôt node c·ª• th·ªÉ d·ª±a tr√™n chi·∫øn l∆∞·ª£c c·ªßa node.
        
        ƒê√¢y l√† ph∆∞∆°ng th·ª©c ch√≠nh ƒë·ªÉ x·ª≠ l√Ω node, s·∫Ω:
        1. L·∫•y c·∫•u h√¨nh node t·ª´ node_id
        2. √Åp d·ª•ng chi·∫øn l∆∞·ª£c ph√π h·ª£p (detect_both_fields ho·∫∑c payment_field_only)
        3. Ph√¢n t√≠ch form data v√† tr·∫£ v·ªÅ k·∫øt qu·∫£
        
        Args:
            node_id (str): ID c·ªßa node c·∫ßn x·ª≠ l√Ω
            form_data (List[Dict]): D·ªØ li·ªáu form t·ª´ Lark API
            
        Returns:
            Dict: K·∫øt qu·∫£ x·ª≠ l√Ω bao g·ªìm:
                - success (bool): X·ª≠ l√Ω th√†nh c√¥ng hay kh√¥ng
                - qr_type (str): Lo·∫°i QR ƒë√£ x√°c ƒë·ªãnh
                - amount (float): S·ªë ti·ªÅn cho QR
                - field_used (str): Tr∆∞·ªùng ƒë√£ s·ª≠ d·ª•ng
                - node_strategy (str): Chi·∫øn l∆∞·ª£c c·ªßa node
                - reason (str): L√Ω do k·∫øt qu·∫£
                - field_detection (Dict): Chi ti·∫øt ph√°t hi·ªán tr∆∞·ªùng
        """
        try:
            # L·∫•y c·∫•u h√¨nh node t·ª´ h·ªá th·ªëng
            node_config = get_node_config(node_id)
            if not node_config:
                print(f"‚ùå Kh√¥ng t√¨m th·∫•y c·∫•u h√¨nh cho node {node_id}")
                return {
                    'success': False,
                    'qr_type': 'none',
                    'error': f'Kh√¥ng t√¨m th·∫•y node {node_id} trong c·∫•u h√¨nh'
                }
            
            # Tr√≠ch xu·∫•t th√¥ng tin node
            strategy = node_config['strategy']
            node_name = node_config['name']
            
            print(f"üîç ƒêang x·ª≠ l√Ω node: {node_name} (chi·∫øn l∆∞·ª£c: {strategy})")
            
            # Ph√°t hi·ªán c√°c tr∆∞·ªùng c√≥ s·∫µn trong form
            field_detection = self.detect_available_amount_fields(form_data, node_config)
            
            # √Åp d·ª•ng chi·∫øn l∆∞·ª£c x·ª≠ l√Ω theo c·∫•u h√¨nh
            if strategy == "detect_both_fields":
                # Chi·∫øn l∆∞·ª£c ph√°t hi·ªán k√©p: c√≥ th·ªÉ l√† t·∫°m ·ª©ng ho·∫∑c thanh to√°n
                print(f"üìã √Åp d·ª•ng chi·∫øn l∆∞·ª£c ph√°t hi·ªán k√©p")
                qr_decision = self.determine_qr_type_by_fields(field_detection)
                
                return {
                    'success': qr_decision['qr_type'] != 'none',
                    'qr_type': qr_decision['qr_type'],
                    'amount': qr_decision['amount'],
                    'field_used': qr_decision['field_used'],
                    'node_strategy': strategy,
                    'reason': f"K·∫øt qu·∫£ ph√°t hi·ªán k√©p: {qr_decision['reason']}",
                    'field_detection': field_detection
                }
                
            elif strategy == "payment_field_only":
                # Chi·∫øn l∆∞·ª£c ch·ªâ thanh to√°n: ch·ªâ ki·ªÉm tra tr∆∞·ªùng thanh to√°n
                print(f"üí≥ √Åp d·ª•ng chi·∫øn l∆∞·ª£c ch·ªâ thanh to√°n")
                payment_amount = field_detection.get('payment_amount')
                payment_found = field_detection.get('payment_field_found', False)
                payment_field_name = node_config.get('payment_field')

                if payment_found and payment_amount:
                    try:
                        amount_value = float(payment_amount)
                        if amount_value > 0:
                            print(f"‚úÖ T√¨m th·∫•y s·ªë ti·ªÅn thanh to√°n h·ª£p l·ªá: {amount_value:,} VND")
                            return {
                                'success': True,
                                'qr_type': 'payment',
                                'amount': amount_value,
                                'field_used': payment_field_name,
                                'node_strategy': strategy,
                                'reason': 'Chi·∫øn l∆∞·ª£c ch·ªâ thanh to√°n: t√¨m th·∫•y s·ªë ti·ªÅn h·ª£p l·ªá',
                                'field_detection': field_detection
                            }
                    except (ValueError, TypeError):
                        print(f"‚ö†Ô∏è S·ªë ti·ªÅn thanh to√°n kh√¥ng h·ª£p l·ªá: {payment_amount}")
                
                print(f"‚ùå Kh√¥ng t√¨m th·∫•y s·ªë ti·ªÅn thanh to√°n h·ª£p l·ªá")
                return {
                    'success': False,
                    'qr_type': 'none',
                    'amount': None,
                    'field_used': None,
                    'node_strategy': strategy,
                    'reason': f'Chi·∫øn l∆∞·ª£c ch·ªâ thanh to√°n: kh√¥ng c√≥ s·ªë ti·ªÅn h·ª£p l·ªá (t√¨m_th·∫•y={payment_found}, gi√°_tr·ªã={payment_amount})',
                    'field_detection': field_detection
                }
            
            else:
                print(f"‚ùå Chi·∫øn l∆∞·ª£c kh√¥ng x√°c ƒë·ªãnh: {strategy}")
                return {
                    'success': False,
                    'qr_type': 'none',
                    'error': f'Chi·∫øn l∆∞·ª£c kh√¥ng x√°c ƒë·ªãnh: {strategy}'
                }
                
        except Exception as e:
            print(f"‚ùå L·ªói khi x·ª≠ l√Ω node {node_id}: {e}")
            return {
                'success': False,
                'qr_type': 'none',
                'error': str(e)
            }
============================================================

============================================================
FILE: app\domains\qr_generation\services\qr_processor.py
============================================================
import json
from app.core.config.settings import settings
# NODE_CONFIG v√† AmountDetector kh√¥ng c√≤n c·∫ßn thi·∫øt cho logic ch√≠nh, nh∆∞ng gi·ªØ l·∫°i import ƒë·ªÉ kh√¥ng ·∫£nh h∆∞·ªüng c√°c h√†m ph·ª•
from app.core.config.node_config import NODE_CONFIG
from app.core.config.field_constants import FFN
from app.core.infrastructure.lark_service import lark_service
from app.core.infrastructure.cache_service import cache_service
from app.core.utils.field_extractor import FieldExtractor
from app.domains.qr_generation.services.vietqr_service import vietqr_service
# AmountDetector kh√¥ng c√≤n ƒë∆∞·ª£c s·ª≠ d·ª•ng trong h√†m ch√≠nh n·ªØa
# from app.domains.qr_generation.services.amount_detector import AmountDetector
from app.domains.qr_generation.models import QRType, BankInfo

class QRProcessor:
    """
    B·ªô x·ª≠ l√Ω QR ch√≠nh - Qu·∫£n l√Ω logic nghi·ªáp v·ª• t·∫°o v√† x·ª≠ l√Ω m√£ QR cho h·ªá th·ªëng ph√™ duy·ªát.
    
    Class n√†y x·ª≠ l√Ω to√†n b·ªô quy tr√¨nh t·ª´ vi·ªác ki·ªÉm tra node ph√™ duy·ªát, tr√≠ch xu·∫•t d·ªØ li·ªáu,
    validate th√¥ng tin, t·∫°o m√£ VietQR v√† upload l√™n h·ªá th·ªëng Lark.
    
    Attributes:
        field_extractor (FieldExtractor): B·ªô tr√≠ch xu·∫•t tr∆∞·ªùng d·ªØ li·ªáu t·ª´ form
    """

    def __init__(self):
        """Kh·ªüi t·∫°o QRProcessor v·ªõi c√°c service c·∫ßn thi·∫øt."""
        self.field_extractor = FieldExtractor()
        # self.amount_detector kh√¥ng c√≤n c·∫ßn thi·∫øt n·ªØa
        # self.amount_detector = AmountDetector()

    # --- H√ÄM C≈® N√ÄY V·∫™N GI·ªÆ L·∫†I NH∆ØNG KH√îNG ƒê∆Ø·ª¢C G·ªåI TRONG H√ÄM CH√çNH ---
    def check_pending_allowed_node_in_task_list(self, api_response: dict, node_config: dict = None) -> dict:
        """
        Ki·ªÉm tra node c√≥ tr·∫°ng th√°i ph√π h·ª£p v√† ƒë√°p ·ª©ng c√°c ƒëi·ªÅu ki·ªán b·ªï sung.
        (H√†m n√†y kh√¥ng c√≤n ƒë∆∞·ª£c s·ª≠ d·ª•ng trong lu·ªìng ch√≠nh t·∫°o QR ƒë·ªông)
        """
        if node_config is None:
            node_config = NODE_CONFIG
        # ... logic c·ªßa h√†m c≈© gi·ªØ nguy√™n ...
        try:
            # Tr√≠ch xu·∫•t d·ªØ li·ªáu t·ª´ API response
            data = api_response.get('data', {})
            task_list = data.get('task_list', [])
            configured_node_ids = list(node_config.keys())
            
            # T·∫°o map ƒë·ªÉ tra c·ª©u nhanh tr·∫°ng th√°i c·ªßa c√°c node
            node_status_map = {}
            for task in task_list:
                node_id = task.get('node_id')
                status = task.get('status', 'UNKNOWN')
                if node_id:
                    node_status_map[node_id] = status
            
            print(f"üîç ƒêang ki·ªÉm tra c√°c node v·ªõi ƒëi·ªÅu ki·ªán b·ªï sung:")
            for node_id, config in node_config.items():
                required_status = config.get('required_status', 'PENDING')
                additional_conditions = config.get('additional_conditions', [])
                print(f"   ‚Ä¢ {node_id[:8]}... - {config['name']} (y√™u c·∫ßu: {required_status})")
                if additional_conditions:
                    for condition in additional_conditions:
                        print(f"     + ƒêi·ªÅu ki·ªán th√™m: {condition['node_id'][:8]}... ph·∫£i ·ªü tr·∫°ng th√°i {condition['required_status']}")
            
            print(f"üìã Danh s√°ch task ch·ª©a {len(task_list)} nhi·ªám v·ª•")
            
            matching_configured_nodes = []
            
            # Duy·ªát qua t·ª´ng node ƒë√£ c·∫•u h√¨nh
            for node_id in configured_node_ids:
                config = node_config[node_id]
                required_status = config.get('required_status', 'PENDING')
                current_status = node_status_map.get(node_id, 'NOT_FOUND')
                
                # Ki·ªÉm tra ƒëi·ªÅu ki·ªán ch√≠nh
                if current_status != required_status:
                    continue
                    
                # Ki·ªÉm tra c√°c ƒëi·ªÅu ki·ªán b·ªï sung
                additional_conditions = config.get('additional_conditions', [])
                all_conditions_met = True
                
                for condition in additional_conditions:
                    condition_node_id = condition['node_id']
                    condition_required_status = condition['required_status']
                    condition_current_status = node_status_map.get(condition_node_id, 'NOT_FOUND')
                    
                    print(f"üîç Ki·ªÉm tra ƒëi·ªÅu ki·ªán b·ªï sung: {condition_node_id[:8]}... ")
                    print(f"   Y√™u c·∫ßu: {condition_required_status}, Hi·ªán t·∫°i: {condition_current_status}")
                    
                    if condition_current_status != condition_required_status:
                        all_conditions_met = False
                        print(f"‚ùå ƒêi·ªÅu ki·ªán b·ªï sung kh√¥ng ƒë√°p ·ª©ng cho {node_id[:8]}...")
                        break
                    else:
                        print(f"‚úÖ ƒêi·ªÅu ki·ªán b·ªï sung ƒë√£ ƒë√°p ·ª©ng")
                
                # N·∫øu t·∫•t c·∫£ ƒëi·ªÅu ki·ªán ƒë·ªÅu th·ªèa m√£n
                if all_conditions_met:
                    matching_configured_nodes.append({
                        'node_id': node_id,
                        'config': config,
                        'strategy': config['strategy'],
                        'matched_status': current_status,
                        'required_status': required_status,
                        'additional_conditions_met': True
                    })
                    print(f"‚úÖ T√¨m th·∫•y node ph√π h·ª£p: {node_id[:8]}... ({config['name']}) - Tr·∫°ng th√°i: {current_status}")
            
            # Tr·∫£ v·ªÅ node ph√π h·ª£p ƒë·∫ßu ti√™n
            if matching_configured_nodes:
                first_matching = matching_configured_nodes[0]
                return {
                    'found': True,
                    'node_id': first_matching['node_id'],
                    'node_config': first_matching['config'],
                    'strategy': first_matching['strategy'],
                    'matched_status': first_matching['matched_status'],
                    'required_status': first_matching['required_status'],
                    'all_tasks': task_list,
                    'all_matching_configured': matching_configured_nodes,
                    'node_status_map': node_status_map
                }
            else:
                print(f"‚ùå Kh√¥ng t√¨m th·∫•y node n√†o ƒë√°p ·ª©ng t·∫•t c·∫£ ƒëi·ªÅu ki·ªán")
                return {
                    'found': False,
                    'node_id': None,
                    'node_config': None,
                    'strategy': None,
                    'matched_status': None,
                    'all_tasks': task_list,
                    'all_matching_configured': [],
                    'node_status_map': node_status_map
                }
            
        except Exception as e:
            print(f"‚ùå L·ªói khi ki·ªÉm tra node: {e}")
            return {
                'found': False,
                'error': str(e),
                'all_tasks': [],
                'all_matching_configured': []
            }


    def validate_amount_value(self, amount_value) -> dict:
        """
        Validate v√† chuy·ªÉn ƒë·ªïi gi√° tr·ªã s·ªë ti·ªÅn.
        """
        try:
            if amount_value is None:
                return {'valid': False, 'amount': None, 'error': 'S·ªë ti·ªÅn kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng'}
            
            amount_float = float(amount_value)
            amount_int = int(amount_float)
            
            if amount_int <= 0:
                return {'valid': False, 'amount': amount_int, 'error': 'S·ªë ti·ªÅn ph·∫£i l·ªõn h∆°n 0'}
                
            return {'valid': True, 'amount': amount_int, 'error': None}
            
        except (ValueError, TypeError) as e:
            return {'valid': False, 'amount': None, 'error': f'ƒê·ªãnh d·∫°ng s·ªë ti·ªÅn kh√¥ng h·ª£p l·ªá: {str(e)}'}

    async def process_approval_with_qr_comment(self, instance_code: str, access_token: str) -> bool:
        """
        X·ª≠ l√Ω ph√™ duy·ªát v·ªõi t·∫°o QR code v√† comment (phi√™n b·∫£n n√¢ng c·∫•p h·ªó tr·ª£ nhi·ªÅu l·∫ßn t·∫°m ·ª©ng).
        """
        try:
            # B∆∞·ªõc 1: L·∫•y th√¥ng tin chi ti·∫øt c·ªßa instance
            api_response = await lark_service.get_approval_instance(instance_code, access_token)
            if not api_response or 'data' not in api_response:
                print(f"‚ùå Kh√¥ng th·ªÉ l·∫•y th√¥ng tin instance {instance_code}")
                return False
            
            task_list = api_response['data'].get('task_list', [])
            form_str = api_response['data'].get('form', '[]')
            form_data = json.loads(form_str)

            # --- [LOGIC M·ªöI] B·∫Øt ƒë·∫ßu ph·∫ßn t√¨m ki·∫øm l·∫ßn t·∫°m ·ª©ng ho·∫°t ƒë·ªông ---
            
            # 2.1: T√¨m t·∫•t c·∫£ c√°c node "Th·ªß qu·ªπ chi ti·ªÅn t·∫°m ·ª©ng" trong quy tr√¨nh
            cashier_nodes = [task for task in task_list if "Th·ªß qu·ªπ chi ti·ªÅn t·∫°m ·ª©ng" in task.get('node_name', '')]
            print(f"üîç T√¨m th·∫•y {len(cashier_nodes)} node 'Th·ªß qu·ªπ chi ti·ªÅn t·∫°m ·ª©ng' trong quy tr√¨nh.")

            active_advance_info = None
            
            # 2.2: L·∫∑p qua c√°c node th·ªß qu·ªπ ƒë·ªÉ t√¨m node ƒëang PENDING
            for i, node in enumerate(cashier_nodes, 1):
                node_id = node.get('node_id')
                node_status = node.get('status')
                print(f"   - Ki·ªÉm tra l·∫ßn t·∫°m ·ª©ng {i} (Node ID: {node_id[:8]}..., Tr·∫°ng th√°i: {node_status})...")

                # ƒêi·ªÅu ki·ªán 1: Node ph·∫£i ·ªü tr·∫°ng th√°i PENDING
                if node_status == 'PENDING':
                    # ƒêi·ªÅu ki·ªán 2: Ng∆∞·ªùi d√πng ph·∫£i ch·ªçn "Yes" cho l·∫ßn t·∫°m ·ª©ng t∆∞∆°ng ·ª©ng
                    yes_no_field_name = f"Thanh to√°n t·∫°m ·ª©ng l·∫ßn {i}: Y/N"
                    amount_field_name = f"S·ªë ti·ªÅn t·∫°m ·ª©ng l·∫ßn {i}:"

                    yes_no_value = self.field_extractor.extract_field_value(form_data, yes_no_field_name)
                    
                    if yes_no_value == "Yes":
                        print(f"     ‚úÖ ƒêi·ªÅu ki·ªán th·ªèa m√£n: Node PENDING v√† ng∆∞·ªùi d√πng ch·ªçn 'Yes'.")
                        amount_value = self.field_extractor.extract_field_value(form_data, amount_field_name)
                        
                        active_advance_info = {
                            "amount": amount_value,
                            "node_id": node_id,
                            "node_name": node.get('node_name'),
                            "qr_type": "advance",
                            "field_used": amount_field_name,
                            "advance_round": i
                        }
                        print(f"     ‚û°Ô∏è L·∫ßn t·∫°m ·ª©ng {i} ƒë∆∞·ª£c k√≠ch ho·∫°t v·ªõi s·ªë ti·ªÅn: {amount_value}")
                        break # T√¨m th·∫•y r·ªìi th√¨ d·ª´ng l·∫°i
                    else:
                        print(f"     - B·ªè qua: Ng∆∞·ªùi d√πng kh√¥ng ch·ªçn 'Yes' cho l·∫ßn {i} (Gi√° tr·ªã: {yes_no_value}).")
                else:
                    print(f"     - B·ªè qua: Tr·∫°ng th√°i node kh√¥ng ph·∫£i PENDING.")

            # 2.3: X·ª≠ l√Ω k·∫øt qu·∫£ t√¨m ki·∫øm
            if not active_advance_info:
                print(f"‚è≠Ô∏è  Kh√¥ng c√≥ l·∫ßn t·∫°m ·ª©ng n√†o ƒëang ho·∫°t ƒë·ªông (PENDING v√† ƒë∆∞·ª£c ch·ªçn 'Yes'). B·ªè qua t·∫°o QR.")
                return True # Coi nh∆∞ th√†nh c√¥ng v√¨ ƒë√£ x·ª≠ l√Ω ƒë√∫ng (b·ªè qua)

            # --- [LOGIC M·ªöI] K·∫øt th√∫c ph·∫ßn t√¨m ki·∫øm ---


            # --- [PH·∫¶N GI·ªÆ NGUY√äN] Ti·∫øp t·ª•c x·ª≠ l√Ω v·ªõi th√¥ng tin ƒë√£ t√¨m ƒë∆∞·ª£c ---

            # L·∫•y c√°c bi·∫øn t·ª´ k·∫øt qu·∫£ t√¨m ki·∫øm
            matching_node_id = active_advance_info['node_id']
            qr_type = active_advance_info['qr_type']
            amount_value = active_advance_info['amount']
            field_used = active_advance_info['field_used']
            node_name = active_advance_info['node_name']
            
            # B∆∞·ªõc 5: Ki·ªÉm tra duplicate TR∆Ø·ªöC KHI t·∫°o QR
            if cache_service.is_qr_recently_generated(
                instance_code, matching_node_id, qr_type, 
                settings.QR_CACHE_DURATION_MINUTES
            ):
                print(f"‚ö†Ô∏è PH√ÅT HI·ªÜN TR√ôNG L·∫∂P: QR {qr_type.upper()} cho node {node_name} ƒë√£ ƒë∆∞·ª£c t·∫°o g·∫ßn ƒë√¢y.")
                print(f"   ‚Üí B·ªé QUA t·∫°o QR ƒë·ªÉ tr√°nh tr√πng l·∫∑p.")
                return True
            
            print(f"üí∞ Chi ti·∫øt t·∫°o QR cho l·∫ßn t·∫°m ·ª©ng {active_advance_info['advance_round']}:")
            print(f"   - Lo·∫°i: {qr_type}")
            print(f"   - S·ªë ti·ªÅn: {amount_value}")
            print(f"   - Tr∆∞·ªùng s·ª≠ d·ª•ng: {field_used}")
            print(f"   - Node k√≠ch ho·∫°t: {node_name} ({matching_node_id[:8]}...)")
            
            # B∆∞·ªõc 6: Validate s·ªë ti·ªÅn
            amount_validation = self.validate_amount_value(amount_value)
            if not amount_validation['valid']:
                print(f"‚ùå S·ªë ti·ªÅn kh√¥ng h·ª£p l·ªá: {amount_validation['error']}")
                return False
                
            amount_int = amount_validation['amount']

            # B∆∞·ªõc 7: Tr√≠ch xu·∫•t th√¥ng tin ng√¢n h√†ng
            bank_id = self.field_extractor.extract_field_value(form_data, FFN.BANK_NAME)
            account_no = self.field_extractor.extract_field_value(form_data, FFN.BANK_ACCOUNT_NUMBER)
            account_name = self.field_extractor.extract_field_value(form_data, FFN.BENEFICIARY_NAME)

            if not all([bank_id, account_no, account_name]):
                missing = [f for f, v in {FFN.BANK_NAME: bank_id, FFN.BANK_ACCOUNT_NUMBER: account_no, FFN.BENEFICIARY_NAME: account_name}.items() if not v]
                print(f"‚ùå Thi·∫øu th√¥ng tin ng√¢n h√†ng: {', '.join(missing)}")
                return False
            
            # B∆∞·ªõc 8: T·∫°o m√¥ t·∫£ QR theo lo·∫°i
            description = vietqr_service.generate_qr_description(f"{qr_type}{active_advance_info['advance_round']}", instance_code)
            
            print(f"üè¶ T·∫°o VietQR v·ªõi th√¥ng tin:")
            print(f"   - Ng√¢n h√†ng: {bank_id}")
            print(f"   - S·ªë t√†i kho·∫£n: {account_no}")
            print(f"   - T√™n ng∆∞·ªùi nh·∫≠n: {account_name}")
            print(f"   - S·ªë ti·ªÅn: {amount_int:,} VND")
            print(f"   - M√¥ t·∫£: {description}")
            
            # B∆∞·ªõc 9: T·∫°o VietQR code trong b·ªô nh·ªõ
            qr_image_buffer = vietqr_service.create_qr_in_memory(
                bank_id=bank_id,
                account_no=account_no,
                amount=amount_int,
                description=description,
                account_name=account_name
            )
            
            if not qr_image_buffer:
                print("‚ùå Kh√¥ng th·ªÉ t·∫°o m√£ VietQR")
                return False
            
            # B∆∞·ªõc 10: Upload ·∫£nh l√™n Lark Approval
            filename = f"{instance_code}_{qr_type}{active_advance_info['advance_round']}_qr.png"
            upload_result = await lark_service.upload_image_to_approval(qr_image_buffer, filename, access_token)
            
            if not upload_result['success']:
                print(f"‚ùå Upload th·∫•t b·∫°i: {upload_result['error']}")
                return False
            
            # B∆∞·ªõc 11: ƒê√°nh d·∫•u ƒë√£ t·∫°o QR SAU KHI upload th√†nh c√¥ng
            cache_service.mark_qr_as_generated(instance_code, matching_node_id, qr_type)
            
            # B∆∞·ªõc 12: T·∫°o comment n√¢ng cao v·ªõi th√¥ng tin chi ti·∫øt
            comment_result = await lark_service.create_enhanced_comment_with_image(
                instance_code=instance_code,
                file_url=upload_result['file_url'],
                file_code=upload_result['file_code'],
                filename=filename,
                qr_type=f"{qr_type} L·∫ßn {active_advance_info['advance_round']}", # L√†m r√µ h∆°n trong comment
                amount=amount_int,
                node_name=node_name,
                access_token=access_token
            )
            
            if comment_result['success']:
                print(f"‚úÖ Ho√†n th√†nh x·ª≠ l√Ω ph√™ duy·ªát {instance_code}")
                print(f"üí∞ Lo·∫°i: {qr_type.upper()} L·∫¶N {active_advance_info['advance_round']} | S·ªë ti·ªÅn: {amount_int:,} VND")
                print(f"üè∑Ô∏è Node: {node_name}")
                print(f"üìã Tr∆∞·ªùng: {field_used}")
                print(f"üí¨ ID Comment: {comment_result['comment_id']}")
                return True
            else:
                print(f"‚ùå T·∫°o comment th·∫•t b·∫°i: {comment_result['error']}")
                return False
                
        except Exception as e:
            print(f"‚ùå L·ªói x·ª≠ l√Ω ph√™ duy·ªát: {e}")
            import traceback
            traceback.print_exc()
            return False

qr_processor = QRProcessor()
============================================================

============================================================
FILE: app\domains\qr_generation\services\vietqr_service.py
============================================================
import requests
from urllib.parse import quote
from PIL import Image
from io import BytesIO
from app.core.config.settings import settings
from app.domains.qr_generation.models import QRType


class VietQRService:
    """
    D·ªãch v·ª• t·∫°o m√£ QR thanh to√°n VietQR.
    
    Class n√†y cung c·∫•p c√°c ch·ª©c nƒÉng ƒë·ªÉ t·∫°o m√£ QR VietQR th√¥ng qua API,
    x·ª≠ l√Ω h√¨nh ·∫£nh v√† t·∫°o m√¥ t·∫£ ph√π h·ª£p cho t·ª´ng lo·∫°i giao d·ªãch.
    
    VietQR l√† h·ªá th·ªëng thanh to√°n QR code chu·∫©n c·ªßa Vi·ªát Nam, cho ph√©p
    t·∫°o m√£ QR ch·ª©a th√¥ng tin ng√¢n h√†ng, s·ªë ti·ªÅn v√† n·ªôi dung chuy·ªÉn kho·∫£n.
    
    Attributes:
        base_url (str): URL c∆° s·ªü c·ªßa VietQR API t·ª´ settings
    """

    def __init__(self):
        """Kh·ªüi t·∫°o VietQRService v·ªõi URL API t·ª´ c·∫•u h√¨nh."""
        self.base_url = settings.VIETQR_BASE_URL
    
    def create_qr_in_memory(self, bank_id: str, account_no: str, amount: int, 
                           description: str, account_name: str, 
                           template: str = None) -> BytesIO:
        """
        T·∫°o m√£ QR VietQR v·ªõi th√¥ng tin thanh to√°n v√† tr·∫£ v·ªÅ d·ªØ li·ªáu ·∫£nh trong b·ªô nh·ªõ.
        
        Ph∆∞∆°ng th·ª©c n√†y s·∫Ω:
        1. T·∫°o URL request ƒë·∫øn VietQR API v·ªõi c√°c tham s·ªë ƒë√£ m√£ h√≥a
        2. G·ª≠i HTTP request ƒë·ªÉ l·∫•y h√¨nh ·∫£nh QR
        3. X·ª≠ l√Ω h√¨nh ·∫£nh b·∫±ng PIL (chuy·ªÉn ƒë·ªïi format n·∫øu c·∫ßn)
        4. Tr·∫£ v·ªÅ BytesIO object ch·ª©a d·ªØ li·ªáu PNG
        
        Args:
            bank_id (str): M√£ ng√¢n h√†ng (v√≠ d·ª•: 970422 cho MB Bank)
            account_no (str): S·ªë t√†i kho·∫£n th·ª• h∆∞·ªüng
            amount (int): S·ªë ti·ªÅn giao d·ªãch (ƒë∆°n v·ªã: VND)
            description (str): N·ªôi dung chuy·ªÉn kho·∫£n (s·∫Ω ƒë∆∞·ª£c m√£ h√≥a URL)
            account_name (str): T√™n ch·ªß t√†i kho·∫£n (s·∫Ω ƒë∆∞·ª£c m√£ h√≥a URL)
            template (str, optional): Template QR. Defaults to settings.VIETQR_TEMPLATE
        
        Returns:
            BytesIO: D·ªØ li·ªáu ·∫£nh QR d·∫°ng PNG trong b·ªô nh·ªõ, ho·∫∑c None n·∫øu c√≥ l·ªói
            
        Raises:
            requests.exceptions.RequestException: L·ªói khi g·ªçi API
            PIL.UnidentifiedImageError: L·ªói khi x·ª≠ l√Ω h√¨nh ·∫£nh
        """
        # S·ª≠ d·ª•ng template m·∫∑c ƒë·ªãnh n·∫øu kh√¥ng ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh
        if template is None:
            template = settings.VIETQR_TEMPLATE
        
        # M√£ h√≥a URL cho c√°c tham s·ªë ti·∫øng Vi·ªát ƒë·ªÉ tr√°nh l·ªói encoding
        encoded_desc = quote(description)
        encoded_name = quote(account_name)
        
        # T·∫°o URL request theo format c·ªßa VietQR API
        url = (f"{self.base_url}/{bank_id}-{account_no}-{template}.jpg?"
               f"amount={amount}&addInfo={encoded_desc}&accountName={encoded_name}")
        
        print(f"üåê URL VietQR: {url}")
        
        try:
            # G·ª≠i HTTP GET request v·ªõi timeout ƒë·ªÉ tr√°nh treo
            print(f"üì° ƒêang g·ª≠i y√™u c·∫ßu t·∫°o QR ƒë·∫øn VietQR API...")
            response = requests.get(url, timeout=10)
            response.raise_for_status()  # Raise exception n·∫øu HTTP status code kh√¥ng th√†nh c√¥ng
            
            print(f"‚úÖ Nh·∫≠n ƒë∆∞·ª£c d·ªØ li·ªáu QR t·ª´ API ({len(response.content)} bytes)")
            
            # M·ªü v√† x·ª≠ l√Ω h√¨nh ·∫£nh t·ª´ response content
            image = Image.open(BytesIO(response.content))
            print(f"üñºÔ∏è ƒê√£ t·∫£i ·∫£nh QR - K√≠ch th∆∞·ªõc: {image.size}, Mode: {image.mode}")
            
            # Chuy·ªÉn ƒë·ªïi sang RGB n·∫øu ·∫£nh c√≥ mode kh√¥ng t∆∞∆°ng th√≠ch v·ªõi PNG
            # RGBA (c√≥ alpha channel), LA (grayscale + alpha), P (palette mode)
            if image.mode in ('RGBA', 'LA', 'P'):
                print(f"üîÑ Chuy·ªÉn ƒë·ªïi ·∫£nh t·ª´ mode {image.mode} sang RGB")
                image = image.convert('RGB')
            
            # T·∫°o BytesIO buffer ƒë·ªÉ l∆∞u ·∫£nh PNG
            img_buffer = BytesIO()
            image.save(img_buffer, format='PNG')
            img_buffer.seek(0)  # Reset con tr·ªü v·ªÅ ƒë·∫ßu buffer ƒë·ªÉ ƒë·ªçc t·ª´ ƒë·∫ßu
            
            print(f"‚úÖ T·∫°o m√£ VietQR th√†nh c√¥ng trong b·ªô nh·ªõ")
            print(f"üì¶ K√≠ch th∆∞·ªõc buffer: {img_buffer.getbuffer().nbytes} bytes")
            return img_buffer
            
        except requests.exceptions.Timeout:
            print(f"‚è∞ Timeout khi g·ªçi VietQR API (qu√° 10 gi√¢y)")
            return None
        except requests.exceptions.ConnectionError:
            print(f"üîå L·ªói k·∫øt n·ªëi ƒë·∫øn VietQR API")
            return None
        except requests.exceptions.HTTPError as e:
            print(f"üö´ L·ªói HTTP t·ª´ VietQR API: {e}")
            print(f"    Status code: {response.status_code}")
            return None
        except requests.exceptions.RequestException as e:
            print(f"‚ùå L·ªói request khi g·ªçi VietQR API: {e}")
            return None
        except Exception as e:
            print(f"‚ùå L·ªói kh√¥ng x√°c ƒë·ªãnh khi x·ª≠ l√Ω VietQR: {e}")
            return None

    def generate_qr_description(self, qr_type: str, instance_code: str) -> str:
        """
        T·∫°o m√¥ t·∫£ (n·ªôi dung chuy·ªÉn kho·∫£n) cho m√£ QR d·ª±a tr√™n lo·∫°i giao d·ªãch.
        
        M√¥ t·∫£ s·∫Ω ƒë∆∞·ª£c hi·ªÉn th·ªã trong n·ªôi dung chuy·ªÉn kho·∫£n c·ªßa ng√¢n h√†ng,
        gi√∫p ng∆∞·ªùi nh·∫≠n d·ªÖ d√†ng nh·∫≠n bi·∫øt m·ª•c ƒë√≠ch giao d·ªãch.
        
        Args:
            qr_type (str): Lo·∫°i QR code ('advance', 'payment', ho·∫∑c gi√° tr·ªã kh√°c)
            instance_code (str): M√£ ƒë∆°n ph√™ duy·ªát ƒë·ªÉ tham chi·∫øu
            
        Returns:
            str: N·ªôi dung m√¥ t·∫£ cho QR code
            
        Examples:
            >>> generate_qr_description('advance', 'AP123456')
            'Tam ung don AP123456'
            
            >>> generate_qr_description('payment', 'AP123456') 
            'Thanh toan don AP123456'
            
            >>> generate_qr_description('other', 'AP123456')
            'Don AP123456'
        """
        # X√°c ƒë·ªãnh m√¥ t·∫£ d·ª±a tr√™n lo·∫°i QR
        if qr_type == 'advance':
            description = f"Tam ung don {instance_code}"
            print(f"üìù T·∫°o m√¥ t·∫£ QR t·∫°m ·ª©ng: {description}")
        elif qr_type == 'payment':
            description = f"Thanh toan don {instance_code}"
            print(f"üìù T·∫°o m√¥ t·∫£ QR thanh to√°n: {description}")
        else:
            # Fallback cho c√°c lo·∫°i kh√°c
            description = f"Don {instance_code}"
            print(f"üìù T·∫°o m√¥ t·∫£ QR chung: {description}")
            
        return description

vietqr_service = VietQRService()
============================================================

============================================================
FILE: app\domains\validation\__init__.py
============================================================
# app/domains/validation/__init__.py
from .models import *
from .services import *
from .handlers import *

__all__ = [
    # Models
    "ValidationType", "ValidationResult", "ValidationResponse",
    # Services
    "validation_service",
    # Handlers  
    "validation_event_handler"
]

============================================================

============================================================
FILE: app\domains\validation\handlers\__init__.py
============================================================
from .validation_event_handler import validation_event_handler

__all__ = ["validation_event_handler"]

============================================================

============================================================
FILE: app\domains\validation\handlers\validation_event_handler.py
============================================================
"""
Validation Event Handler - B·ªô x·ª≠ l√Ω s·ª± ki·ªán validation cho h·ªá th·ªëng ph√™ duy·ªát
"""
from typing import Dict, List, Optional
import json
from app.domains.validation.services import validation_service
from app.core.infrastructure import lark_service
from app.domains.notification.services import lark_webhook_service
from app.core.infrastructure import cache_service

class ValidationEventHandler:
    """
    B·ªô x·ª≠ l√Ω s·ª± ki·ªán validation cho h·ªá th·ªëng ph√™ duy·ªát.
    
    Class n√†y ch·ªãu tr√°ch nhi·ªám:
    1. Nh·∫≠n v√† x·ª≠ l√Ω c√°c s·ª± ki·ªán ph√™ duy·ªát ƒë·ªÉ validation
    2. Ch·∫°y c√°c quy t·∫Øc validation tr√™n d·ªØ li·ªáu form v√† workflow
    3. G·ª≠i c·∫£nh b√°o qua webhook khi ph√°t hi·ªán v·∫•n ƒë·ªÅ
    4. NgƒÉn ch·∫∑n duplicate alerts ƒë·ªÉ tr√°nh spam notification
    5. X·ª≠ l√Ω l·ªói v√† g·ª≠i error alerts khi c·∫ßn thi·∫øt
    
    Attributes:
        name (str): T√™n ƒë·ªãnh danh c·ªßa service
        webhook_service: Service g·ª≠i webhook notifications
    """
    
    def __init__(self):
        """Kh·ªüi t·∫°o ValidationEventHandler v·ªõi webhook service."""
        self.name = "Validation_Service"
        self.webhook_service = lark_webhook_service

    async def handle_approval_event(self, event_data: Dict) -> Dict:
        """
        X·ª≠ l√Ω s·ª± ki·ªán ph√™ duy·ªát ƒë·ªÉ th·ª±c hi·ªán validation v·ªõi c∆° ch·∫ø anti-spam n√¢ng cao.

        [N√ÇNG C·∫§P] B·ªï sung logic ki·ªÉm tra tr·∫°ng th√°i ƒë∆°n. S·∫Ω b·ªè qua x·ª≠ l√Ω
        n·∫øu ƒë∆°n ·ªü tr·∫°ng th√°i cu·ªëi c√πng nh∆∞ REJECTED, CANCELED, DELETED.
        
        Quy tr√¨nh x·ª≠ l√Ω m·ªõi:
        1. L·∫•y d·ªØ li·ªáu instance t·ª´ Lark.
        2. Ch·∫°y t·∫•t c·∫£ c√°c validation rules.
        3. L·ªçc ra c√°c k·∫øt qu·∫£ kh√¥ng h·ª£p l·ªá (invalid).
        4. **[LOGIC M·ªöI]** L·∫∑p qua t·ª´ng l·ªói kh√¥ng h·ª£p l·ªá:
            a. D√πng `validation_type` c·ª• th·ªÉ c·ªßa l·ªói ƒë·ªÉ ki·ªÉm tra cache.
            b. N·∫øu l·ªói ch∆∞a ƒë∆∞·ª£c cache, th√™m n√≥ v√†o danh s√°ch c·∫ßn g·ª≠i c·∫£nh b√°o.
        5. N·∫øu c√≥ l·ªói c·∫ßn c·∫£nh b√°o, g·ª≠i m·ªôt webhook duy nh·∫•t ch·ª©a t·∫•t c·∫£ c√°c l·ªói m·ªõi.
        6. **[LOGIC M·ªöI]** Sau khi g·ª≠i, ghi cache cho t·ª´ng lo·∫°i l·ªói ƒë√£ ƒë∆∞·ª£c c·∫£nh b√°o.
        """
        instance_code = event_data.get('instance_code')
        if not instance_code:
            return {"success": False, "message": "Kh√¥ng t√¨m th·∫•y instance_code", "service": self.name}

        try:
            # [TH√äM M·ªöI] B·∫Øt ƒë·∫ßu kh·ªëi logic ki·ªÉm tra tr·∫°ng th√°i
            FINAL_STATUSES = ['REJECTED', 'CANCELED', 'DELETED']

            # Tr√≠ch xu·∫•t tr·∫°ng th√°i t·ª´ d·ªØ li·ªáu g·ªëc c·ªßa s·ª± ki·ªán ƒë·ªÉ tr√°nh g·ªçi API kh√¥ng c·∫ßn thi·∫øt
            raw_data = event_data.get('raw_data', {})
            instance_status = raw_data.get('event', {}).get('object', {}).get('status')

            # N·∫øu kh√¥ng c√≥ trong payload, th√¨ t√¨m trong event body
            event_body = raw_data.get('event', {})
            if not instance_status:
                instance_status = event_body.get('status')


            # Ki·ªÉm tra xem tr·∫°ng th√°i c·ªßa ƒë∆°n c√≥ n·∫±m trong danh s√°ch c·∫ßn b·ªè qua kh√¥ng
            if instance_status and instance_status in FINAL_STATUSES:
                print(f"‚è≠Ô∏è [Validation Handler] B·ªè qua instance {instance_code} do c√≥ tr·∫°ng th√°i cu·ªëi c√πng: {instance_status}")
                return {
                    "success": True, # Coi nh∆∞ th√†nh c√¥ng v√¨ ƒë√£ x·ª≠ l√Ω ƒë√∫ng (b·ªè qua)
                    "message": f"B·ªè qua validation do tr·∫°ng th√°i ƒë∆°n l√† {instance_status}",
                    "instance_code": instance_code,
                    "webhook_sent": False, # Kh√¥ng c√≥ webhook n√†o ƒë∆∞·ª£c g·ª≠i
                    "service": self.name
                }
            # [TH√äM M·ªöI] K·∫øt th√∫c kh·ªëi logic ki·ªÉm tra tr·∫°ng th√°i

            print(f"üîç [Validation Handler] D·ªãch v·ª• Validation ƒëang x·ª≠ l√Ω: {instance_code} (Tr·∫°ng th√°i: {instance_status or 'N/A'})")
            
            # B∆∞·ªõc 1 & 2: L·∫•y d·ªØ li·ªáu t·ª´ Lark
            access_token = await lark_service.get_access_token()
            if not access_token:
                return {"success": False, "message": "Kh√¥ng th·ªÉ l·∫•y access token", "service": self.name}

            api_response = await lark_service.get_approval_instance(instance_code, access_token)
            if not api_response or 'data' not in api_response:
                return {"success": False, "message": "Kh√¥ng th·ªÉ l·∫•y d·ªØ li·ªáu instance", "service": self.name}
            
            serial_number = api_response.get('data', {}).get('serial_number')
            form_data = json.loads(api_response['data'].get('form', '[]'))
            task_list = api_response['data'].get('task_list', [])
            
            # B∆∞·ªõc 3: Ch·∫°y validations v√† l·ªçc ra c√°c l·ªói
            validation_results = validation_service.run_all_validations(
                form_data, task_list, "dummy_node_id" # node_id c√≥ th·ªÉ c·∫ßn ƒë∆∞·ª£c truy·ªÅn v√†o t·ª´ event_data n·∫øu logic y√™u c·∫ßu
            )
            invalid_results = [r for r in validation_results if not r.is_valid]
            
            if not invalid_results:
                print("‚úÖ [Validation Handler] T·∫•t c·∫£ validation ƒë·ªÅu th√†nh c√¥ng.")
                return {
                    "success": True, "message": "T·∫•t c·∫£ validation ƒë·ªÅu th√†nh c√¥ng",
                    "webhook_sent": False, "webhook_skipped_count": 0,
                    "service": self.name
                }
            
            # --- PH·∫¶N LOGIC ANTI-SPAM ƒê∆Ø·ª¢C THAY TH·∫æ HO√ÄN TO√ÄN ---
            # B∆∞·ªõc 4: L·ªçc ra c√°c c·∫£nh b√°o ch∆∞a ƒë∆∞·ª£c g·ª≠i (ch∆∞a c√≥ trong cache)
            alerts_to_send = []
            skipped_count = 0
            
            print(f"‚ö†Ô∏è [Validation Handler] Ph√°t hi·ªán {len(invalid_results)} v·∫•n ƒë·ªÅ. ƒêang ki·ªÉm tra cache anti-spam...")
            for result in invalid_results:
                # T·∫†O CACHE KEY C·ª§ TH·ªÇ CHO T·ª™NG L·ªñI
                # D√πng hash c·ªßa message ƒë·ªÉ ƒë·∫£m b·∫£o m·ªói l·ªói l√† duy nh·∫•t
                specific_error_key = f"{result.validation_type.value}_{hash(result.message)}"
                
                if cache_service.is_validation_alert_recently_sent(
                    instance_code, specific_error_key, cache_duration_minutes=10
                ):
                    print(f"  üîÑ B·ªè qua (ƒë√£ cache): {result.message[:80]}...") # Log m·ªôt ph·∫ßn message
                    skipped_count += 1
                else:
                    print(f"  üÜï C·∫ßn g·ª≠i c·∫£nh b√°o cho: {result.message[:80]}...")
                    alerts_to_send.append(result)

            # B∆∞·ªõc 5: G·ª≠i webhook n·∫øu c√≥ c·∫£nh b√°o m·ªõi c·∫ßn g·ª≠i
            webhook_sent = False
            if alerts_to_send:
                error_messages = [r.message for r in alerts_to_send]
                print(f"üì® [Validation Handler] ƒêang g·ª≠i {len(error_messages)} c·∫£nh b√°o m·ªõi qua webhook...")
                
                webhook_sent = await self._send_validation_alert(instance_code, error_messages, serial_number)
                
                # B∆∞·ªõc 6: N·∫øu g·ª≠i th√†nh c√¥ng, ghi cache cho t·ª´ng l·ªói ƒë√£ g·ª≠i
                if webhook_sent:
                    print("‚úÖ [Validation Handler] G·ª≠i webhook th√†nh c√¥ng. ƒêang c·∫≠p nh·∫≠t cache...")
                    for result in alerts_to_send:
                        # D√ôNG L·∫†I CACHE KEY C·ª§ TH·ªÇ ƒê√É T·∫†O ·ªû TR√äN
                        specific_error_key = f"{result.validation_type.value}_{hash(result.message)}"
                        cache_service.mark_validation_alert_as_sent(instance_code, specific_error_key)
                        print(f"  üîí ƒê√£ cache cho: {result.message[:80]}...")
                else:
                    print("‚ùå [Validation Handler] G·ª≠i webhook th·∫•t b·∫°i.")
            else:
                print("‚úÖ [Validation Handler] Kh√¥ng c√≥ c·∫£nh b√°o m·ªõi n√†o c·∫ßn g·ª≠i. T·∫•t c·∫£ ƒë√£ ƒë∆∞·ª£c cache.")

            return {
                "success": True,
                "message": f"Ho√†n th√†nh validation. {len(alerts_to_send)} c·∫£nh b√°o m·ªõi ƒë√£ ƒë∆∞·ª£c g·ª≠i. {skipped_count} c·∫£nh b√°o b·ªã b·ªè qua do cache.",
                "alerts_sent_count": len(alerts_to_send),
                "webhook_sent": webhook_sent,
                "webhook_skipped_count": skipped_count,
                "validation_details": [r.dict() for r in validation_results],
                "service": self.name
            }
            
        except Exception as e:
            # X·ª≠ l√Ω l·ªói h·ªá th·ªëng (gi·ªØ nguy√™n logic c≈©)
            print(f"‚ùå [Validation Handler] L·ªói nghi√™m tr·ªçng trong Validation Service: {str(e)}")
            # ... (ph·∫ßn x·ª≠ l√Ω l·ªói n√†y c√≥ th·ªÉ gi·ªØ nguy√™n ho·∫∑c c·∫£i ti·∫øn sau)
            return {
                "success": False,
                "message": f"L·ªói Validation Service: {str(e)}",
                "service": self.name
            }

    async def _send_validation_alert(self, instance_code: str, error_messages: List[str], serial_number: Optional[str]) -> bool:
        """G·ª≠i c·∫£nh b√°o validation qua webhook service."""
        try:
            from app.domains.notification.models import ValidationAlertRequest, NotificationPriority
            request = ValidationAlertRequest(
                instance_code=instance_code,
                serial_number=serial_number,
                validation_errors=error_messages,
                priority=NotificationPriority.HIGH
            )
            result = await self.webhook_service.send_validation_alert(request)
            return result.success
        except Exception as e:
            print(f"‚ùå L·ªói khi g·ª≠i validation alert: {e}")
            return False

    async def _send_error_alert(self, instance_code: str, error_message: str) -> bool:
        """G·ª≠i c·∫£nh b√°o l·ªói h·ªá th·ªëng qua webhook service."""
        try:
            # Logic n√†y hi·ªán kh√¥ng ƒë∆∞·ª£c d√πng trong lu·ªìng ch√≠nh nh∆∞ng gi·ªØ l·∫°i ƒë·ªÉ c√≥ th·ªÉ d√πng sau
            result = await self.webhook_service.send_custom_alert(
                title="L·ªñI VALIDATION SERVICE",
                message=f"L·ªói x·ª≠ l√Ω validation cho {instance_code}: {error_message}",
                instance_code=instance_code
            )
            return result.success
        except Exception as e:
            print(f"‚ùå L·ªói khi g·ª≠i error alert: {e}")
            return False


validation_event_handler = ValidationEventHandler()
============================================================

============================================================
FILE: app\domains\validation\models\__init__.py
============================================================
from .validation import (
    ValidationType,
    ValidationStatus,
    ValidationResult,
    ValidationRequest,
    ValidationResponse
)

__all__ = [
    "ValidationType",
    "ValidationStatus", 
    "ValidationResult",
    "ValidationRequest",
    "ValidationResponse"
]

============================================================

============================================================
FILE: app\domains\validation\models\validation.py
============================================================
from pydantic import BaseModel
from typing import Optional, Dict, Any, List
from enum import Enum


class ValidationType(str, Enum):
    AMOUNT_SUM = "amount_sum_validation"

    ADVANCE_AMOUNT_MISMATCH = "advance_amount_mismatch"      # T·∫°m ·ª©ng
    PAYMENT_AMOUNT_MISMATCH = "payment_amount_mismatch"      # Thanh to√°n  
    TOTAL_AMOUNT_MISMATCH = "total_amount_mismatch"          # T·ªïng amount
    
    WORKFLOW_STATUS = "workflow_status_validation" 
    FIELD_CONSISTENCY = "field_consistency_validation"
    PAYMENT_CONSISTENCY = "payment_consistency_validation"
    TOTAL_PAYMENT_VALIDATION = "total_payment_validation"


class ValidationStatus(str, Enum):
    VALID = "valid"
    INVALID = "invalid"
    SKIPPED = "skipped"
    ERROR = "error"


class ValidationResult(BaseModel):
    """Enhanced validation result model with proper enums"""
    is_valid: bool
    validation_type: ValidationType
    status: ValidationStatus
    message: str
    details: Optional[Dict[str, Any]] = None
    
    @classmethod
    def create_valid(cls, validation_type: ValidationType, message: str, details: Dict = None):
        return cls(
            is_valid=True,
            validation_type=validation_type,
            status=ValidationStatus.VALID,
            message=message,
            details=details or {}
        )
    
    @classmethod
    def create_invalid(cls, validation_type: ValidationType, message: str, details: Dict = None):
        return cls(
            is_valid=False,
            validation_type=validation_type,
            status=ValidationStatus.INVALID,
            message=message,
            details=details or {}
        )
    
    @classmethod
    def create_skipped(cls, validation_type: ValidationType, message: str, details: Dict = None):
        return cls(
            is_valid=True,  # Skipped is not a failure
            validation_type=validation_type,
            status=ValidationStatus.SKIPPED,
            message=message,
            details=details or {}
        )
    
    @classmethod
    def create_error(cls, validation_type: ValidationType, message: str, details: Dict = None):
        return cls(
            is_valid=False,
            validation_type=validation_type,
            status=ValidationStatus.ERROR,
            message=message,
            details=details or {}
        )


class ValidationRequest(BaseModel):
    instance_code: str
    form_data: List[Dict[str, Any]]
    task_list: List[Dict[str, Any]]
    node_id: Optional[str] = None


class ValidationResponse(BaseModel):
    success: bool
    instance_code: str
    validation_results: List[ValidationResult]
    invalid_count: int
    total_validations: int
    alerts_sent: bool = False
    webhook_sent: bool = False
    message: Optional[str] = None
============================================================

============================================================
FILE: app\domains\validation\routers\notification.py
============================================================
from fastapi import APIRouter
from app.domains.notification.models import NotificationRequest, NotificationResult
from app.domains.notification.services.notification_coordinator import notification_coordinator

router = APIRouter(prefix="/notification", tags=["Notification"])

@router.post("/send", response_model=NotificationResult)
async def send_notification(request: NotificationRequest):
    """Manual g·ª≠i notification"""
    return await notification_coordinator.send_notification(request)

@router.get("/channels")
async def get_notification_channels():
    """Xem danh s√°ch notification channels"""
    from app.domains.notification.models import NotificationChannel, NotificationType
    return {
        "channels": [ch.value for ch in NotificationChannel],
        "types": [nt.value for nt in NotificationType],
        "supported_combinations": {
            "lark_webhook": ["validation_alert", "custom_alert", "service_error"]
        }
    }

@router.get("/cache/status")
async def get_notification_cache_status():
    """Xem tr·∫°ng th√°i notification cache"""
    from app.core.infrastructure.cache_service import cache_service
    cache_status = cache_service.get_cache_status()
    return cache_status.get('validation_cache', {})

============================================================

============================================================
FILE: app\domains\validation\routers\validation.py
============================================================
from fastapi import APIRouter
from app.domains.validation.models import ValidationRequest, ValidationResponse
from app.domains.validation.services.validation_service import validation_service

router = APIRouter(prefix="/validation", tags=["Validation"])

@router.post("/validate", response_model=ValidationResponse)
async def validate_instance(request: ValidationRequest):
    """Manual validation c·ªßa m·ªôt instance"""
    try:
        # Ch·∫°y validations
        validation_results = validation_service.run_all_validations(
            request.form_data, 
            request.task_list, 
            request.node_id or "manual_validation"
        )
        
        invalid_count = len([r for r in validation_results if not r.is_valid])
        
        return ValidationResponse(
            success=True,
            instance_code=request.instance_code,
            validation_results=validation_results,
            invalid_count=invalid_count,
            total_validations=len(validation_results),
            message=f"Completed {len(validation_results)} validations, {invalid_count} issues found"
        )
        
    except Exception as e:
        return ValidationResponse(
            success=False,
            instance_code=request.instance_code,
            validation_results=[],
            invalid_count=0,
            total_validations=0,
            message=f"Validation error: {str(e)}"
        )

@router.get("/rules")
async def get_validation_rules():
    """Xem danh s√°ch validation rules"""
    from app.domains.validation.models import ValidationType
    return {
        "available_rules": [vt.value for vt in ValidationType],
        "total_rules": len(ValidationType)
    }

============================================================

============================================================
FILE: app\domains\validation\services\__init__.py
============================================================
# app/domains/validation/services/__init__.py
from .validation_service import validation_service

__all__ = ["validation_service"]

============================================================

============================================================
FILE: app\domains\validation\services\validation_service.py
============================================================
"""
Validation Service - D·ªãch v·ª• domain cho c√°c quy t·∫Øc validation
"""
from typing import Dict, List, Any, Optional
from app.domains.validation.models import ValidationResult, ValidationType, ValidationStatus
from app.core.utils.field_extractor import FieldExtractor
from app.core.config.field_constants import FFN

class ValidationService:
    """
    D·ªãch v·ª• validation cho h·ªá th·ªëng ph√™ duy·ªát.
    
    Class n√†y cung c·∫•p c√°c quy t·∫Øc validation kh√°c nhau ƒë·ªÉ ki·ªÉm tra
    t√≠nh nh·∫•t qu√°n v√† h·ª£p l·ªá c·ªßa d·ªØ li·ªáu trong quy tr√¨nh ph√™ duy·ªát:
    
    - ADVANCE_AMOUNT_MISMATCH: So s√°nh t·ªïng s·ªë ti·ªÅn t·∫°m ·ª©ng
    - PAYMENT_AMOUNT_MISMATCH: So s√°nh s·ªë ti·ªÅn thanh to√°n
    - TOTAL_AMOUNT_MISMATCH: Ki·ªÉm tra t·ªïng s·ªë ti·ªÅn thanh to√°n
    - WORKFLOW_STATUS: Ki·ªÉm tra tr·∫°ng th√°i node
    - FIELD_CONSISTENCY: Ki·ªÉm tra logic gi·ªØa c√°c tr∆∞·ªùng
    
    M·ªói validation s·∫Ω tr·∫£ v·ªÅ ValidationResult v·ªõi m·ªôt trong c√°c tr·∫°ng th√°i:
    - VALID: Validation pass
    - INVALID: Validation fail  
    - SKIPPED: B·ªè qua do thi·∫øu d·ªØ li·ªáu
    - ERROR: C√≥ l·ªói trong qu√° tr√¨nh validation
    
    Attributes:
        field_extractor (FieldExtractor): C√¥ng c·ª• tr√≠ch xu·∫•t d·ªØ li·ªáu t·ª´ form
        validation_rules (Dict): Map t·ª´ validation type ƒë·∫øn method t∆∞∆°ng ·ª©ng
    """
    
    def __init__(self):
        """Kh·ªüi t·∫°o ValidationService v·ªõi field extractor v√† mapping rules."""
        self.field_extractor = FieldExtractor()
        
        self.validation_rules = {
            ValidationType.ADVANCE_AMOUNT_MISMATCH: self.validate_advance_amount_mismatch,
            ValidationType.PAYMENT_AMOUNT_MISMATCH: self.validate_payment_amount_mismatch,
            #ValidationType.TOTAL_AMOUNT_MISMATCH: self.validate_total_amount_mismatch,
            ValidationType.WORKFLOW_STATUS: self.validate_workflow_status,
            ValidationType.FIELD_CONSISTENCY: self.validate_field_consistency,
        }
    
    # Thay v√¨ tr·∫£ v·ªÅ ValidationResult, gi·ªù ƒë√¢y h√†m s·∫Ω tr·∫£ v·ªÅ List[ValidationResult]
    def validate_advance_amount_mismatch(self, form_data: List[Dict], **kwargs) -> List[ValidationResult]:
        """
        Tr·∫£ v·ªÅ m·ªôt danh s√°ch c√°c ValidationResult, m·ªói result cho m·ªôt l·ªói.
        """
        try:
            accountant_expenditures = self.field_extractor.extract_all_values_from_fieldlist(
                form_data, FFN.ACCOUNTING_ADVANCE_INFO, FFN.EXPENDITURE_AMOUNT
            )
            
            results = []
            found_data = False

            for i in range(1, 5): # Ch·ªâ ki·ªÉm tra 4 l·∫ßn
                user_advance_field = f"S·ªë ti·ªÅn t·∫°m ·ª©ng l·∫ßn {i}:"
                user_advance_value = self.field_extractor.extract_field_value(form_data, user_advance_field)
                
                if user_advance_value is not None:
                    found_data = True

                if (i - 1) >= len(accountant_expenditures) or user_advance_value is None:
                    continue
                
                accountant_expenditure_value = accountant_expenditures[i-1]
                
                try:
                    user_amount = float(user_advance_value)
                    accountant_amount = float(accountant_expenditure_value)
                    
                    if abs(user_amount - accountant_amount) >= 0.01:
                        message = (f"‚ùå L·ªói T·∫°m ·ª©ng L·∫ßn {i}: Y√™u c·∫ßu ({user_amount:,.0f}) ‚â† K·∫ø to√°n chi ({accountant_amount:,.0f}). "
                                f"L·ªách: {abs(user_amount - accountant_amount):,.0f} VND")
                        # T·∫°o m·ªôt result ri√™ng cho l·ªói n√†y
                        results.append(ValidationResult.create_invalid(ValidationType.ADVANCE_AMOUNT_MISMATCH, message))
                except (ValueError, TypeError):
                    message = f"‚ùå L·ªói ƒë·ªãnh d·∫°ng s·ªë T·∫°m ·ª©ng L·∫ßn {i}."
                    results.append(ValidationResult.create_invalid(ValidationType.ADVANCE_AMOUNT_MISMATCH, message))

            # N·∫øu kh√¥ng c√≥ l·ªói n√†o ƒë∆∞·ª£c t√¨m th·∫•y v√† c√≥ d·ªØ li·ªáu ƒë·ªÉ ki·ªÉm tra
            if not results and found_data:
                results.append(ValidationResult.create_valid(
                    ValidationType.ADVANCE_AMOUNT_MISMATCH,
                    "‚úÖ T·∫•t c·∫£ c√°c l·∫ßn t·∫°m ·ª©ng ƒë√£ kh·ªõp."
                ))
            
            # N·∫øu kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ ki·ªÉm tra
            if not found_data:
                results.append(ValidationResult.create_skipped(
                    ValidationType.ADVANCE_AMOUNT_MISMATCH,
                    "‚ÑπÔ∏è B·ªè qua: Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu t·∫°m ·ª©ng ƒë·ªÉ so s√°nh."
                ))
            
            return results
                
        except Exception as e:
            return [ValidationResult.create_error(
                ValidationType.ADVANCE_AMOUNT_MISMATCH,
                f"‚ùå L·ªói h·ªá th·ªëng khi validation ti·ªÅn t·∫°m ·ª©ng: {e}",
            )]

    def validate_payment_amount_mismatch(self, form_data: List[Dict], **kwargs) -> ValidationResult:
        """
        Validation t√≠nh nh·∫•t qu√°n s·ªë ti·ªÅn thanh to√°n (gi·ªØ nguy√™n logic c≈©).
        
        So s√°nh "K·∫ø to√°n - Th√¥ng tin thanh to√°n" v·ªõi "S·ªë ti·ªÅn c√≤n ph·∫£i thanh to√°n" 
        ho·∫∑c "S·ªë ti·ªÅn thanh to√°n".
        """
        try:
            payment_info_amount = self.field_extractor.extract_field_from_fieldlist(
                form_data,  FFN.ACCOUNTING_PAYMENT_INFO, FFN.EXPENDITURE_AMOUNT
            )
            amount_due = self.field_extractor.extract_field_value(
                form_data,  FFN.REMAINING_PAYMENT_AMOUNT
            )
            amount_paid = self.field_extractor.extract_field_value(
                form_data, FFN.PAYMENT_AMOUNT
            )
            
            compare_amount = amount_due if amount_due is not None else amount_paid
            compare_field_name = FFN.REMAINING_PAYMENT_AMOUNT if amount_due is not None else FFN.PAYMENT_AMOUNT

            if payment_info_amount is None or compare_amount is None:
                return ValidationResult.create_skipped(
                    ValidationType.PAYMENT_AMOUNT_MISMATCH,
                    "‚ÑπÔ∏è B·ªè qua: Kh√¥ng t√¨m th·∫•y ƒë·ªß c√°c tr∆∞·ªùng v·ªÅ s·ªë ti·ªÅn thanh to√°n ƒë·ªÉ so s√°nh."
                )

            payment_info_float = float(payment_info_amount)
            compare_amount_float = float(compare_amount)

            if abs(payment_info_float - compare_amount_float) < 0.01:
                return ValidationResult.create_valid(
                    ValidationType.PAYMENT_AMOUNT_MISMATCH,
                    f"‚úÖ S·ªë ti·ªÅn thanh to√°n nh·∫•t qu√°n: {payment_info_float:,.0f} VND"
                )
            else:
                message = (f"‚ùå L·ªói thanh to√°n: 'K·∫ø to√°n' ({payment_info_float:,.0f}) ‚â† "
                           f"'{compare_field_name}' ({compare_amount_float:,.0f}). "
                           f"Ch√™nh l·ªách: {abs(payment_info_float - compare_amount_float):,.0f} VND")
                details = {"payment_info_amount": payment_info_float, "compare_amount": compare_amount_float}
                return ValidationResult.create_invalid(ValidationType.PAYMENT_AMOUNT_MISMATCH, message, details)
        except (ValueError, TypeError) as e:
            return ValidationResult.create_error(
                ValidationType.PAYMENT_AMOUNT_MISMATCH, f"‚ùå L·ªói ƒë·ªãnh d·∫°ng s·ªë ti·ªÅn thanh to√°n: {e}",
            )
        except Exception as e:
            return ValidationResult.create_error(
                ValidationType.PAYMENT_AMOUNT_MISMATCH, f"‚ùå L·ªói kh√¥ng x√°c ƒë·ªãnh khi validation ti·ªÅn thanh to√°n: {e}",
            )

    def validate_total_amount_mismatch(self, form_data: List[Dict], **kwargs) -> ValidationResult:
        """
        Validation t·ªïng s·ªë ti·ªÅn thanh to√°n d·ª±a tr√™n c√°c kho·∫£n chi ƒë√£ ƒë∆∞·ª£c k·∫ø to√°n x√°c nh·∫≠n.
        
        C√¥ng th·ª©c: Total = (T·ªïng c√°c kho·∫£n chi trong FieldList "K·∫ø to√°n - Th√¥ng tin t·∫°m ·ª©ng") + (S·ªë ti·ªÅn c√≤n ph·∫£i thanh to√°n).
        """
        try:
            # L·∫•y t·ªïng c√°c kho·∫£n chi t·∫°m ·ª©ng TH·ª∞C T·∫æ t·ª´ k·∫ø to√°n
            accountant_expenditures = self.field_extractor.extract_all_values_from_fieldlist(
                form_data, FFN.ACCOUNTING_ADVANCE_INFO, FFN.EXPENDITURE_AMOUNT
            )
            total_accountant_advance = sum(float(v) for v in accountant_expenditures if v is not None and str(v).strip() != '')

            # L·∫•y c√°c tr∆∞·ªùng c√≤n l·∫°i
            amount_due = self.field_extractor.extract_field_value(form_data, FFN.REMAINING_PAYMENT_AMOUNT)
            total_payment_actual = self.field_extractor.extract_field_value(form_data, FFN.TOTAL_PAYMENT_AMOUNT)

            if total_accountant_advance == 0 and amount_due is None:
                return ValidationResult.create_skipped(
                    ValidationType.TOTAL_AMOUNT_MISMATCH,
                    f"‚ÑπÔ∏è B·ªè qua: K·∫ø to√°n ch∆∞a ƒëi·ªÅn th√¥ng tin chi ho·∫∑c s·ªë ti·ªÅn c√≤n l·∫°i."
                )

            if total_payment_actual is None:
                return ValidationResult.create_skipped(
                    ValidationType.TOTAL_AMOUNT_MISMATCH,
                    f"‚ÑπÔ∏è B·ªè qua: Kh√¥ng t√¨m th·∫•y tr∆∞·ªùng '{FFN.TOTAL_PAYMENT_AMOUNT}' ƒë·ªÉ t√≠nh t·ªïng."
                )

            amount_due_float = float(amount_due) if amount_due is not None else 0.0
            total_actual_float = float(total_payment_actual)
            
            total_expected = total_accountant_advance + amount_due_float

            if abs(total_expected - total_actual_float) < 0.01:
                return ValidationResult.create_valid(
                    ValidationType.TOTAL_AMOUNT_MISMATCH,
                    f"‚úÖ T·ªïng s·ªë ti·ªÅn h·ª£p l·ªá: {total_actual_float:,.0f} VND"
                )
            else:
                case_description = f"T·ªïng K·∫ø to√°n chi ({total_accountant_advance:,.0f}) + C√≤n L·∫°i ({amount_due_float:,.0f})"
                message = (f"‚ùå L·ªói t·ªïng ti·ªÅn: Th·ª±c t·∫ø ({total_actual_float:,.0f}) ‚â† "
                        f"D·ª± ki·∫øn ({total_expected:,.0f} t·ª´ {case_description}). "
                        f"Ch√™nh l·ªách: {abs(total_expected - total_actual_float):,.0f} VND")
                details = {
                    "total_expected": total_expected, 
                    "total_actual": total_actual_float,
                    "total_accountant_advance": total_accountant_advance,
                    "remaining_payment": amount_due_float
                }
                return ValidationResult.create_invalid(ValidationType.TOTAL_AMOUNT_MISMATCH, message, details)
        except (ValueError, TypeError) as e:
            return ValidationResult.create_error(
                ValidationType.TOTAL_AMOUNT_MISMATCH, f"‚ùå L·ªói ƒë·ªãnh d·∫°ng s·ªë khi t√≠nh t·ªïng ti·ªÅn: {e}",
            )
        except Exception as e:
            return ValidationResult.create_error(
                ValidationType.TOTAL_AMOUNT_MISMATCH, f"‚ùå L·ªói kh√¥ng x√°c ƒë·ªãnh khi validation t·ªïng ti·ªÅn: {e}",
            )
    
    def validate_workflow_status(self, task_list: List[Dict], node_id: str, **kwargs) -> ValidationResult:
        """
        Validation tr·∫°ng th√°i workflow ƒë·ªÉ ph√°t hi·ªán node b·ªã thu h·ªìi.
        """
        try:
            target_node = next((task for task in task_list if task.get('node_id') == node_id), None)
            
            if not target_node:
                return ValidationResult.create_skipped(
                    ValidationType.WORKFLOW_STATUS,
                    f"‚ÑπÔ∏è B·ªè qua: Node {node_id[:8]}... kh√¥ng t√¨m th·∫•y trong danh s√°ch task"
                )
            
            current_status = target_node.get('status', 'UNKNOWN')
            problematic_statuses = ['REJECTED', 'CANCELED', 'WITHDRAWN']
            if current_status in problematic_statuses:
                return ValidationResult.create_invalid(
                    ValidationType.WORKFLOW_STATUS,
                    f"‚ö†Ô∏è C·∫¢NH B√ÅO: Node {node_id[:8]}... c√≥ tr·∫°ng th√°i {current_status} - c√≥ th·ªÉ ƒë√£ b·ªã thu h·ªìi ho·∫∑c t·ª´ ch·ªëi"
                )
            
            return ValidationResult.create_valid(
                ValidationType.WORKFLOW_STATUS,
                f"‚úÖ Node {node_id[:8]}... c√≥ tr·∫°ng th√°i b√¨nh th∆∞·ªùng: {current_status}"
            )
        except Exception as e:
            return ValidationResult.create_error(
                ValidationType.WORKFLOW_STATUS,
                f"‚ùå L·ªói ki·ªÉm tra tr·∫°ng th√°i workflow: {str(e)}"
            )
    
    def validate_field_consistency(self, form_data: List[Dict], **kwargs) -> ValidationResult:
        """
        Placeholder cho c√°c logic validation v·ªÅ t√≠nh nh·∫•t qu√°n c·ªßa c√°c tr∆∞·ªùng kh√°c.
        """
        return ValidationResult.create_valid(
            ValidationType.FIELD_CONSISTENCY,
            "‚úÖ Ki·ªÉm tra t√≠nh nh·∫•t qu√°n c√°c tr∆∞·ªùng th√†nh c√¥ng (placeholder)"
        )
    
    def run_validation(self, validation_type: ValidationType, **kwargs) -> ValidationResult:
        """
        Ch·∫°y m·ªôt quy t·∫Øc validation c·ª• th·ªÉ.
        """
        if validation_type in self.validation_rules:
            return self.validation_rules[validation_type](**kwargs)
        else:
            return ValidationResult.create_error(
                validation_type,
                f"‚ùå Lo·∫°i validation kh√¥ng x√°c ƒë·ªãnh: {validation_type}"
            )
    
    def run_all_validations(self, form_data: List[Dict], task_list: List[Dict], 
                           node_id: str) -> List[ValidationResult]:
        """
        Ch·∫°y t·∫•t c·∫£ c√°c validation rules ƒë√£ ƒë∆∞·ª£c ƒëƒÉng k√Ω.
        """
        print(f"üöÄ B·∫Øt ƒë·∫ßu ch·∫°y t·∫•t c·∫£ validation cho node {node_id[:8]}...")
        results = []
        
        for validation_type in self.validation_rules.keys():
            print(f"‚ñ∂Ô∏è ƒêang ch·∫°y: {validation_type.value}...")
            # S·ª≠ d·ª•ng extend ƒë·ªÉ x·ª≠ l√Ω vi·ªác m·ªôt rule c√≥ th·ªÉ tr·∫£ v·ªÅ nhi·ªÅu result
            validation_func = self.validation_rules[validation_type]
            
            # C·∫ßn ki·ªÉm tra xem h√†m c√≥ tr·∫£ v·ªÅ list hay kh√¥ng
            # V√¨ c√°c h√†m kh√°c v·∫´n tr·∫£ v·ªÅ 1 result ƒë∆°n l·∫ª
            result_or_list = validation_func(
                form_data=form_data,
                task_list=task_list,
                node_id=node_id
            )

            if isinstance(result_or_list, list):
                results.extend(result_or_list)
            else:
                results.append(result_or_list)

        invalid_count = sum(1 for r in results if not r.is_valid)
        print(f"üìà Ho√†n th√†nh validation: T√¨m th·∫•y {invalid_count} v·∫•n ƒë·ªÅ.")
        
        return results

validation_service = ValidationService()
============================================================

============================================================
FILE: project_complete_info.txt
============================================================
================================================================================
TH√îNG TIN D·ª∞ √ÅN HO√ÄN CH·ªàNH
================================================================================
Th·ªùi gian t·∫°o: 2025-10-03 14:17:39
Th∆∞ m·ª•c g·ªëc: d:\Atino\extension\webhook-server-approval
================================================================================

üìÅ C·∫§U TR√öC THU M·ª§C
--------------------------------------------------
‚îú‚îÄ‚îÄ üìÅ app/
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ api/
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ core/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÅ bootstrap/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ application.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÅ config/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ field_constants.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ node_config.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ settings.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÅ events/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ event_registry.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÅ infrastructure/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ cache_service.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ event_bus.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ lark_service.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÅ models/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ event.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ response.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ shared.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÅ routers/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ monitoring.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ webhook.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÅ utils/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ amount_detector.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ field_extractor.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ helpers.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ __init__.py
‚îÇ   ‚îî‚îÄ‚îÄ üìÅ domains/
‚îÇ       ‚îú‚îÄ‚îÄ üìÅ notification/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ üìÅ models/
‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ __init__.py
‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ notification.py
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ üìÅ services/
‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ __init__.py
‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ lark_webhook_service.py
‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ notification_coordinator.py
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ __init__.py
‚îÇ       ‚îú‚îÄ‚îÄ üìÅ qr_generation/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ üìÅ handlers/
‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ __init__.py
‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ qr_event_handler.py
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ üìÅ models/
‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ __init__.py
‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ qr.py
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ üìÅ routers/
‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ qr.py
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ üìÅ services/
‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ __init__.py
‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ amount_detector.py
‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ qr_processor.py
‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ vietqr_service.py
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ __init__.py
‚îÇ       ‚îú‚îÄ‚îÄ üìÅ validation/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ üìÅ handlers/
‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ __init__.py
‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ validation_event_handler.py
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ üìÅ models/
‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ __init__.py
‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ validation.py
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ üìÅ routers/
‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ notification.py
‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ validation.py
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ üìÅ services/
‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ __init__.py
‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ validation_service.py
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ __init__.py
‚îÇ       ‚îî‚îÄ‚îÄ üìÑ __init__.py
‚îú‚îÄ‚îÄ üìÑ .gitignore
‚îú‚îÄ‚îÄ üìÑ Dockerfile
‚îú‚îÄ‚îÄ üìÑ Get detail code.ipynb
‚îú‚îÄ‚îÄ üìÑ lark_events.csv
‚îú‚îÄ‚îÄ üìÑ project_complete_info.txt
‚îú‚îÄ‚îÄ üìÑ README.md
‚îî‚îÄ‚îÄ üìÑ requirements.txt


üìÑ DANH S√ÅCH T·∫§T C·∫¢ FILE
--------------------------------------------------
.gitignore (594 bytes)
app\core\__init__.py (376 bytes)
app\core\bootstrap\application.py (8435 bytes)
app\core\config\__init__.py (271 bytes)
app\core\config\field_constants.py (1232 bytes)
app\core\config\node_config.py (5382 bytes)
app\core\config\settings.py (3520 bytes)
app\core\events\event_registry.py (2702 bytes)
app\core\infrastructure\__init__.py (176 bytes)
app\core\infrastructure\cache_service.py (11934 bytes)
app\core\infrastructure\event_bus.py (5703 bytes)
app\core\infrastructure\lark_service.py (11949 bytes)
app\core\models\event.py (899 bytes)
app\core\models\response.py (1015 bytes)
app\core\models\shared.py (553 bytes)
app\core\routers\monitoring.py (1619 bytes)
app\core\routers\webhook.py (2919 bytes)
app\core\utils\__init__.py (332 bytes)
app\core\utils\amount_detector.py (10162 bytes)
app\core\utils\field_extractor.py (12805 bytes)
app\core\utils\helpers.py (2198 bytes)
app\domains\__init__.py (593 bytes)
app\domains\notification\__init__.py (262 bytes)
app\domains\notification\models\__init__.py (425 bytes)
app\domains\notification\models\notification.py (1578 bytes)
app\domains\notification\services\__init__.py (235 bytes)
app\domains\notification\services\lark_webhook_service.py (12787 bytes)
app\domains\notification\services\notification_coordinator.py (8726 bytes)
app\domains\qr_generation\__init__.py (251 bytes)
app\domains\qr_generation\handlers\__init__.py (82 bytes)
app\domains\qr_generation\handlers\qr_event_handler.py (6616 bytes)
app\domains\qr_generation\models\__init__.py (359 bytes)
app\domains\qr_generation\models\qr.py (1571 bytes)
app\domains\qr_generation\routers\qr.py (1789 bytes)
app\domains\qr_generation\services\__init__.py (214 bytes)
app\domains\qr_generation\services\amount_detector.py (15034 bytes)
app\domains\qr_generation\services\qr_processor.py (17581 bytes)
app\domains\qr_generation\services\vietqr_service.py (6971 bytes)
app\domains\validation\__init__.py (301 bytes)
app\domains\validation\handlers\__init__.py (106 bytes)
app\domains\validation\handlers\validation_event_handler.py (10972 bytes)
app\domains\validation\models\__init__.py (289 bytes)
app\domains\validation\models\validation.py (2871 bytes)
app\domains\validation\routers\notification.py (1283 bytes)
app\domains\validation\routers\validation.py (1756 bytes)
app\domains\validation\services\__init__.py (135 bytes)
app\domains\validation\services\validation_service.py (15465 bytes)
Dockerfile (1896 bytes)
Get detail code.ipynb (10463 bytes)
lark_events.csv (111947 bytes)
project_complete_info.txt (0 bytes)
README.md (7974 bytes)
requirements.txt (136 bytes)

T·ªïng c·ªông: 53 file

üíª N·ªòI DUNG T·∫§T C·∫¢ FILE CODE
================================================================================

============================================================
FILE: app\core\__init__.py
============================================================
"""
Core infrastructure exports
"""
from app.core.config import *
from app.core.infrastructure import *
from app.core.utils import *

__all__ = [
    # Configuration
    "settings", "NODE_CONFIG",
    
    # Infrastructure  
    "event_bus", "cache_service", "lark_service",
    
    # Utils
    "extract_instance_code", "get_event_type", "format_currency"
]

============================================================

============================================================
FILE: app\core\bootstrap\application.py
============================================================
import asyncio
from datetime import datetime
from app.core.events.event_registry import event_registry
from app.core.config.settings import settings


class ApplicationBootstrap:
    """
    Bootstrap to√†n b·ªô ·ª©ng d·ª•ng theo ki·∫øn tr√∫c DDD (Domain-Driven Design).
    
    L·ªõp n√†y ch·ªãu tr√°ch nhi·ªám kh·ªüi t·∫°o v√† c·∫•u h√¨nh t·∫•t c·∫£ c√°c th√†nh ph·∫ßn c·∫ßn thi·∫øt
    c·ªßa ·ª©ng d·ª•ng bao g·ªìm event handlers, infrastructure services v√† ki·ªÉm tra
    s·ª©c kh·ªèe h·ªá th·ªëng.
    
    Attributes:
        startup_time (datetime): Th·ªùi ƒëi·ªÉm b·∫Øt ƒë·∫ßu kh·ªüi t·∫°o ·ª©ng d·ª•ng
        is_initialized (bool): Tr·∫°ng th√°i kh·ªüi t·∫°o c·ªßa ·ª©ng d·ª•ng
    """
    
    def __init__(self):
        """Kh·ªüi t·∫°o ApplicationBootstrap v·ªõi tr·∫°ng th√°i ban ƒë·∫ßu."""
        self.startup_time = None
        self.is_initialized = False
        
    async def initialize(self):
        """
        Kh·ªüi t·∫°o to√†n b·ªô ·ª©ng d·ª•ng theo th·ª© t·ª± ∆∞u ti√™n.
        
        Qu√° tr√¨nh kh·ªüi t·∫°o bao g·ªìm:
        1. ƒêƒÉng k√Ω event handlers
        2. Kh·ªüi t·∫°o infrastructure services  
        3. Ki·ªÉm tra s·ª©c kh·ªèe h·ªá th·ªëng
        
        Raises:
            Exception: Khi c√≥ l·ªói trong qu√° tr√¨nh kh·ªüi t·∫°o
        """
        print("üöÄ B·∫Øt ƒë·∫ßu kh·ªüi t·∫°o ·ª©ng d·ª•ng...")
        self.startup_time = datetime.now()
        
        try:
            # 1. ƒêƒÉng k√Ω c√°c event handlers
            await self._register_event_handlers()
            
            # 2. Kh·ªüi t·∫°o c√°c infrastructure services
            await self._initialize_infrastructure()
            
            # 3. Ki·ªÉm tra s·ª©c kh·ªèe h·ªá th·ªëng
            await self._validate_system_health()
            
            # ƒê√°nh d·∫•u ·ª©ng d·ª•ng ƒë√£ kh·ªüi t·∫°o th√†nh c√¥ng
            self.is_initialized = True
            elapsed = (datetime.now() - self.startup_time).total_seconds()
            
            print(f"‚úÖ Kh·ªüi t·∫°o ·ª©ng d·ª•ng ho√†n t·∫•t trong {elapsed:.2f}s")
            
        except Exception as e:
            print(f"‚ùå Kh·ªüi t·∫°o ·ª©ng d·ª•ng th·∫•t b·∫°i: {e}")
            raise
    
    async def _register_event_handlers(self):
        """
        ƒêƒÉng k√Ω t·∫•t c·∫£ event handlers t·ª´ domain layer.
        
        Method n√†y s·ª≠ d·ª•ng event_registry ƒë·ªÉ t·ª± ƒë·ªông ƒëƒÉng k√Ω t·∫•t c·∫£
        handlers ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a trong c√°c domain modules.
        
        Raises:
            Exception: Khi kh√¥ng th·ªÉ ƒëƒÉng k√Ω event handlers
        """
        print("üìù ƒêang ƒëƒÉng k√Ω event handlers...")
        
        try:
            # G·ªçi registry ƒë·ªÉ ƒëƒÉng k√Ω t·∫•t c·∫£ domain handlers
            event_registry.register_domain_handlers()
            
            # L·∫•y th√¥ng tin tr·∫°ng th√°i ƒëƒÉng k√Ω ƒë·ªÉ log
            status = event_registry.get_registration_status()
            print(f"   ‚Ä¢ ƒê√£ ƒëƒÉng k√Ω {status['total_handlers']} handlers cho {status['total_event_types']} lo·∫°i event")
            
        except Exception as e:
            print(f"‚ùå ƒêƒÉng k√Ω event handlers th·∫•t b·∫°i: {e}")
            raise
    
    async def _initialize_infrastructure(self):
        """
        Kh·ªüi t·∫°o v√† ki·ªÉm tra c√°c infrastructure services.
        
        Bao g·ªìm:
        - Lark API service (k·∫øt n·ªëi ƒë·∫øn Lark/Feishu)
        - Cache service (Redis ho·∫∑c in-memory cache)
        - Notification service (webhook alerts)
        
        Raises:
            Exception: Khi kh√¥ng th·ªÉ kh·ªüi t·∫°o infrastructure services
        """
        print("üèóÔ∏è ƒêang kh·ªüi t·∫°o infrastructure services...")
        
        try:
            # Ki·ªÉm tra k·∫øt n·ªëi Lark API
            from app.core.infrastructure.lark_service import lark_service
            
            print("   ‚Ä¢ ƒêang ki·ªÉm tra k·∫øt n·ªëi Lark API...")
            token = await lark_service.get_access_token()
            if token:
                print("   ‚úÖ K·∫øt n·ªëi Lark API th√†nh c√¥ng")
            else:
                print("   ‚ö†Ô∏è K·∫øt n·ªëi Lark API th·∫•t b·∫°i - ki·ªÉm tra l·∫°i th√¥ng tin x√°c th·ª±c")
            
            # Kh·ªüi t·∫°o cache service
            from app.core.infrastructure.cache_service import cache_service
            print("   ‚Ä¢ Cache service ƒë√£ ƒë∆∞·ª£c kh·ªüi t·∫°o")
            print(f"   ‚Ä¢ Th·ªùi gian cache QR code: {settings.QR_CACHE_DURATION_MINUTES} ph√∫t")
            
            # Ki·ªÉm tra notification service n·∫øu ƒë∆∞·ª£c b·∫≠t
            if settings.ENABLE_VALIDATION_ALERTS:
                print("   ‚Ä¢ C·∫£nh b√°o validation ƒë√£ ƒë∆∞·ª£c b·∫≠t")
                if settings.LARK_WEBHOOK_URL:
                    print("   ‚úÖ Webhook URL ƒë√£ ƒë∆∞·ª£c c·∫•u h√¨nh")
                else:
                    print("   ‚ö†Ô∏è Ch∆∞a c·∫•u h√¨nh webhook URL")
            else:
                print("   ‚Ä¢ C·∫£nh b√°o validation ƒë√£ ƒë∆∞·ª£c t·∫Øt")
            
        except Exception as e:
            print(f"‚ùå Kh·ªüi t·∫°o infrastructure th·∫•t b·∫°i: {e}")
            raise
    
    async def _validate_system_health(self):
        """
        Ki·ªÉm tra s·ª©c kh·ªèe t·ªïng th·ªÉ c·ªßa h·ªá th·ªëng.
        
        Validates:
        - Event bus ho·∫°t ƒë·ªông b√¨nh th∆∞·ªùng
        - Node configuration ƒë√£ ƒë∆∞·ª£c load
        - Environment variables c·∫ßn thi·∫øt ƒë√£ ƒë∆∞·ª£c c·∫•u h√¨nh
        
        Raises:
            Exception: Khi ph√°t hi·ªán v·∫•n ƒë·ªÅ nghi√™m tr·ªçng v·ªõi h·ªá th·ªëng
        """
        print("üîç ƒêang ki·ªÉm tra s·ª©c kh·ªèe h·ªá th·ªëng...")
        
        try:
            # Ki·ªÉm tra event bus
            from app.core.infrastructure.event_bus import event_bus
            handler_count = len(event_bus.handlers.get("approval.instance.updated", []))
            print(f"   ‚Ä¢ Event bus: {handler_count} handlers ƒë√£ ƒëƒÉng k√Ω cho approval events")
            
            # Ki·ªÉm tra node configuration
            from app.core.config.node_config import NODE_CONFIG
            print(f"   ‚Ä¢ C·∫•u h√¨nh node: {len(NODE_CONFIG)} nodes ƒë√£ ƒë∆∞·ª£c c·∫•u h√¨nh")
            
            # Ki·ªÉm tra c√°c environment variables b·∫Øt bu·ªôc
            required_vars = ["LARK_APP_ID", "LARK_APP_SECRET"]
            missing_vars = []
            
            # Duy·ªát qua t·ª´ng bi·∫øn m√¥i tr∆∞·ªùng b·∫Øt bu·ªôc
            for var in required_vars:
                if not getattr(settings, var, None):
                    missing_vars.append(var)
            
            # B√°o c√°o k·∫øt qu·∫£ ki·ªÉm tra environment variables
            if missing_vars:
                print(f"   ‚ö†Ô∏è Thi·∫øu c√°c bi·∫øn m√¥i tr∆∞·ªùng: {', '.join(missing_vars)}")
            else:
                print("   ‚úÖ T·∫•t c·∫£ bi·∫øn m√¥i tr∆∞·ªùng b·∫Øt bu·ªôc ƒë·ªÅu c√≥")
            
            print("   ‚úÖ Ki·ªÉm tra s·ª©c kh·ªèe h·ªá th·ªëng ho√†n t·∫•t")
            
        except Exception as e:
            print(f"‚ùå Ki·ªÉm tra s·ª©c kh·ªèe h·ªá th·ªëng th·∫•t b·∫°i: {e}")
            raise
    
    def get_startup_info(self) -> dict:
        """
        L·∫•y th√¥ng tin chi ti·∫øt v·ªÅ qu√° tr√¨nh kh·ªüi ƒë·ªông ·ª©ng d·ª•ng.
        
        Returns:
            dict: Dictionary ch·ª©a th√¥ng tin startup bao g·ªìm:
                - startup_time: Th·ªùi ƒëi·ªÉm b·∫Øt ƒë·∫ßu kh·ªüi t·∫°o
                - is_initialized: Tr·∫°ng th√°i kh·ªüi t·∫°o
                - uptime_seconds: Th·ªùi gian ho·∫°t ƒë·ªông (gi√¢y)
                - event_handlers: Th√¥ng tin v·ªÅ event handlers ƒë√£ ƒëƒÉng k√Ω
                - architecture: Lo·∫°i ki·∫øn tr√∫c ƒë∆∞·ª£c s·ª≠ d·ª•ng
                - version: Phi√™n b·∫£n ·ª©ng d·ª•ng
        """
        return {
            "startup_time": self.startup_time.isoformat() if self.startup_time else None,
            "is_initialized": self.is_initialized,
            "uptime_seconds": (datetime.now() - self.startup_time).total_seconds() if self.startup_time else 0,
            "event_handlers": event_registry.get_registration_status(),
            "architecture": "DDD",
            "version": "2.0.0"
        }


app_bootstrap = ApplicationBootstrap()

============================================================

============================================================
FILE: app\core\config\__init__.py
============================================================
from .settings import settings
from .node_config import NODE_CONFIG, get_node_config, get_configured_node_ids
from .field_constants import FFN

__all__ = [
    "settings", 
    "NODE_CONFIG", 
    "get_node_config", 
    "get_configured_node_ids",
    "FFN"
]

============================================================

============================================================
FILE: app\core\config\field_constants.py
============================================================
# app/core/config/field_constants.py

class FormFieldNames:
    """
    Single Source of Truth for all Lark Approval form field names.
    T·∫≠p trung t·∫•t c·∫£ t√™n tr∆∞·ªùng c·ªßa form ph√™ duy·ªát Lark t·∫°i m·ªôt n∆°i duy nh·∫•t.
    """
    
    # === Tr∆∞·ªùng Ti·ªÅn T·ªá C·∫•p Cao (Top-level Amount Fields) ===
    ADVANCE_AMOUNT = "S·ªë ti·ªÅn t·∫°m ·ª©ng"
    PAYMENT_AMOUNT = "S·ªë ti·ªÅn thanh to√°n"
    REMAINING_PAYMENT_AMOUNT = "S·ªë ti·ªÅn c√≤n ph·∫£i thanh to√°n"
    TOTAL_PAYMENT_AMOUNT = "Total s·ªë ti·ªÅn thanh to√°n"

    # === Tr∆∞·ªùng Trong FieldList K·∫ø To√°n (Accounting FieldList Fields) ===
    ACCOUNTING_ADVANCE_INFO = "K·∫ø to√°n - Th√¥ng tin t·∫°m ·ª©ng"
    ACCOUNTING_PAYMENT_INFO = "K·∫ø to√°n - Th√¥ng tin thanh to√°n"
    EXPENDITURE_AMOUNT = "S·ªë ti·ªÅn chi" # D√πng chung cho c·∫£ t·∫°m ·ª©ng v√† thanh to√°n

    # === Tr∆∞·ªùng Th√¥ng Tin Ng√¢n H√†ng (Bank Information Fields) ===
    BANK_NAME = "Ng√¢n h√†ng"
    BANK_ACCOUNT_NUMBER = "S·ªë t√†i kho·∫£n ng√¢n h√†ng"
    BENEFICIARY_NAME = "T√™n ng∆∞·ªùi th·ª• h∆∞·ªüng"

# T·∫°o m·ªôt instance ƒë·ªÉ d·ªÖ d√†ng import v√† s·ª≠ d·ª•ng
# from app.core.config.field_constants import FFN
FFN = FormFieldNames()
============================================================

============================================================
FILE: app\core\config\node_config.py
============================================================
from .field_constants import FFN

# C·∫•u h√¨nh chi ti·∫øt cho t·ª´ng node trong approval workflow
NODE_CONFIG = {
    # Node tr∆∞·ªüng ph√≤ng duy·ªát - C√≥ th·ªÉ detect c·∫£ advance v√† payment (Kh√¥ng b·∫Øt ƒë∆∞·ª£c node submit, node n√†y lu√¥n l√† node ti·∫øp theo)
    "30e5338b60587c64c7cef5f6a7211ccb": {
        "name": "truong_phong_duyet",
        "type": "dual_detection",                   # Lo·∫°i node h·ªó tr·ª£ c·∫£ advance v√† payment
        "advance_field": FFN.ADVANCE_AMOUNT,        # T√™n field ch·ª©a s·ªë ti·ªÅn t·∫°m ·ª©ng
        "payment_field": FFN.PAYMENT_AMOUNT,        # T√™n field ch·ª©a s·ªë ti·ªÅn thanh to√°n
        "strategy": "detect_both_fields",           # Strategy t·ª± ƒë·ªông detect lo·∫°i QR d·ª±a tr√™n fields
        "required_status": "PENDING",               # Status c·∫ßn thi·∫øt ƒë·ªÉ trigger QR generation
        "description": "Tr∆∞·ªüng ph√≤ng duy·ªát - Auto detect advance/payment"
    },
    
    # Node thanh to√°n
    "f23535375a26847ef71c1cbf0755f246": {
        "name": "thanh_toan_sau_tam_ung", 
        "type": "payment_only",                          # Lo·∫°i node ch·ªâ x·ª≠ l√Ω payment
        "advance_field": None,                           # Kh√¥ng c√≥ field advance
        "payment_field": FFN.REMAINING_PAYMENT_AMOUNT,   # Field ch·ª©a s·ªë ti·ªÅn c·∫ßn thanh to√°n
        "strategy": "payment_field_only",                # Strategy ch·ªâ x·ª≠ l√Ω payment field
        "required_status": "APPROVED",                   # Node n√†y c·∫ßn status APPROVED
        
        # ƒêi·ªÅu ki·ªán b·ªï sung ƒë·ªÉ trigger QR generation
        "additional_conditions": [
            {
                "node_id": "ef83b231885a1a77658f32808a199764",  # Node ti·∫øp theo
                "required_status": "PENDING",                   # Node ti·∫øp theo ph·∫£i PENDING
                "description": "Node ti·∫øp theo ph·∫£i PENDING"    # M√¥ t·∫£ ƒëi·ªÅu ki·ªán
            }
        ],
        "description": "Thanh to√°n sau t·∫°m ·ª©ng - Payment only (trigger on APPROVED + next node PENDING)"
    }
}


def get_node_config(node_id: str) -> dict:
    """
    L·∫•y configuration chi ti·∫øt cho m·ªôt node_id c·ª• th·ªÉ.
    
    Args:
        node_id (str): Node ID c·∫ßn l·∫•y configuration
        
    Returns:
        dict: Dictionary ch·ª©a c·∫•u h√¨nh node bao g·ªìm:
            - name: T√™n node
            - type: Lo·∫°i node (dual_detection, payment_only, etc.)
            - advance_field: T√™n field ch·ª©a s·ªë ti·ªÅn t·∫°m ·ª©ng
            - payment_field: T√™n field ch·ª©a s·ªë ti·ªÅn thanh to√°n
            - strategy: Chi·∫øn l∆∞·ª£c x·ª≠ l√Ω (detect_both_fields, payment_field_only, etc.)
            - required_status: Status c·∫ßn thi·∫øt ƒë·ªÉ trigger
            - additional_conditions: C√°c ƒëi·ªÅu ki·ªán b·ªï sung (optional)
            - description: M√¥ t·∫£ node
        Tr·∫£ v·ªÅ None n·∫øu kh√¥ng t√¨m th·∫•y node_id
    """
    return NODE_CONFIG.get(node_id)


def get_node_strategy(node_id: str) -> str:
    """
    L·∫•y strategy x·ª≠ l√Ω c·ªßa m·ªôt node c·ª• th·ªÉ.
    
    Args:
        node_id (str): Node ID c·∫ßn l·∫•y strategy
        
    Returns:
        str: T√™n strategy c·ªßa node nh∆∞:
            - "detect_both_fields": T·ª± ƒë·ªông detect advance/payment
            - "payment_field_only": Ch·ªâ x·ª≠ l√Ω payment
            - "unknown": N·∫øu kh√¥ng t√¨m th·∫•y node ho·∫∑c strategy
    """
    config = get_node_config(node_id)
    return config.get("strategy", "unknown") if config else "unknown"


def print_node_config_summary():
    """
    In ra t√≥m t·∫Øt chi ti·∫øt c·ªßa NODE_CONFIG bao g·ªìm additional conditions.
    
    Function n√†y hi·ªÉn th·ªã th√¥ng tin t·ªïng quan v·ªÅ t·∫•t c·∫£ nodes ƒë∆∞·ª£c c·∫•u h√¨nh,
    bao g·ªìm strategy, fields, required status v√† c√°c ƒëi·ªÅu ki·ªán b·ªï sung.
    """
    print("üìã T√≥m t·∫Øt c·∫•u h√¨nh NODE_CONFIG:")
    
    # Duy·ªát qua t·ª´ng node trong configuration
    for node_id, config in NODE_CONFIG.items():
        required_status = config.get('required_status', 'PENDING')
        additional_conditions = config.get('additional_conditions', [])
        
        # Hi·ªÉn th·ªã th√¥ng tin c∆° b·∫£n c·ªßa node
        print(f"   ‚Ä¢ {node_id[:8]}... - {config['name']} ({config['strategy']})")
        print(f"     C√°c tr∆∞·ªùng: advance='{config['advance_field']}', payment='{config['payment_field']}'")
        print(f"     Status y√™u c·∫ßu: {required_status}")
        
        # Hi·ªÉn th·ªã c√°c ƒëi·ªÅu ki·ªán b·ªï sung n·∫øu c√≥
        if additional_conditions:
            print(f"     ƒêi·ªÅu ki·ªán b·ªï sung:")
            for condition in additional_conditions:
                condition_node_short = condition['node_id'][:8]
                condition_status = condition['required_status']
                print(f"       - {condition_node_short}... ph·∫£i c√≥ status {condition_status}")


def get_configured_node_ids():
    """
    L·∫•y danh s√°ch t·∫•t c·∫£ node IDs ƒë√£ ƒë∆∞·ª£c c·∫•u h√¨nh.
    
    Returns:
        List[str]: Danh s√°ch t·∫•t c·∫£ node IDs c√≥ trong NODE_CONFIG
    """
    return list(NODE_CONFIG.keys())


# Backward compatibility - Gi·ªØ l·∫°i t√™n c≈© ƒë·ªÉ kh√¥ng break existing code
ALLOWED_NODE_IDS = get_configured_node_ids()

============================================================

============================================================
FILE: app\core\config\settings.py
============================================================
import os
from typing import Optional


class Settings:
    """
    C·∫•u h√¨nh to√†n b·ªô ·ª©ng d·ª•ng t·ª´ environment variables v√† default values.
    
    Settings class qu·∫£n l√Ω t·∫•t c·∫£ c√°c c·∫•u h√¨nh c·∫ßn thi·∫øt cho ·ª©ng d·ª•ng bao g·ªìm:
    - FastAPI server configuration
    - Lark/Feishu API credentials v√† endpoints
    - VietQR service configuration
    - Webhook v√† notification settings
    - Cache v√† performance settings
    - File storage settings
    - Validation v√† alert settings
    
    T·∫•t c·∫£ settings c√≥ th·ªÉ ƒë∆∞·ª£c override b·∫±ng environment variables.
    """
    
    # ===== FASTAPI SERVER SETTINGS =====
    # C·∫•u h√¨nh cho FastAPI web server
    DEBUG: bool = os.getenv("DEBUG", "false").lower() == "true"  # B·∫≠t/t·∫Øt debug mode
    PORT: int = int(os.getenv("PORT", "8000"))                   # Port ƒë·ªÉ ch·∫°y server
    
    # ===== LARK/FEISHU API SETTINGS =====
    # Th√¥ng tin x√°c th·ª±c v√† endpoints cho Lark API
    LARK_APP_ID: str = os.getenv("LARK_APP_ID", "cli_a758ffaf41f8502f")
    LARK_APP_SECRET: str = os.getenv("LARK_APP_SECRET", "45Jsgm3TYfEwD2F67BH1LctlYEcCjZpH")
    
    # Base URL cho t·∫•t c·∫£ Lark API calls
    BASE_URL: str = "https://open.larksuite.com/open-apis"
    
    # Endpoint chuy√™n d·ª•ng cho upload file l√™n approval system
    APPROVAL_UPLOAD_URL: str = "https://www.larksuite.com/approval/openapi/v2/file/upload"
    
    # ===== VIETQR SERVICE SETTINGS =====
    # C·∫•u h√¨nh cho VietQR API ƒë·ªÉ generate QR codes
    VIETQR_TEMPLATE: str = "compact2"                           # Template layout cho QR code
    VIETQR_BASE_URL: str = "https://img.vietqr.io/image"       # Base URL c·ªßa VietQR service
    
    # ===== WEBHOOK & NOTIFICATION SETTINGS =====
    # C·∫•u h√¨nh webhook ƒë·ªÉ g·ª≠i notifications
    LARK_WEBHOOK_URL: str = os.getenv(
        "LARK_WEBHOOK_URL", 
        "https://open.larksuite.com/open-apis/bot/v2/hook/6a53a060-40d7-4716-9a90-970a6cbdaf64"
    )
    
    # B·∫≠t/t·∫Øt validation alerts qua webhook
    ENABLE_VALIDATION_ALERTS: bool = os.getenv("ENABLE_VALIDATION_ALERTS", "true").lower() == "true"

    # ===== CACHE & PERFORMANCE SETTINGS =====
    # C·∫•u h√¨nh cache ƒë·ªÉ t·ªëi ∆∞u performance v√† tr√°nh duplicate requests
    QR_CACHE_DURATION_MINUTES: int = 5      # Th·ªùi gian cache QR generation (ph√∫t)
    TOKEN_CACHE_BUFFER_SECONDS: int = 300   # Buffer time tr∆∞·ªõc khi token h·∫øt h·∫°n (5 ph√∫t)

    # ===== FILE STORAGE SETTINGS =====
    # C·∫•u h√¨nh file storage cho logging v√† data persistence
    EVENTS_FILE: str = "lark_events.csv"    # File l∆∞u tr·ªØ event logs
    
    # ===== USER & AUTHENTICATION SETTINGS =====
    # User ID m·∫∑c ƒë·ªãnh ƒë·ªÉ t·∫°o comments trong Lark approval
    DEFAULT_USER_ID: str = "cd11b141"
    
    # ===== VALIDATION & MONITORING SETTINGS =====
    # C·∫•u h√¨nh c√°c t√≠nh nƒÉng validation v√† monitoring (cho future extensions)
    
    # B·∫≠t/t·∫Øt validation s·ªë ti·ªÅn trong approval workflow
    ENABLE_AMOUNT_VALIDATION: bool = os.getenv("ENABLE_AMOUNT_VALIDATION", "true").lower() == "true"
    
    # B·∫≠t/t·∫Øt alerts cho workflow errors v√† anomalies
    ENABLE_WORKFLOW_ALERTS: bool = os.getenv("ENABLE_WORKFLOW_ALERTS", "true").lower() == "true"


# Global settings instance - s·ª≠ d·ª•ng trong to√†n b·ªô ·ª©ng d·ª•ng
# Import settings t·ª´ module n√†y ƒë·ªÉ truy c·∫≠p t·∫•t c·∫£ configuration
settings = Settings()

============================================================

============================================================
FILE: app\core\events\event_registry.py
============================================================
"""
Event Registry - Central registration for all domain event handlers
"""
from typing import Dict, List, Callable
from app.core.infrastructure.event_bus import event_bus

class EventRegistry:
    """Central registry for domain event handlers"""
    
    def __init__(self):
        self.registered_handlers: Dict[str, List[str]] = {}
    
    def register_handler(self, event_type: str, handler: Callable, domain: str = "core"):
        """Register a handler for an event type"""
        try:
            event_bus.subscribe(event_type, handler)
            
            # Track registration for monitoring
            if event_type not in self.registered_handlers:
                self.registered_handlers[event_type] = []
            
            handler_info = f"{domain}.{handler.__name__}"
            self.registered_handlers[event_type].append(handler_info)
            
            print(f"‚úÖ Registered {handler_info} for event: {event_type}")
            
        except Exception as e:
            print(f"‚ùå Failed to register handler {handler.__name__}: {e}")
    
    def register_domain_handlers(self):
        """Register all domain handlers"""
        print("üîß Registering domain event handlers...")
        
        try:
            # QR Generation Domain Handlers
            from app.domains.qr_generation.handlers import qr_event_handler
            self.register_handler(
                "approval.instance.updated", 
                qr_event_handler.handle_approval_event,
                "qr_generation"
            )
            
            # Validation Domain Handlers  
            from app.domains.validation.handlers import validation_event_handler
            self.register_handler(
                "approval.instance.updated",
                validation_event_handler.handle_approval_event, 
                "validation"
            )
            
            print(f"‚úÖ Successfully registered handlers for {len(self.registered_handlers)} event types")
            
        except Exception as e:
            print(f"‚ùå Error registering domain handlers: {e}")
            raise
    
    def get_registration_status(self) -> Dict:
        """Get current registration status"""
        total_handlers = sum(len(handlers) for handlers in self.registered_handlers.values())
        
        return {
            "total_event_types": len(self.registered_handlers),
            "total_handlers": total_handlers,
            "registrations": self.registered_handlers,
            "event_bus_handlers": len(event_bus.handlers)
        }

# Global registry instance
event_registry = EventRegistry()

============================================================

============================================================
FILE: app\core\infrastructure\__init__.py
============================================================
from .event_bus import event_bus
from .cache_service import cache_service
from .lark_service import lark_service

__all__ = ["event_bus", "cache_service", "lark_service"]

============================================================

============================================================
FILE: app\core\infrastructure\cache_service.py
============================================================
from datetime import datetime, timedelta
from typing import Dict, Optional


class CacheService:
    """
    Service qu·∫£n l√Ω cache cho QR code generation v√† validation alerts.
    
    CacheService gi√∫p tr√°nh tr√πng l·∫∑p b·∫±ng c√°ch cache th·ªùi ƒëi·ªÉm t·∫°o QR codes
    v√† g·ª≠i validation alerts. Service n√†y s·ª≠ d·ª•ng in-memory cache v·ªõi
    automatic expiration ƒë·ªÉ ti·∫øt ki·ªám b·ªô nh·ªõ.
    
    Attributes:
        qr_generation_cache (Dict[str, datetime]): Cache th·ªùi ƒëi·ªÉm t·∫°o QR codes
        validation_alert_cache (Dict[str, datetime]): Cache th·ªùi ƒëi·ªÉm g·ª≠i validation alerts
    """
    
    def __init__(self):
        """Kh·ªüi t·∫°o CacheService v·ªõi c√°c cache dictionary r·ªóng."""
        self.qr_generation_cache: Dict[str, datetime] = {}
        self.validation_alert_cache: Dict[str, datetime] = {}
    
    def generate_cache_key(self, instance_code: str, node_id: str, qr_type: str) -> str:
        """
        T·∫°o cache key unique cho QR code ƒë·ªÉ detect duplicates.
        
        Args:
            instance_code (str): M√£ instance c·ªßa approval workflow
            node_id (str): ID c·ªßa node trong workflow
            qr_type (str): Lo·∫°i QR code (payment, advance, etc.)
            
        Returns:
            str: Cache key format: {instance_code}_{short_node_id}_{qr_type}
        """
        # R√∫t ng·∫Øn node_id ƒë·ªÉ cache key kh√¥ng qu√° d√†i
        short_node_id = node_id[:8] if len(node_id) > 8 else node_id
        return f"{instance_code}_{short_node_id}_{qr_type}"

    def generate_validation_cache_key(self, instance_code: str, validation_type: str) -> str:
        """
        T·∫°o cache key cho validation alerts ƒë·ªÉ tr√°nh spam alerts.
        
        Args:
            instance_code (str): M√£ instance c·ªßa approval workflow
            validation_type (str): Lo·∫°i validation (amount_mismatch, workflow_error, etc.)
            
        Returns:
            str: Cache key format: validation_{instance_code}_{validation_type}
        """
        return f"validation_{instance_code}_{validation_type}"

    def is_qr_recently_generated(self, instance_code: str, node_id: str, qr_type: str, 
                               cache_duration_minutes: int = 5) -> bool:
        """
        Ki·ªÉm tra xem QR code ƒë√£ ƒë∆∞·ª£c t·∫°o trong kho·∫£ng th·ªùi gian g·∫ßn ƒë√¢y ch∆∞a.
        
        Args:
            instance_code (str): M√£ instance c·ªßa approval workflow
            node_id (str): ID c·ªßa node trong workflow
            qr_type (str): Lo·∫°i QR code
            cache_duration_minutes (int, optional): Th·ªùi gian cache t√≠nh b·∫±ng ph√∫t. M·∫∑c ƒë·ªãnh 5 ph√∫t.
            
        Returns:
            bool: True n·∫øu QR ƒë√£ ƒë∆∞·ª£c t·∫°o g·∫ßn ƒë√¢y, False n·∫øu ch∆∞a ho·∫∑c ƒë√£ h·∫øt h·∫°n
        """
        try:
            cache_key = self.generate_cache_key(instance_code, node_id, qr_type)
            
            # Ki·ªÉm tra xem cache key c√≥ t·ªìn t·∫°i kh√¥ng
            if cache_key not in self.qr_generation_cache:
                print(f"üÜï Cache miss: {cache_key} - ch∆∞a t·ª´ng t·∫°o QR")
                return False
            
            # T√≠nh th·ªùi gian ƒë√£ tr·∫£i qua k·ªÉ t·ª´ l·∫ßn t·∫°o QR cu·ªëi
            generated_time = self.qr_generation_cache[cache_key]
            current_time = datetime.now()
            time_diff = current_time - generated_time
            
            # N·∫øu ƒë√£ qu√° th·ªùi gian cache th√¨ x√≥a entry v√† return False
            if time_diff > timedelta(minutes=cache_duration_minutes):
                del self.qr_generation_cache[cache_key] 
                print(f"‚è∞ Cache ƒë√£ h·∫øt h·∫°n: {cache_key} ({time_diff.total_seconds()/60:.1f} ph√∫t tr∆∞·ªõc)")
                return False
            
            print(f"üîí Cache hit: {cache_key} - QR ƒë√£ t·∫°o {time_diff.total_seconds()/60:.1f} ph√∫t tr∆∞·ªõc")
            return True
            
        except Exception as e:
            print(f"‚ùå L·ªói khi ki·ªÉm tra cache: {e}")
            return False

    def is_validation_alert_recently_sent(self, instance_code: str, validation_type: str,
                                        cache_duration_minutes: int = 10) -> bool:
        """
        Ki·ªÉm tra xem validation alert ƒë√£ ƒë∆∞·ª£c g·ª≠i trong kho·∫£ng th·ªùi gian g·∫ßn ƒë√¢y ch∆∞a.
        
        Args:
            instance_code (str): M√£ instance c·ªßa approval workflow
            validation_type (str): Lo·∫°i validation error
            cache_duration_minutes (int, optional): Th·ªùi gian cache t√≠nh b·∫±ng ph√∫t. M·∫∑c ƒë·ªãnh 10 ph√∫t.
            
        Returns:
            bool: True n·∫øu alert ƒë√£ ƒë∆∞·ª£c g·ª≠i g·∫ßn ƒë√¢y, False n·∫øu ch∆∞a ho·∫∑c ƒë√£ h·∫øt h·∫°n
        """
        try:
            cache_key = self.generate_validation_cache_key(instance_code, validation_type)
            
            # Ki·ªÉm tra xem cache key c√≥ t·ªìn t·∫°i kh√¥ng
            if cache_key not in self.validation_alert_cache:
                print(f"üÜï Validation cache miss: {cache_key} - ch∆∞a t·ª´ng g·ª≠i alert")
                return False
            
            # T√≠nh th·ªùi gian ƒë√£ tr·∫£i qua k·ªÉ t·ª´ l·∫ßn g·ª≠i alert cu·ªëi
            sent_time = self.validation_alert_cache[cache_key]
            current_time = datetime.now()
            time_diff = current_time - sent_time
            
            # N·∫øu ƒë√£ qu√° th·ªùi gian cache th√¨ x√≥a entry v√† return False
            if time_diff > timedelta(minutes=cache_duration_minutes):
                del self.validation_alert_cache[cache_key]
                print(f"‚è∞ Validation cache ƒë√£ h·∫øt h·∫°n: {cache_key} ({time_diff.total_seconds()/60:.1f} ph√∫t tr∆∞·ªõc)")
                return False
            
            print(f"üîí Validation cache hit: {cache_key} - Alert ƒë√£ g·ª≠i {time_diff.total_seconds()/60:.1f} ph√∫t tr∆∞·ªõc")
            return True
            
        except Exception as e:
            print(f"‚ùå L·ªói khi ki·ªÉm tra validation cache: {e}")
            return False

    def mark_qr_as_generated(self, instance_code: str, node_id: str, qr_type: str):
        """
        ƒê√°nh d·∫•u QR code ƒë√£ ƒë∆∞·ª£c t·∫°o b·∫±ng c√°ch l∆∞u timestamp v√†o cache.
        
        Args:
            instance_code (str): M√£ instance c·ªßa approval workflow
            node_id (str): ID c·ªßa node trong workflow
            qr_type (str): Lo·∫°i QR code
        """
        try:
            cache_key = self.generate_cache_key(instance_code, node_id, qr_type)
            self.qr_generation_cache[cache_key] = datetime.now()
            
            print(f"üîí ƒê√£ ƒë√°nh d·∫•u QR ƒë∆∞·ª£c t·∫°o: {cache_key}")
            print(f"üìä K√≠ch th∆∞·ªõc QR Cache: {len(self.qr_generation_cache)} entries")
            
        except Exception as e:
            print(f"‚ùå L·ªói khi ƒë√°nh d·∫•u cache: {e}")

    def mark_validation_alert_as_sent(self, instance_code: str, validation_type: str):
        """
        ƒê√°nh d·∫•u validation alert ƒë√£ ƒë∆∞·ª£c g·ª≠i b·∫±ng c√°ch l∆∞u timestamp v√†o cache.
        
        Args:
            instance_code (str): M√£ instance c·ªßa approval workflow
            validation_type (str): Lo·∫°i validation error
        """
        try:
            cache_key = self.generate_validation_cache_key(instance_code, validation_type)
            self.validation_alert_cache[cache_key] = datetime.now()
            
            print(f"üîí ƒê√£ ƒë√°nh d·∫•u validation alert ƒë∆∞·ª£c g·ª≠i: {cache_key}")
            print(f"üìä K√≠ch th∆∞·ªõc Validation Cache: {len(self.validation_alert_cache)} entries")
            
        except Exception as e:
            print(f"‚ùå L·ªói khi ƒë√°nh d·∫•u validation cache: {e}")

    def get_cache_status(self) -> Dict:
        """
        L·∫•y tr·∫°ng th√°i chi ti·∫øt c·ªßa t·∫•t c·∫£ cache (QR v√† validation).
        
        Returns:
            Dict: Dictionary ch·ª©a th√¥ng tin chi ti·∫øt v·ªÅ:
                - qr_cache: Th√¥ng tin v·ªÅ QR generation cache
                - validation_cache: Th√¥ng tin v·ªÅ validation alert cache
                - current_time: Th·ªùi gian hi·ªán t·∫°i
        """
        try:
            current_time = datetime.now()
            
            # T√≠nh to√°n tr·∫°ng th√°i QR Cache
            active_qr_cache = {}
            for cache_key, generated_time in self.qr_generation_cache.items():
                time_diff = current_time - generated_time
                minutes_ago = time_diff.total_seconds() / 60
                
                active_qr_cache[cache_key] = {
                    'generated_at': generated_time.isoformat(),
                    'minutes_ago': round(minutes_ago, 1),
                    'will_expire_in_minutes': max(0, 5 - minutes_ago)  # 5 ph√∫t cho QR
                }
            
            # T√≠nh to√°n tr·∫°ng th√°i Validation Cache
            active_validation_cache = {}
            for cache_key, sent_time in self.validation_alert_cache.items():
                time_diff = current_time - sent_time
                minutes_ago = time_diff.total_seconds() / 60
                
                active_validation_cache[cache_key] = {
                    'sent_at': sent_time.isoformat(),
                    'minutes_ago': round(minutes_ago, 1),
                    'will_expire_in_minutes': max(0, 10 - minutes_ago)  # 10 ph√∫t cho validation
                }
            
            return {
                'qr_cache': {
                    'total_cached_qr': len(self.qr_generation_cache),
                    'active_cache': active_qr_cache,
                    'cache_duration_minutes': 5
                },
                'validation_cache': {
                    'total_cached_alerts': len(self.validation_alert_cache),
                    'active_cache': active_validation_cache,
                    'cache_duration_minutes': 10
                },
                'current_time': current_time.isoformat()
            }
            
        except Exception as e:
            return {"error": str(e)}

    def clear_cache(self) -> Dict:
        """
        X√≥a t·∫•t c·∫£ cache entries (c·∫£ QR v√† validation) v√† tr·∫£ v·ªÅ th√¥ng tin chi ti·∫øt.
        
        Returns:
            Dict: Dictionary ch·ª©a:
                - message: Th√¥ng b√°o k·∫øt qu·∫£
                - cleared_qr_keys: Danh s√°ch QR cache keys ƒë√£ b·ªã x√≥a
                - cleared_validation_keys: Danh s√°ch validation cache keys ƒë√£ b·ªã x√≥a
                - current_cache_sizes: K√≠ch th∆∞·ªõc cache hi·ªán t·∫°i (sau khi clear)
        """
        try:
            # L∆∞u l·∫°i th√¥ng tin tr∆∞·ªõc khi clear
            old_qr_count = len(self.qr_generation_cache)
            old_validation_count = len(self.validation_alert_cache)
            old_qr_keys = list(self.qr_generation_cache.keys())
            old_validation_keys = list(self.validation_alert_cache.keys())
            
            # Clear t·∫•t c·∫£ cache
            self.qr_generation_cache.clear()
            self.validation_alert_cache.clear()
            
            return {
                'message': f'ƒê√£ x√≥a th√†nh c√¥ng {old_qr_count} QR cache entries v√† {old_validation_count} validation cache entries',
                'cleared_qr_keys': old_qr_keys,
                'cleared_validation_keys': old_validation_keys,
                'current_qr_cache_size': len(self.qr_generation_cache),
                'current_validation_cache_size': len(self.validation_alert_cache)
            }
            
        except Exception as e:
            return {"success": False, "error": str(e)}


cache_service = CacheService()

============================================================

============================================================
FILE: app\core\infrastructure\event_bus.py
============================================================
# app/services/event_bus.py
import asyncio
from typing import Dict, List, Callable, Any
from datetime import datetime


class EventBus:
    """
    Event Bus system ƒë·ªÉ qu·∫£n l√Ω v√† ph√¢n ph·ªëi events trong ·ª©ng d·ª•ng.
    
    EventBus cho ph√©p c√°c component ƒëƒÉng k√Ω handlers cho c√°c lo·∫°i event kh√°c nhau
    v√† publish events ƒë·ªÉ th·ª±c thi t·∫•t c·∫£ handlers ƒë√£ ƒëƒÉng k√Ω m·ªôt c√°ch b·∫•t ƒë·ªìng b·ªô.
    
    Attributes:
        handlers (Dict[str, List[Callable]]): Dictionary ch·ª©a danh s√°ch handlers cho t·ª´ng event type
        event_history (List[Dict]): L·ªãch s·ª≠ t·∫•t c·∫£ events ƒë√£ ƒë∆∞·ª£c publish
    """
    
    def __init__(self):
        """Kh·ªüi t·∫°o EventBus v·ªõi handlers v√† event history r·ªóng."""
        self.handlers: Dict[str, List[Callable]] = {}
        self.event_history: List[Dict] = []
    
    def subscribe(self, event_type: str, handler: Callable):
        """
        ƒêƒÉng k√Ω handler cho m·ªôt event type c·ª• th·ªÉ.
        
        Args:
            event_type (str): Lo·∫°i event c·∫ßn l·∫Øng nghe
            handler (Callable): H√†m x·ª≠ l√Ω s·∫Ω ƒë∆∞·ª£c g·ªçi khi event ƒë∆∞·ª£c publish
            
        Note:
            Handler ph·∫£i l√† async function v√† nh·∫≠n event_data l√†m tham s·ªë
        """
        # Kh·ªüi t·∫°o danh s√°ch handlers cho event type n·∫øu ch∆∞a t·ªìn t·∫°i
        if event_type not in self.handlers:
            self.handlers[event_type] = []
        
        # Th√™m handler v√†o danh s√°ch
        self.handlers[event_type].append(handler)
        print(f"üìù ƒê√£ ƒëƒÉng k√Ω handler cho event: {event_type}")
    
    async def publish(self, event_type: str, event_data: Dict[str, Any]):
        """
        Publish event v√† th·ª±c thi t·∫•t c·∫£ handlers ƒë√£ ƒëƒÉng k√Ω song song.
        
        Args:
            event_type (str): Lo·∫°i event c·∫ßn publish
            event_data (Dict[str, Any]): D·ªØ li·ªáu s·∫Ω ƒë∆∞·ª£c truy·ªÅn cho c√°c handlers
            
        Returns:
            List: Danh s√°ch k·∫øt qu·∫£ t·ª´ t·∫•t c·∫£ handlers (bao g·ªìm c·∫£ exceptions)
        """
        print(f"üì¢ ƒêang publish event: {event_type}")
        
        # L∆∞u l·ªãch s·ª≠ event
        event_record = {
            "timestamp": datetime.now().isoformat(),
            "event_type": event_type,
            "data": event_data,
            "handlers_count": len(self.handlers.get(event_type, []))
        }
        self.event_history.append(event_record)
        
        # Th·ª±c thi t·∫•t c·∫£ handlers ƒë·ªìng th·ªùi
        if event_type in self.handlers:
            tasks = []
            
            # T·∫°o task cho m·ªói handler
            for handler in self.handlers[event_type]:
                task = asyncio.create_task(
                    self._run_handler_safe(handler, event_data)
                )
                tasks.append(task)
            
            # ƒê·ª£i t·∫•t c·∫£ handlers ho√†n th√†nh (k·ªÉ c·∫£ khi c√≥ l·ªói)
            results = await asyncio.gather(*tasks, return_exceptions=True)
            
            # Ghi log k·∫øt qu·∫£ t·ª´ m·ªói handler
            for i, result in enumerate(results):
                handler_name = self.handlers[event_type][i].__name__
                if isinstance(result, Exception):
                    print(f"‚ùå Handler {handler_name} th·∫•t b·∫°i: {result}")
                else:
                    print(f"‚úÖ Handler {handler_name} ho√†n th√†nh: {result}")
            
            return results
        else:
            print(f"‚ö†Ô∏è Kh√¥ng c√≥ handler n√†o ƒë∆∞·ª£c ƒëƒÉng k√Ω cho event: {event_type}")
            return []
    
    async def _run_handler_safe(self, handler: Callable, event_data: Dict) -> Dict:
        """
        Th·ª±c thi handler v·ªõi error handling v√† monitoring th·ªùi gian.
        
        Args:
            handler (Callable): Handler function c·∫ßn th·ª±c thi
            event_data (Dict): D·ªØ li·ªáu event ƒë∆∞·ª£c truy·ªÅn cho handler
            
        Returns:
            Dict: Th√¥ng tin k·∫øt qu·∫£ bao g·ªìm success status, result/error, v√† th·ªùi gian th·ª±c thi
        """
        handler_name = handler.__name__
        try:
            print(f"üöÄ B·∫Øt ƒë·∫ßu th·ª±c thi handler: {handler_name}")
            start_time = datetime.now()
            
            # G·ªçi handler (ph·∫£i l√† async function)
            result = await handler(event_data)
            
            # T√≠nh th·ªùi gian th·ª±c thi
            end_time = datetime.now()
            duration = (end_time - start_time).total_seconds()
            
            return {
                "handler": handler_name,
                "success": True,
                "result": result,
                "duration_seconds": duration
            }
            
        except Exception as e:
            print(f"‚ùå Handler {handler_name} g·∫∑p l·ªói: {e}")
            return {
                "handler": handler_name,
                "success": False,
                "error": str(e),
                "duration_seconds": 0
            }
    
    def get_event_history(self, limit: int = 50) -> List[Dict]:
        """
        L·∫•y l·ªãch s·ª≠ c√°c events ƒë√£ ƒë∆∞·ª£c publish.
        
        Args:
            limit (int, optional): S·ªë l∆∞·ª£ng events g·∫ßn nh·∫•t c·∫ßn l·∫•y. M·∫∑c ƒë·ªãnh l√† 50.
            
        Returns:
            List[Dict]: Danh s√°ch c√°c event records theo th·ª© t·ª± th·ªùi gian (m·ªõi nh·∫•t cu·ªëi)
        """
        return self.event_history[-limit:]


event_bus = EventBus()

============================================================

============================================================
FILE: app\core\infrastructure\lark_service.py
============================================================
import requests
import json
from datetime import datetime
from typing import Optional, Dict
from app.core.config.settings import settings


class LarkService:
    """
    Service t∆∞∆°ng t√°c v·ªõi Lark/Feishu API ƒë·ªÉ qu·∫£n l√Ω approval instances.
    
    LarkService cung c·∫•p c√°c ch·ª©c nƒÉng ch√≠nh:
    - X√°c th·ª±c v√† qu·∫£n l√Ω access tokens v·ªõi caching
    - L·∫•y th√¥ng tin approval instances
    - Upload h√¨nh ·∫£nh l√™n Lark
    - T·∫°o comments v·ªõi attachments
    
    Attributes:
        access_token_cache (Dict): Cache l∆∞u tr·ªØ access token v√† th·ªùi gian h·∫øt h·∫°n
    """
    
    def __init__(self):
        """Kh·ªüi t·∫°o LarkService v·ªõi token cache r·ªóng."""
        self.access_token_cache = {"token": None, "expires_at": None}
    
    async def get_access_token(self) -> Optional[str]:
        """
        L·∫•y access token t·ª´ LarkSuite API v·ªõi caching mechanism.
        
        Method n√†y s·∫Ω s·ª≠ d·ª•ng cached token n·∫øu c√≤n hi·ªáu l·ª±c, otherwise
        s·∫Ω g·ªçi API ƒë·ªÉ l·∫•y token m·ªõi v√† cache l·∫°i.
        
        Returns:
            Optional[str]: Access token n·∫øu th√†nh c√¥ng, None n·∫øu th·∫•t b·∫°i
        """
        current_time = datetime.now().timestamp()
        
        # Ki·ªÉm tra xem token ƒë√£ cache c√≤n hi·ªáu l·ª±c kh√¥ng
        if (self.access_token_cache["token"] and 
            self.access_token_cache["expires_at"] and 
            current_time < self.access_token_cache["expires_at"]):
            return self.access_token_cache["token"]
        
        try:
            # G·ªçi API ƒë·ªÉ l·∫•y tenant access token m·ªõi
            url = f"{settings.BASE_URL}/auth/v3/tenant_access_token/internal"
            payload = {
                "app_id": settings.LARK_APP_ID,
                "app_secret": settings.LARK_APP_SECRET
            }
            
            response = requests.post(url, json=payload, timeout=10)
            data = response.json()
            
            # Ki·ªÉm tra response t·ª´ API
            if data.get("code") == 0:
                token = data["tenant_access_token"]
                expires_in = data.get("expire", 7200)  # M·∫∑c ƒë·ªãnh 2 ti·∫øng
                
                # Cache token v·ªõi buffer time ƒë·ªÉ tr√°nh token h·∫øt h·∫°n gi·ªØa ch·ª´ng
                self.access_token_cache["token"] = token
                self.access_token_cache["expires_at"] = current_time + expires_in - settings.TOKEN_CACHE_BUFFER_SECONDS
                
                print(f"‚úÖ L·∫•y access token th√†nh c√¥ng")
                return token
            else:
                print(f"‚ùå L·∫•y token th·∫•t b·∫°i: {data}")
                return None
                
        except Exception as e:
            print(f"‚ùå L·ªói khi l·∫•y token: {e}")
            return None

    async def get_approval_instance(self, instance_code: str, access_token: str) -> Optional[Dict]:
        """
        L·∫•y th√¥ng tin chi ti·∫øt c·ªßa approval instance t·ª´ Lark API.
        
        Args:
            instance_code (str): M√£ ƒë·ªãnh danh c·ªßa approval instance
            access_token (str): Access token ƒë·ªÉ x√°c th·ª±c API call
            
        Returns:
            Optional[Dict]: Th√¥ng tin instance n·∫øu th√†nh c√¥ng, None n·∫øu th·∫•t b·∫°i
        """
        try:
            url = f"{settings.BASE_URL}/approval/v4/instances/{instance_code}"
            headers = {"Authorization": f"Bearer {access_token}"}
            
            print(f"üîç ƒêang l·∫•y th√¥ng tin instance: {instance_code}")
            response = requests.get(url, headers=headers, timeout=10)
            
            # Ki·ªÉm tra HTTP status code
            if response.status_code != 200:
                print(f"‚ùå L·ªói HTTP khi g·ªçi API: {response.status_code}")
                return None
                
            api_response = response.json()
            
            # Ki·ªÉm tra Lark API response code
            if api_response.get("code") != 0:
                print(f"‚ùå L·ªói Lark API response: {api_response}")
                return None
                
            return api_response
            
        except Exception as e:
            print(f"‚ùå L·ªói khi l·∫•y th√¥ng tin approval instance: {e}")
            return None

    async def upload_image_to_approval(self, image_buffer, filename: str, access_token: str) -> Dict:
        """
        Upload h√¨nh ·∫£nh l√™n Lark Approval system ƒë·ªÉ s·ª≠ d·ª•ng trong comments.
        
        Args:
            image_buffer: Buffer ch·ª©a d·ªØ li·ªáu h√¨nh ·∫£nh (bytes)
            filename (str): T√™n file c·ªßa h√¨nh ·∫£nh
            access_token (str): Access token ƒë·ªÉ x√°c th·ª±c API call
            
        Returns:
            Dict: Dictionary ch·ª©a:
                - success (bool): Tr·∫°ng th√°i upload
                - file_code (str): M√£ file t·ª´ Lark (n·∫øu success)  
                - file_url (str): URL file t·ª´ Lark (n·∫øu success)
                - error (str): Th√¥ng b√°o l·ªói (n·∫øu failed)
        """
        try:
            # Reset buffer position v·ªÅ ƒë·∫ßu ƒë·ªÉ ƒë·ªçc t·ª´ beginning
            image_buffer.seek(0)
            
            # Chu·∫©n b·ªã multipart form data cho upload
            files = {
                'name': (None, filename),
                'type': (None, 'image'),
                'content': (filename, image_buffer, 'image/png')
            }
            
            headers = {
                'Authorization': f'Bearer {access_token}'
            }
            
            print(f"üì§ ƒêang upload h√¨nh ·∫£nh: {filename}")
            response = requests.post(settings.APPROVAL_UPLOAD_URL, files=files, headers=headers)
            
            # X·ª≠ l√Ω response t·ª´ upload API
            if response.status_code == 200:
                data = response.json()
                if data.get('code') == 0:
                    file_code = data['data']['code']
                    file_url = data['data']['url']
                    print(f'‚úÖ Upload h√¨nh ·∫£nh th√†nh c√¥ng! File code: {file_code}')
                    return {
                        'success': True,
                        'file_code': file_code,
                        'file_url': file_url
                    }
                else:
                    error_msg = f"L·ªói API: {data.get('msg')} (code: {data.get('code')})"
                    print(f'‚ùå Upload th·∫•t b·∫°i: {error_msg}')
                    return {'success': False, 'error': error_msg}
            else:
                error_msg = f"L·ªói HTTP: {response.status_code}"
                print(f'‚ùå Upload th·∫•t b·∫°i: {error_msg}')
                return {'success': False, 'error': error_msg}
                
        except Exception as e:
            error_msg = f"Exception: {str(e)}"
            print(f"‚ùå L·ªói upload: {error_msg}")
            return {'success': False, 'error': error_msg}

    async def create_enhanced_comment_with_image(self, instance_code: str, file_url: str, file_code: str, 
                                               filename: str, qr_type: str, amount: int, node_name: str,
                                               access_token: str, user_id: str = None) -> Dict:
        """
        T·∫°o comment v·ªõi h√¨nh ·∫£nh QR code v√† th√¥ng tin chi ti·∫øt.
        
        Args:
            instance_code (str): M√£ instance c·ªßa approval workflow
            file_url (str): URL c·ªßa file ƒë√£ upload
            file_code (str): Code c·ªßa file t·ª´ Lark system
            filename (str): T√™n file h√¨nh ·∫£nh
            qr_type (str): Lo·∫°i QR ('advance' ho·∫∑c 'payment')
            amount (int): S·ªë ti·ªÅn c·ªßa QR code
            node_name (str): T√™n node trong workflow
            access_token (str): Access token ƒë·ªÉ x√°c th·ª±c
            user_id (str, optional): User ID th·ª±c hi·ªán comment
            
        Returns:
            Dict: Dictionary ch·ª©a:
                - success (bool): Tr·∫°ng th√°i t·∫°o comment
                - comment_id (str): ID c·ªßa comment ƒë∆∞·ª£c t·∫°o (n·∫øu success)
                - error (str): Th√¥ng b√°o l·ªói (n·∫øu failed)
        """
        try:
            # S·ª≠ d·ª•ng default user ID n·∫øu kh√¥ng ƒë∆∞·ª£c cung c·∫•p
            if user_id is None:
                user_id = settings.DEFAULT_USER_ID
                
            create_comment_url = f'{settings.BASE_URL}/approval/v4/instances/{instance_code}/comments'
            
            # Parameters cho API call
            params = {
                "user_id": user_id,
                "user_id_type": "user_id"
            }
            
            # T·∫°o text hi·ªÉn th·ªã cho QR type
            qr_type_display = {
                'advance': 'T·∫†M ·ª®NG',
                'payment': 'THANH TO√ÅN'
            }
            
            # T·∫°o n·ªôi dung comment v·ªõi th√¥ng tin chi ti·∫øt
            comment_text = f"""üè¶ M√£ VietQR {qr_type_display.get(qr_type, qr_type.upper())}
üí∞ S·ªë ti·ªÅn: {amount:,} VND"""

            # ∆Ø·ªõc t√≠nh k√≠ch th∆∞·ªõc file (rough estimate)
            try:
                file_size = len(filename) * 100  # ∆Ø·ªõc t√≠nh d·ª±a tr√™n ƒë·ªô d√†i filename
            except:
                file_size = 50000  # Gi√° tr·ªã m·∫∑c ƒë·ªãnh

            # T·∫°o content data v·ªõi text v√† file attachment
            content_data = {
                "text": comment_text,
                "files": [{
                    "url": file_url,
                    "fileSize": file_size,
                    "title": filename,
                    "type": "image",
                    "extra": file_code
                }]
            }
            
            # Request body v·ªõi JSON content
            request_body = {
                "content": json.dumps(content_data, ensure_ascii=False)
            }
            
            headers_comment = {
                'Authorization': f'Bearer {access_token}',
                'Content-Type': 'application/json'
            }
            
            print(f"üì§ ƒêang t·∫°o enhanced comment cho instance: {instance_code}")
            print(f"   N·ªôi dung: {comment_text.replace(chr(10), ' | ')}")
            
            # G·ªçi API ƒë·ªÉ t·∫°o comment
            response = requests.post(
                create_comment_url, 
                params=params,
                json=request_body, 
                headers=headers_comment
            )
            
            # X·ª≠ l√Ω response t·ª´ comment API
            if response.status_code == 200:
                comment_result = response.json()
                if comment_result.get('code') == 0:
                    comment_id = comment_result.get("data", {}).get("comment_id", "N/A")
                    print(f'‚úÖ T·∫°o enhanced comment th√†nh c√¥ng! Comment ID: {comment_id}')
                    return {'success': True, 'comment_id': comment_id}
                else:
                    error_msg = f"L·ªói API: {comment_result.get('msg')} (code: {comment_result.get('code')})"
                    print(f'‚ùå T·∫°o comment th·∫•t b·∫°i: {error_msg}')
                    return {'success': False, 'error': error_msg}
            else:
                error_msg = f"L·ªói HTTP: {response.status_code}"
                print(f'‚ùå T·∫°o comment th·∫•t b·∫°i: {error_msg}')
                return {'success': False, 'error': error_msg}
                
        except Exception as e:
            error_msg = f"Exception: {str(e)}"
            print(f"‚ùå L·ªói t·∫°o enhanced comment: {error_msg}")
            return {'success': False, 'error': error_msg}


lark_service = LarkService()

============================================================

============================================================
FILE: app\core\models\event.py
============================================================
from pydantic import BaseModel
from typing import Optional, Dict, Any
from datetime import datetime

class EventHeader(BaseModel):
    event_id: Optional[str] = None
    event_type: Optional[str] = None
    create_time: Optional[str] = None
    token: Optional[str] = None
    tenant_key: Optional[str] = None
    app_id: Optional[str] = None

class EventBody(BaseModel):
    instance_code: Optional[str] = None
    type: Optional[str] = None
    object: Optional[Dict[str, Any]] = None

class LarkEvent(BaseModel):
    schema: Optional[str] = None
    header: Optional[EventHeader] = None
    event: Optional[EventBody] = None
    type: Optional[str] = None  # For URL verification
    challenge: Optional[str] = None  # For URL verification

class EventRecord(BaseModel):
    timestamp: datetime
    event_type: str
    instance_code: Optional[str]
    raw_event: str

============================================================

============================================================
FILE: app\core\models\response.py
============================================================
from pydantic import BaseModel
from typing import Optional, Dict, Any, List

class APIResponse(BaseModel):
    success: bool
    message: Optional[str] = None
    data: Optional[Dict[str, Any]] = None
    error: Optional[str] = None

class UploadResult(BaseModel):
    success: bool
    file_code: Optional[str] = None
    file_url: Optional[str] = None
    error: Optional[str] = None

class CommentResult(BaseModel):
    success: bool
    comment_id: Optional[str] = None
    error: Optional[str] = None

class QRGenerationResult(BaseModel):
    success: bool
    qr_type: Optional[str] = None
    amount: Optional[float] = None
    field_used: Optional[str] = None
    node_name: Optional[str] = None
    comment_id: Optional[str] = None
    error: Optional[str] = None
    processing_info: Optional[Dict[str, Any]] = None

class CacheStatus(BaseModel):
    total_cached_qr: int
    active_cache: Dict[str, Dict[str, Any]]
    cache_duration_minutes: int
    current_time: str

============================================================

============================================================
FILE: app\core\models\shared.py
============================================================
from pydantic import BaseModel
from typing import Optional, List, Dict, Any

class FormField(BaseModel):
    name: Optional[str] = None
    type: Optional[str] = None
    value: Optional[Any] = None

class TaskInfo(BaseModel):
    node_id: Optional[str] = None
    status: Optional[str] = None
    task_id: Optional[str] = None
    node_name: Optional[str] = None

class ApprovalInstance(BaseModel):
    instance_code: str
    status: Optional[str] = None
    form: Optional[str] = None
    task_list: Optional[List[TaskInfo]] = None

============================================================

============================================================
FILE: app\core\routers\monitoring.py
============================================================
from fastapi import APIRouter
from app.core.infrastructure.event_bus import event_bus
from app.core.bootstrap.application import app_bootstrap

router = APIRouter()

@router.get("/system/health")
async def get_system_health():
    """System health check v·ªõi DDD architecture"""
    return {
        "status": "healthy" if app_bootstrap.is_initialized else "initializing",
        "application": app_bootstrap.get_startup_info(),
        "event_system": {
            "total_event_types": len(event_bus.handlers),
            "registered_events": list(event_bus.handlers.keys()),
            "total_handlers": sum(len(handlers) for handlers in event_bus.handlers.values())
        }
    }

@router.get("/events/history")
async def get_event_history(limit: int = 50):
    """Event processing history"""
    return {
        "recent_events": event_bus.get_event_history(limit),
        "handlers": {
            event_type: [handler.__name__ for handler in handlers]
            for event_type, handlers in event_bus.handlers.items()
        }
    }

@router.post("/events/test/{instance_code}")
async def test_event_processing(instance_code: str):
    """Test event processing system"""
    event_data = {
        "instance_code": instance_code,
        "event_type": "test_event",
        "timestamp": "manual_test"
    }
    
    results = await event_bus.publish("approval.instance.updated", event_data)
    
    return {
        "test_instance": instance_code,
        "handlers_executed": len(results),
        "results": results,
        "architecture": "DDD"
    }

============================================================

============================================================
FILE: app\core\routers\webhook.py
============================================================
from fastapi import APIRouter, Request
from fastapi.responses import JSONResponse
from app.core.infrastructure.event_bus import event_bus
from app.core.utils.helpers import save_event_to_csv, get_event_type, extract_instance_code
from app.core.config.settings import settings

router = APIRouter()

@router.post("/webhook")
async def handle_lark_webhook(request: Request):
    """
    X·ª≠ l√Ω webhook t·ª´ Lark v·ªõi ki·∫øn tr√∫c DDD

    Ch·ª©c nƒÉng ch√≠nh:
    - Nh·∫≠n v√† x·ª≠ l√Ω c√°c s·ª± ki·ªán webhook t·ª´ Lark
    - X√°c th·ª±c URL verification cho webhook setup
    - L∆∞u tr·ªØ t·∫•t c·∫£ events v√†o file CSV ƒë·ªÉ audit
    - X·ª≠ l√Ω c√°c s·ª± ki·ªán ph√™ duy·ªát qua event bus pattern
    - Tr·∫£ v·ªÅ response ph√π h·ª£p cho t·ª´ng lo·∫°i event

    Args:
        request (Request): HTTP request ch·ª©a webhook data t·ª´ Lark

    Returns:
        JSONResponse: 
            - ƒê·ªëi v·ªõi URL verification: {"challenge": "..."}
            - ƒê·ªëi v·ªõi events th√†nh c√¥ng: {"status": "success", "architecture": "DDD"}
            - ƒê·ªëi v·ªõi l·ªói: {"error": "..."} v·ªõi status 500
    """
    try:
        data = await request.json()
        print(f"üì® Nh·∫≠n ƒë∆∞·ª£c webhook: {get_event_type(data)}")

        # X·ª≠ l√Ω x√°c th·ª±c URL khi setup webhook
        if data.get("type") == "url_verification":
            print("üîê ƒêang x·ª≠ l√Ω URL verification")
            return JSONResponse(content={"challenge": data.get("challenge")})

        print("üíæ ƒêang l∆∞u event v√†o CSV...")
        await save_event_to_csv(data, settings.EVENTS_FILE)

        # X·ª≠ l√Ω c√°c s·ª± ki·ªán ph√™ duy·ªát th√¥ng qua event bus
        event_type = get_event_type(data)
        if "approval" in event_type.lower():
            instance_code = extract_instance_code(data)
            if instance_code:
                print(f"üîç ƒêang x·ª≠ l√Ω instance ph√™ duy·ªát: {instance_code}")

                # Ph√°t h√†nh event qua event bus - s·∫Ω k√≠ch ho·∫°t t·∫•t c·∫£ handlers ƒë√£ ƒëƒÉng k√Ω
                print("üì° ƒêang ph√°t h√†nh event qua event bus...")
                await event_bus.publish("approval.instance.updated", {
                    "instance_code": instance_code,
                    "event_type": event_type,
                    "timestamp": data.get("header", {}).get("create_time"),
                    "raw_data": data
                })
                print("‚úÖ ƒê√£ ph√°t h√†nh event th√†nh c√¥ng")
            else:
                print("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y instance code trong event ph√™ duy·ªát")

        print("üéâ X·ª≠ l√Ω webhook ho√†n t·∫•t")
        return JSONResponse(content={"status": "success", "architecture": "DDD"})

    except Exception as e:
        print(f"‚ùå L·ªói khi x·ª≠ l√Ω webhook: {e}")
        return JSONResponse(content={"error": str(e)}, status_code=500)
============================================================

============================================================
FILE: app\core\utils\__init__.py
============================================================
from .helpers import extract_instance_code, get_event_type, format_currency, get_short_node_id
from .field_extractor import FieldExtractor
from .amount_detector import AmountDetector

__all__ = [
    "extract_instance_code", "get_event_type", "format_currency", "get_short_node_id",
    "FieldExtractor", "AmountDetector"
]

============================================================

============================================================
FILE: app\core\utils\amount_detector.py
============================================================
from typing import Dict, List, Optional
from app.core.config.node_config import get_node_config
from app.core.utils.field_extractor import FieldExtractor

class AmountDetector:
    def __init__(self):
        self.field_extractor = FieldExtractor()
    
    def detect_available_amount_fields(self, form_data: List[Dict], node_config: Dict = None) -> Dict:
        """
        Scan form data ƒë·ªÉ t√¨m amount fields theo config c·ªßa node
        
        Args:
            form_data (list): Form data t·ª´ API response
            node_config (dict): Node configuration (optional)
            
        Returns:
            dict: Detection results v·ªõi c√°c fields v√† values
        """
        try:
            # S·ª≠ d·ª•ng config t·ª´ node thay v√¨ hardcode
            if node_config:
                advance_field = node_config.get('advance_field')
                payment_field = node_config.get('payment_field')
            else:
                # Fallback cho backward compatibility
                advance_field = "S·ªë ti·ªÅn t·∫°m ·ª©ng"
                payment_field = "S·ªë ti·ªÅn thanh to√°n"
            
            # Extract c·∫£ 2 fields (ch·ªâ khi field name kh√¥ng ph·∫£i None)
            advance_value = self.field_extractor.extract_field_value(form_data, advance_field) if advance_field else None
            payment_value = self.field_extractor.extract_field_value(form_data, payment_field) if payment_field else None
            
            # Debug: t√¨m t·∫•t c·∫£ fields c√≥ ch·ª©a "ti·ªÅn" ho·∫∑c "amount" 
            all_amount_fields = self.field_extractor.get_amount_fields(form_data)
            
            result = {
                'advance_amount': advance_value,
                'payment_amount': payment_value,
                'advance_field_found': advance_value is not None,
                'payment_field_found': payment_value is not None,
                'all_amount_fields': all_amount_fields,
                'fields_used': {
                    'advance_field': advance_field,
                    'payment_field': payment_field
                }
            }
            
            print(f"üí∞ Field detection results:")
            if advance_field:
                print(f"   - {advance_field}: {'‚úÖ ' + str(advance_value) if advance_value else '‚ùå Not found'}")
            else:
                print(f"   - Advance field: ‚ùå Not configured")
                
            if payment_field:
                print(f"   - {payment_field}: {'‚úÖ ' + str(payment_value) if payment_value else '‚ùå Not found'}")
            else:
                print(f"   - Payment field: ‚ùå Not configured")
                
            print(f"   - All amount fields: {list(all_amount_fields.keys())}")
            
            return result
            
        except Exception as e:
            print(f"‚ùå Error detecting amount fields: {e}")
            return {
                'advance_amount': None,
                'payment_amount': None,
                'advance_field_found': False,
                'payment_field_found': False,
                'all_amount_fields': {},
                'fields_used': {'advance_field': None, 'payment_field': None},
                'error': str(e)
            }
    
    def determine_qr_type_by_fields(self, field_detection_result: Dict) -> Dict:
        """
        Quy·∫øt ƒë·ªãnh QR type d·ª±a tr√™n fields c√≥ gi√° tr·ªã
        
        Args:
            field_detection_result (dict): K·∫øt qu·∫£ t·ª´ detect_available_amount_fields()
            
        Returns:
            dict: QR type decision result
        """
        try:
            advance_found = field_detection_result.get('advance_field_found', False)
            payment_found = field_detection_result.get('payment_field_found', False)
            advance_amount = field_detection_result.get('advance_amount')
            payment_amount = field_detection_result.get('payment_amount')

            fields_used = field_detection_result.get('fields_used', {})
            advance_field_name = fields_used.get('advance_field', 'S·ªë ti·ªÅn t·∫°m ·ª©ng')
            payment_field_name = fields_used.get('payment_field', 'S·ªë ti·ªÅn thanh to√°n')

            print(f"üéØ Determining QR type: advance={advance_found}, payment={payment_found}")
            
            # Logic priority: advance tr∆∞·ªõc, sau ƒë√≥ payment
            if advance_found and advance_amount:
                try:
                    amount_value = float(advance_amount)
                    if amount_value > 0:
                        return {
                            'qr_type': 'advance',
                            'amount': amount_value,
                            'field_used': advance_field_name,
                            'reason': 'Found valid advance amount'
                        }
                except (ValueError, TypeError):
                    print(f"‚ö†Ô∏è Invalid advance amount: {advance_amount}")
            
            if payment_found and payment_amount:
                try:
                    amount_value = float(payment_amount)
                    if amount_value > 0:
                        return {
                            'qr_type': 'payment', 
                            'amount': amount_value,
                            'field_used': payment_field_name,
                            'reason': 'Found valid payment amount'
                        }
                except (ValueError, TypeError):
                    print(f"‚ö†Ô∏è Invalid payment amount: {payment_amount}")
            
            # Kh√¥ng t√¨m th·∫•y field h·ª£p l·ªá
            return {
                'qr_type': 'none',
                'amount': None,
                'field_used': None,
                'reason': f'No valid amount found (advance_found={advance_found}, payment_found={payment_found})'
            }
            
        except Exception as e:
            print(f"‚ùå Error determining QR type: {e}")
            return {
                'qr_type': 'none',
                'amount': None,
                'field_used': None,
                'reason': f'Error: {str(e)}'
            }
    
    def get_amount_and_type_for_node(self, node_id: str, form_data: List[Dict]) -> Dict:
        """
        L·∫•y amount v√† QR type cho m·ªôt node c·ª• th·ªÉ d·ª±a tr√™n strategy c·ªßa node ƒë√≥
        
        Args:
            node_id (str): Node ID
            form_data (list): Form data t·ª´ API
            
        Returns:
            dict: Processing result v·ªõi success, qr_type, amount, etc.
        """
        try:
            node_config = get_node_config(node_id)
            if not node_config:
                return {
                    'success': False,
                    'qr_type': 'none',
                    'error': f'Node {node_id} not found in configuration'
                }
            
            strategy = node_config['strategy']
            node_name = node_config['name']
            
            print(f"üîç Processing node: {node_name} (strategy: {strategy})")
            
            # Detect available fields
            field_detection = self.detect_available_amount_fields(form_data, node_config)
            
            if strategy == "detect_both_fields":
                # Dual detection: c√≥ th·ªÉ l√† advance ho·∫∑c payment
                qr_decision = self.determine_qr_type_by_fields(field_detection)
                
                return {
                    'success': qr_decision['qr_type'] != 'none',
                    'qr_type': qr_decision['qr_type'],
                    'amount': qr_decision['amount'],
                    'field_used': qr_decision['field_used'],
                    'node_strategy': strategy,
                    'reason': f"Dual detection result: {qr_decision['reason']}",
                    'field_detection': field_detection
                }
                
            elif strategy == "payment_field_only":
                # Payment only: ch·ªâ check payment field
                payment_amount = field_detection.get('payment_amount')
                payment_found = field_detection.get('payment_field_found', False)
                payment_field_name = node_config.get('payment_field')

                if payment_found and payment_amount:
                    try:
                        amount_value = float(payment_amount)
                        if amount_value > 0:
                            return {
                                'success': True,
                                'qr_type': 'payment',
                                'amount': amount_value,
                                'field_used': payment_field_name,
                                'node_strategy': strategy,
                                'reason': 'Payment-only strategy: found valid payment amount',
                                'field_detection': field_detection
                            }
                    except (ValueError, TypeError):
                        pass
                
                return {
                    'success': False,
                    'qr_type': 'none',
                    'amount': None,
                    'field_used': None,
                    'node_strategy': strategy,
                    'reason': f'Payment-only strategy: no valid payment amount (found={payment_found}, value={payment_amount})',
                    'field_detection': field_detection
                }
            
            else:
                return {
                    'success': False,
                    'qr_type': 'none',
                    'error': f'Unknown strategy: {strategy}'
                }
                
        except Exception as e:
            print(f"‚ùå Error processing node {node_id}: {e}")
            return {
                'success': False,
                'qr_type': 'none',
                'error': str(e)
            }

============================================================

============================================================
FILE: app\core\utils\field_extractor.py
============================================================
from typing import List, Dict, Any, Optional

class FieldExtractor:
    def extract_field_value(self, form_data: List[Dict], field_name: str, debug: bool = False) -> Optional[Any]:
        """
        Enhanced version: Tr√≠ch xu·∫•t gi√° tr·ªã c·ªßa m·ªôt field t·ª´ form data v·ªõi better error handling
        
        Args:
            form_data (list): Form data t·ª´ API
            field_name (str): T√™n field c·∫ßn t√¨m
            debug (bool): In debug info
            
        Returns:
            Gi√° tr·ªã field ho·∫∑c None n·∫øu kh√¥ng t√¨m th·∫•y
        """
        try:
            if debug:
                print(f"üîç Searching for field: '{field_name}'")
                
            # Search in top-level fields
            for field in form_data:
                if field.get('name') == field_name:
                    value = field.get('value')
                    if debug:
                        print(f"‚úÖ Found '{field_name}' in top-level: {value}")
                    return value
                
                # Search in nested fieldList
                if field.get('type') == 'fieldList' and 'value' in field:
                    field_list_values = field['value']
                    if isinstance(field_list_values, list):
                        for field_group in field_list_values:
                            if isinstance(field_group, list):
                                for sub_field in field_group:
                                    if isinstance(sub_field, dict) and sub_field.get('name') == field_name:
                                        value = sub_field.get('value')
                                        if debug:
                                            print(f"‚úÖ Found '{field_name}' in fieldList: {value}")
                                        return value
            
            if debug:
                print(f"‚ùå Field '{field_name}' not found")
                print("Available fields:", [f.get('name') for f in form_data if f.get('name')])
                
            return None
            
        except Exception as e:
            print(f"‚ùå Error extracting field '{field_name}': {e}")
            return None

    def get_all_field_names(self, form_data: List[Dict]) -> List[str]:
        """
        L·∫•y t·∫•t c·∫£ field names t·ª´ form data
        
        Args:
            form_data: Form data t·ª´ API
            
        Returns:
            List[str]: Danh s√°ch t√™n fields
        """
        field_names = []
        
        try:
            for field in form_data:
                field_name = field.get('name')
                if field_name:
                    field_names.append(field_name)
                
                # Check nested fieldList
                if field.get('type') == 'fieldList' and 'value' in field:
                    field_list_values = field['value']
                    if isinstance(field_list_values, list):
                        for field_group in field_list_values:
                            if isinstance(field_group, list):
                                for sub_field in field_group:
                                    if isinstance(sub_field, dict):
                                        sub_field_name = sub_field.get('name')
                                        if sub_field_name:
                                            field_names.append(sub_field_name)
        except Exception as e:
            print(f"‚ùå Error getting field names: {e}")
        
        return list(set(field_names))  # Remove duplicates

    def get_amount_fields(self, form_data: List[Dict]) -> Dict[str, Any]:
        """
        T√¨m t·∫•t c·∫£ fields c√≥ ch·ª©a "ti·ªÅn" ho·∫∑c "amount"
        
        Args:
            form_data: Form data t·ª´ API
            
        Returns:
            Dict[str, Any]: Dict v·ªõi field name l√† key, value l√† gi√° tr·ªã
        """
        amount_fields = {}
        
        try:
            for field in form_data:
                field_name = field.get('name', '').lower()
                if 'ti·ªÅn' in field_name or 'amount' in field_name:
                    amount_fields[field.get('name')] = field.get('value')
        except Exception as e:
            print(f"‚ùå Error getting amount fields: {e}")
        
        return amount_fields

    def extract_field_from_fieldlist(self, form_data: List[Dict], fieldlist_name: str, 
                                target_field_name: str, debug: bool = False) -> Optional[Any]:
        """
        Tr√≠ch xu·∫•t gi√° tr·ªã ƒë·∫ßu ti√™n c·ªßa m·ªôt field t·ª´ b√™n trong m·ªôt fieldList c·ª• th·ªÉ.
        
        H√†m n√†y ch·ªâ tr·∫£ v·ªÅ gi√° tr·ªã ƒë·∫ßu ti√™n t√¨m th·∫•y. ƒê·ªÉ l·∫•y t·∫•t c·∫£ gi√° tr·ªã,
        s·ª≠ d·ª•ng `extract_all_values_from_fieldlist`.
        
        Args:
            form_data: Form data t·ª´ API
            fieldlist_name: T√™n fieldList container (vd: "K·∫ø to√°n - Th√¥ng tin t·∫°m ·ª©ng")  
            target_field_name: T√™n field c·∫ßn t√¨m (vd: "S·ªë ti·ªÅn chi")
            debug: In debug info
            
        Returns:
            Gi√° tr·ªã field ho·∫∑c None n·∫øu kh√¥ng t√¨m th·∫•y
        """
        try:
            if debug:
                print(f"üîç Searching for first '{target_field_name}' in fieldList '{fieldlist_name}'")
                
            if not fieldlist_name or not target_field_name:
                if debug: print("‚ùå Invalid parameters: fieldlist_name and target_field_name required")
                return None
                
            for field in form_data:
                if field.get('name') == fieldlist_name and field.get('type') == 'fieldList':
                    field_list_values = field.get('value', [])
                    if debug: print(f"üìã Found fieldList '{fieldlist_name}' with {len(field_list_values)} items")
                    
                    for field_group in field_list_values:
                        if isinstance(field_group, list):
                            for sub_field in field_group:
                                if isinstance(sub_field, dict) and sub_field.get('name') == target_field_name:
                                    value = sub_field.get('value')
                                    if debug: print(f"‚úÖ Found first '{target_field_name}' = {value}")
                                    return value
                    
                    if debug: print(f"‚ùå Field '{target_field_name}' not found in fieldList")
                    return None
            
            if debug:
                print(f"‚ùå fieldList '{fieldlist_name}' not found")
                available = [f.get('name') for f in form_data if f.get('type') == 'fieldList']
                print(f"Available fieldLists: {available}")
            return None
            
        except Exception as e:
            print(f"‚ùå Error extracting field from fieldList: {e}")
            return None
            
    def extract_all_values_from_fieldlist(self, form_data: List[Dict], fieldlist_name: str, 
                                          target_field_name: str, debug: bool = False) -> List[Any]:
        """
        ‚úÖ M·ªöI: Tr√≠ch xu·∫•t T·∫§T C·∫¢ c√°c gi√° tr·ªã c·ªßa m·ªôt field t·ª´ T·∫§T C·∫¢ c√°c d√≤ng trong m·ªôt fieldList.
        
        H·ªØu √≠ch khi c·∫ßn t√≠nh t·ªïng c√°c gi√° tr·ªã trong m·ªôt danh s√°ch, v√≠ d·ª• nh∆∞ t·ªïng "S·ªë ti·ªÅn chi"
        t·ª´ nhi·ªÅu l·∫ßn t·∫°m ·ª©ng c·ªßa k·∫ø to√°n.
        
        Args:
            form_data: Form data t·ª´ API.
            fieldlist_name: T√™n c·ªßa fieldList container (v√≠ d·ª•: "K·∫ø to√°n - Th√¥ng tin t·∫°m ·ª©ng").
            target_field_name: T√™n c·ªßa field c·∫ßn tr√≠ch xu·∫•t gi√° tr·ªã (v√≠ d·ª•: "S·ªë ti·ªÅn chi").
            debug: B·∫≠t/t·∫Øt in th√¥ng tin g·ª° l·ªói.
            
        Returns:
            List[Any]: M·ªôt danh s√°ch ch·ª©a t·∫•t c·∫£ c√°c gi√° tr·ªã t√¨m th·∫•y. Tr·∫£ v·ªÅ list r·ªóng n·∫øu kh√¥ng t√¨m th·∫•y g√¨.
        """
        extracted_values = []
        try:
            if debug:
                print(f"üîç Searching for ALL '{target_field_name}' values in fieldList '{fieldlist_name}'")

            for field in form_data:
                if field.get('name') == fieldlist_name and field.get('type') == 'fieldList':
                    field_list_values = field.get('value', [])
                    if debug:
                        print(f"üìã Found fieldList '{fieldlist_name}' with {len(field_list_values)} rows.")
                    
                    # Duy·ªát qua t·ª´ng d√≤ng (field_group) trong fieldList
                    for i, field_group in enumerate(field_list_values):
                        if isinstance(field_group, list):
                            # Duy·ªát qua t·ª´ng tr∆∞·ªùng (sub_field) trong d√≤ng
                            for sub_field in field_group:
                                if isinstance(sub_field, dict) and sub_field.get('name') == target_field_name:
                                    value = sub_field.get('value')
                                    extracted_values.append(value)
                                    if debug:
                                        print(f"   ‚úÖ Row {i+1}: Found value '{value}'")
                    
                    # Sau khi duy·ªát xong, kh√¥ng c·∫ßn t√¨m n·ªØa
                    if debug:
                        print(f"üìä Total values found: {len(extracted_values)}")
                    return extracted_values
            
            if debug:
                print(f"‚ùå FieldList '{fieldlist_name}' not found in form data.")
            return extracted_values

        except Exception as e:
            print(f"‚ùå Error extracting all values from fieldList: {e}")
            return extracted_values

    def extract_fields_by_prefix(self, form_data: List[Dict], prefix: str, debug: bool = False) -> Dict[str, Any]:
        """
        ‚úÖ M·ªöI: Tr√≠ch xu·∫•t t·∫•t c·∫£ c√°c tr∆∞·ªùng c√≥ t√™n b·∫Øt ƒë·∫ßu b·∫±ng m·ªôt ti·ªÅn t·ªë (prefix) cho tr∆∞·ªõc.
        
        H·ªØu √≠ch ƒë·ªÉ t√¨m c√°c tr∆∞·ªùng ƒë·ªông nh∆∞ "S·ªë ti·ªÅn t·∫°m ·ª©ng l·∫ßn 1:", "S·ªë ti·ªÅn t·∫°m ·ª©ng l·∫ßn 2:",...
        
        Args:
            form_data: Form data t·ª´ API.
            prefix: Ti·ªÅn t·ªë d√πng ƒë·ªÉ t√¨m ki·∫øm (v√≠ d·ª•: "S·ªë ti·ªÅn t·∫°m ·ª©ng l·∫ßn").
            debug: B·∫≠t/t·∫Øt in th√¥ng tin g·ª° l·ªói.
            
        Returns:
            Dict[str, Any]: M·ªôt dictionary v·ªõi key l√† t√™n ƒë·∫ßy ƒë·ªß c·ªßa tr∆∞·ªùng v√† value l√† gi√° tr·ªã c·ªßa n√≥.
        """
        extracted_fields = {}
        try:
            if debug:
                print(f"üîç Searching for all fields with prefix: '{prefix}'")
            
            # Duy·ªát qua t·∫•t c·∫£ c√°c tr∆∞·ªùng ·ªü m·ªçi c·∫•p ƒë·ªô
            for field in form_data:
                field_name = field.get('name')
                
                # Ki·ªÉm tra tr∆∞·ªùng ·ªü c·∫•p cao nh·∫•t
                if field_name and field_name.startswith(prefix):
                    value = field.get('value')
                    extracted_fields[field_name] = value
                    if debug:
                        print(f"   ‚úÖ Found top-level field: '{field_name}' = {value}")
                
                # Ki·ªÉm tra c√°c tr∆∞·ªùng l·ªìng trong fieldList
                if field.get('type') == 'fieldList' and 'value' in field:
                    field_list_values = field.get('value', [])
                    if isinstance(field_list_values, list):
                        for field_group in field_list_values:
                            if isinstance(field_group, list):
                                for sub_field in field_group:
                                    sub_field_name = sub_field.get('name')
                                    if sub_field_name and sub_field_name.startswith(prefix):
                                        value = sub_field.get('value')
                                        extracted_fields[sub_field_name] = value
                                        if debug:
                                            print(f"   ‚úÖ Found nested field: '{sub_field_name}' = {value}")
            
            if debug:
                print(f"üìä Total fields found with prefix: {len(extracted_fields)}")
            return extracted_fields

        except Exception as e:
            print(f"‚ùå Error extracting fields by prefix '{prefix}': {e}")
            return extracted_fields
============================================================

============================================================
FILE: app\core\utils\helpers.py
============================================================
from typing import Optional, Dict, Any
from datetime import datetime
import pandas as pd
import json
import os

def extract_instance_code(event_data: Dict) -> Optional[str]:
    """Tr√≠ch xu·∫•t instance_code t·ª´ event"""
    try:
        event_body = event_data.get("event", {})
        if "instance_code" in event_body:
            return event_body["instance_code"]
            
        if "object" in event_body and "instance_code" in event_body["object"]:
            return event_body["object"]["instance_code"]
            
        return None
    except:
        return None

def get_event_type(event_data: Dict) -> str:
    """L·∫•y event type"""
    try:
        if "header" in event_data:
            return event_data["header"].get("event_type", "unknown")
        
        if "event" in event_data and "type" in event_data["event"]:
            return event_data["event"]["type"]
            
        return event_data.get("type", "unknown")
    except:
        return "unknown"

async def save_event_to_csv(event_data: Dict, events_file: str = "lark_events.csv"):
    """L∆∞u event v√†o CSV"""
    try:
        row_data = {
            "timestamp": datetime.now().isoformat(),
            "event_type": get_event_type(event_data),
            "instance_code": extract_instance_code(event_data),
            "raw_event": json.dumps(event_data, ensure_ascii=False)
        }
        
        df = pd.DataFrame([row_data])
        
        if os.path.exists(events_file):
            df.to_csv(events_file, mode='a', header=False, index=False, encoding='utf-8')
        else:
            df.to_csv(events_file, mode='w', header=True, index=False, encoding='utf-8')
            
        print(f"‚úÖ Event saved to {events_file}")
        
    except Exception as e:
        print(f"‚ùå Error saving event: {e}")

def format_currency(amount: float) -> str:
    """Format s·ªë ti·ªÅn theo ƒë·ªãnh d·∫°ng VND"""
    return f"{amount:,} VND"

def get_short_node_id(node_id: str, length: int = 8) -> str:
    """Get short version of node ID for display"""
    return node_id[:length] + "..." if len(node_id) > length else node_id

============================================================

============================================================
FILE: app\domains\__init__.py
============================================================
"""
Domain package exports
"""
from app.domains.qr_generation import *
from app.domains.validation import *
from app.domains.notification import *

__all__ = [
    # QR Generation Domain
    "QRRequest", "QRResponse", "QRType", 
    "qr_service", "qr_event_handler",
    
    # Validation Domain  
    "ValidationResult", "ValidationResponse", "ValidationType",
    "validation_service", "validation_event_handler",
    
    # Notification Domain
    "NotificationResult", "NotificationType", "NotificationChannel",
    "notification_coordinator", "lark_webhook_service"
]

============================================================

============================================================
FILE: app\domains\notification\__init__.py
============================================================
# app/domains/notification/__init__.py
from .models import *
from .services import *

__all__ = [
    # Models
    "NotificationType", "NotificationResult", "NotificationRequest",
    # Services
    "lark_webhook_service", "notification_coordinator"
]

============================================================

============================================================
FILE: app\domains\notification\models\__init__.py
============================================================
from .notification import (
    NotificationType,
    NotificationChannel,
    NotificationPriority,
    NotificationRequest,
    NotificationResult,
    ValidationAlertRequest,
    CustomAlertRequest
)

__all__ = [
    "NotificationType",
    "NotificationChannel",
    "NotificationPriority",
    "NotificationRequest", 
    "NotificationResult",
    "ValidationAlertRequest",
    "CustomAlertRequest"
]

============================================================

============================================================
FILE: app\domains\notification\models\notification.py
============================================================
from pydantic import BaseModel
from typing import Optional, List, Dict, Any
from enum import Enum

class NotificationType(str, Enum):
    VALIDATION_ALERT = "validation_alert"
    CUSTOM_ALERT = "custom_alert"
    SERVICE_ERROR = "service_error"
    SYSTEM_NOTIFICATION = "system_notification"

class NotificationChannel(str, Enum):
    LARK_WEBHOOK = "lark_webhook"
    EMAIL = "email"
    SMS = "sms"

class NotificationPriority(str, Enum):
    LOW = "low"
    NORMAL = "normal"
    HIGH = "high"
    URGENT = "urgent"

class NotificationRequest(BaseModel):
    notification_type: NotificationType
    channel: NotificationChannel
    title: str
    message: str
    instance_code: Optional[str] = None
    priority: NotificationPriority = NotificationPriority.NORMAL
    metadata: Optional[Dict[str, Any]] = None

class NotificationResult(BaseModel):
    success: bool
    notification_type: NotificationType
    channel: NotificationChannel
    instance_code: Optional[str] = None
    sent_at: Optional[str] = None
    cached: bool = False
    cache_hit: bool = False
    error: Optional[str] = None
    metadata: Optional[Dict[str, Any]] = None

class ValidationAlertRequest(BaseModel):
    instance_code: str
    serial_number: Optional[str] = None
    validation_errors: List[str]
    priority: NotificationPriority = NotificationPriority.HIGH

class CustomAlertRequest(BaseModel):
    title: str
    message: str
    instance_code: Optional[str] = None
    priority: NotificationPriority = NotificationPriority.NORMAL

============================================================

============================================================
FILE: app\domains\notification\services\__init__.py
============================================================
# app/domains/notification/services/__init__.py
from .lark_webhook_service import lark_webhook_service
from .notification_coordinator import notification_coordinator

__all__ = ["lark_webhook_service", "notification_coordinator"]

============================================================

============================================================
FILE: app\domains\notification\services\lark_webhook_service.py
============================================================
"""
Lark Webhook Service - D·ªãch v·ª• g·ª≠i th√¥ng b√°o qua Lark webhook
"""
import requests
import json
from typing import List
from datetime import datetime
from app.core.config.settings import settings
from app.domains.notification.models import (
    NotificationResult, NotificationType, NotificationChannel,
    ValidationAlertRequest, CustomAlertRequest
)


class LarkWebhookService:
    """
    D·ªãch v·ª• g·ª≠i th√¥ng b√°o qua Lark webhook.
    
    Class n√†y cung c·∫•p kh·∫£ nƒÉng g·ª≠i c√°c lo·∫°i th√¥ng b√°o kh√°c nhau ƒë·∫øn
    Lark (FeisHu) th√¥ng qua webhook API:
    
    - Validation alerts: C·∫£nh b√°o khi ph√°t hi·ªán l·ªói validation
    - Custom alerts: Th√¥ng b√°o t√πy ch·ªânh cho c√°c s·ª± ki·ªán ƒë·∫∑c bi·ªát
    
    Service n√†y h·ªó tr·ª£:
    - Format message theo chu·∫©n Lark webhook API
    - Error handling v√† retry logic
    - Tracking k·∫øt qu·∫£ g·ª≠i v·ªõi timestamp
    - Integration v·ªõi notification coordinator
    - Configuration-based enabling/disabling
    
    Attributes:
        webhook_url (str): URL webhook c·ªßa Lark t·ª´ settings
        channel (NotificationChannel): Channel type cho service n√†y
    """
    
    def __init__(self):
        """Kh·ªüi t·∫°o LarkWebhookService v·ªõi c·∫•u h√¨nh t·ª´ settings."""
        self.webhook_url = settings.LARK_WEBHOOK_URL
        self.channel = NotificationChannel.LARK_WEBHOOK
    
    async def send_validation_alert(self, request: ValidationAlertRequest) -> NotificationResult:
        """
        G·ª≠i c·∫£nh b√°o validation error qua Lark webhook.
        
        Method n√†y s·∫Ω format v√† g·ª≠i th√¥ng b√°o c·∫£nh b√°o khi h·ªá th·ªëng
        ph√°t hi·ªán l·ªói validation trong quy tr√¨nh ph√™ duy·ªát.
        
        Quy tr√¨nh x·ª≠ l√Ω:
        1. Ki·ªÉm tra c·∫•u h√¨nh c√≥ enable validation alerts kh√¥ng
        2. Validate webhook URL c√≥ ƒë∆∞·ª£c c·∫•u h√¨nh kh√¥ng
        3. Format message theo template c·∫£nh b√°o validation
        4. G·ª≠i HTTP POST request ƒë·∫øn Lark webhook
        5. Tr·∫£ v·ªÅ k·∫øt qu·∫£ v·ªõi th√¥ng tin chi ti·∫øt
        
        Args:
            request (ValidationAlertRequest): Request ch·ª©a th√¥ng tin validation alert
                - instance_code: M√£ instance c√≥ l·ªói validation
                - validation_errors: Danh s√°ch l·ªói validation
                - priority: M·ª©c ƒë·ªô ∆∞u ti√™n c·ªßa alert
        
        Returns:
            NotificationResult: K·∫øt qu·∫£ g·ª≠i th√¥ng b√°o bao g·ªìm:
                - success: Tr·∫°ng th√°i g·ª≠i th√†nh c√¥ng
                - notification_type: VALIDATION_ALERT
                - channel: LARK_WEBHOOK
                - instance_code: M√£ instance li√™n quan
                - sent_at: Th·ªùi gian g·ª≠i (n·∫øu th√†nh c√¥ng)
                - error: Th√¥ng b√°o l·ªói (n·∫øu th·∫•t b·∫°i)
                - metadata: Th√¥ng tin b·ªï sung (s·ªë l·ªói, priority)
        """
        try:
            # B∆∞·ªõc 1: Ki·ªÉm tra c·∫•u h√¨nh c√≥ enable validation alerts kh√¥ng
            if not settings.ENABLE_VALIDATION_ALERTS:
                print(f"‚ö†Ô∏è T√≠nh nƒÉng c·∫£nh b√°o validation ƒë√£ b·ªã t·∫Øt, b·ªè qua webhook cho {request.instance_code}")
                return NotificationResult(
                    success=True,  # Tr·∫£ v·ªÅ success v√¨ ƒë√£ x·ª≠ l√Ω (disabled)
                    notification_type=NotificationType.VALIDATION_ALERT,
                    channel=self.channel,
                    instance_code=request.instance_code,
                    cached=True,
                    metadata={"disabled": True, "reason": "ENABLE_VALIDATION_ALERTS = False"}
                )
            
            # B∆∞·ªõc 2: Ki·ªÉm tra webhook URL c√≥ ƒë∆∞·ª£c c·∫•u h√¨nh kh√¥ng
            if not self.webhook_url:
                print(f"‚ùå Ch∆∞a c·∫•u h√¨nh webhook URL cho Lark")
                return NotificationResult(
                    success=False,
                    notification_type=NotificationType.VALIDATION_ALERT,
                    channel=self.channel,
                    instance_code=request.instance_code,
                    error="Ch∆∞a c·∫•u h√¨nh webhook URL"
                )
            
            # B∆∞·ªõc 3: Format danh s√°ch l·ªói validation th√†nh text d·ªÖ ƒë·ªçc
            print(f"üìù ƒêang format {len(request.validation_errors)} l·ªói validation...")
            error_messages = "\n".join([f"‚Ä¢ {error}" for error in request.validation_errors])
            
            # T·∫°o message data theo format c·ªßa Lark webhook API
            message_data = {
                "msg_type": "text",
                "content": {
                    "text": f"""‚ö†Ô∏è C·∫¢NH B√ÅO D·ªÆ LI·ªÜU KH√îNG H·ª¢P L·ªÜ
üìÑ Request No.: {request.serial_number}
‚ùå C√°c l·ªói ph√°t hi·ªán:
{error_messages}

üîß Vui l√≤ng ki·ªÉm tra v√† x·ª≠ l√Ω."""
                }
            }
            
            # C·∫•u h√¨nh headers cho HTTP request
            headers = {"Content-Type": "application/json"}
            
            # B∆∞·ªõc 4: G·ª≠i HTTP POST request ƒë·∫øn Lark webhook
            print(f"üö® ƒêang g·ª≠i c·∫£nh b√°o validation qua webhook cho {request.instance_code}")
            response = requests.post(
                self.webhook_url, 
                headers=headers, 
                data=json.dumps(message_data),
                timeout=10  # Timeout 10 gi√¢y ƒë·ªÉ tr√°nh treo
            )
            
            # B∆∞·ªõc 5: X·ª≠ l√Ω response v√† t·∫°o k·∫øt qu·∫£
            success = response.status_code == 200
            sent_at = datetime.now().isoformat() if success else None
            
            if success:
                print(f"‚úÖ G·ª≠i c·∫£nh b√°o validation th√†nh c√¥ng cho {request.instance_code}")
            else:
                print(f"‚ùå G·ª≠i c·∫£nh b√°o validation th·∫•t b·∫°i: HTTP {response.status_code} - {response.text}")
            
            return NotificationResult(
                success=success,
                notification_type=NotificationType.VALIDATION_ALERT,
                channel=self.channel,
                instance_code=request.instance_code,
                sent_at=sent_at,
                error=None if success else f"HTTP {response.status_code}: {response.text}",
                metadata={
                    "errors_count": len(request.validation_errors),
                    "priority": request.priority.value,
                    "response_status": response.status_code
                }
            )
                
        except requests.exceptions.Timeout:
            print(f"‚è∞ Timeout khi g·ª≠i validation webhook (qu√° 10 gi√¢y)")
            return NotificationResult(
                success=False,
                notification_type=NotificationType.VALIDATION_ALERT,
                channel=self.channel,
                instance_code=request.instance_code,
                error="Timeout khi g·ª≠i webhook"
            )
        except requests.exceptions.ConnectionError:
            print(f"üîå L·ªói k·∫øt n·ªëi khi g·ª≠i validation webhook")
            return NotificationResult(
                success=False,
                notification_type=NotificationType.VALIDATION_ALERT,
                channel=self.channel,
                instance_code=request.instance_code,
                error="L·ªói k·∫øt n·ªëi webhook"
            )
        except Exception as e:
            print(f"‚ùå L·ªói kh√¥ng x√°c ƒë·ªãnh khi g·ª≠i validation webhook: {e}")
            return NotificationResult(
                success=False,
                notification_type=NotificationType.VALIDATION_ALERT,
                channel=self.channel,
                instance_code=request.instance_code,
                error=str(e)
            )

    async def send_custom_alert(self, request: CustomAlertRequest) -> NotificationResult:
        """
        G·ª≠i th√¥ng b√°o t√πy ch·ªânh qua Lark webhook.
        
        Method n√†y cho ph√©p g·ª≠i c√°c th√¥ng b√°o t√πy ch·ªânh v·ªõi title v√† message
        do ng∆∞·ªùi d√πng ƒë·ªãnh nghƒ©a, ph√π h·ª£p cho c√°c s·ª± ki·ªán ƒë·∫∑c bi·ªát ho·∫∑c
        th√¥ng b√°o h·ªá th·ªëng.
        
        Args:
            request (CustomAlertRequest): Request ch·ª©a th√¥ng tin custom alert
                - title: Ti√™u ƒë·ªÅ th√¥ng b√°o
                - message: N·ªôi dung th√¥ng b√°o
                - instance_code: M√£ instance li√™n quan (optional)
                - priority: M·ª©c ƒë·ªô ∆∞u ti√™n
        
        Returns:
            NotificationResult: K·∫øt qu·∫£ g·ª≠i th√¥ng b√°o t∆∞∆°ng t·ª± send_validation_alert
        """
        try:
            # B∆∞·ªõc 1: Ki·ªÉm tra c·∫•u h√¨nh v√† webhook URL
            if not settings.ENABLE_VALIDATION_ALERTS or not self.webhook_url:
                print(f"‚ùå Alerts b·ªã t·∫Øt ho·∫∑c ch∆∞a c·∫•u h√¨nh webhook URL")
                return NotificationResult(
                    success=False,
                    notification_type=NotificationType.CUSTOM_ALERT,
                    channel=self.channel,
                    instance_code=request.instance_code,
                    error="Alerts b·ªã t·∫Øt ho·∫∑c ch∆∞a c·∫•u h√¨nh webhook URL"
                )
            
            # B∆∞·ªõc 2: Format message v·ªõi title v√† n·ªôi dung t√πy ch·ªânh
            print(f"üìù ƒêang t·∫°o custom alert: {request.title}")
            alert_text = f"""üîî {request.title}"""
            
            # Th√™m instance code n·∫øu c√≥
            if request.instance_code:
                alert_text += f"\nüìÑ Instance: {request.instance_code}"
                
            alert_text += f"\nüì¢ {request.message}"
            
            # T·∫°o message data cho Lark webhook
            message_data = {
                "msg_type": "text",
                "content": {"text": alert_text}
            }
            
            # B∆∞·ªõc 3: G·ª≠i HTTP request
            print(f"üì§ ƒêang g·ª≠i custom alert qua webhook...")
            headers = {"Content-Type": "application/json"}
            response = requests.post(
                self.webhook_url, 
                headers=headers, 
                data=json.dumps(message_data),
                timeout=10
            )
            
            # B∆∞·ªõc 4: X·ª≠ l√Ω k·∫øt qu·∫£
            success = response.status_code == 200
            sent_at = datetime.now().isoformat() if success else None
            
            if success:
                print(f"‚úÖ G·ª≠i custom alert th√†nh c√¥ng: {request.title}")
            else:
                print(f"‚ùå G·ª≠i custom alert th·∫•t b·∫°i: HTTP {response.status_code} - {response.text}")
            
            return NotificationResult(
                success=success,
                notification_type=NotificationType.CUSTOM_ALERT,
                channel=self.channel,
                instance_code=request.instance_code,
                sent_at=sent_at,
                error=None if success else f"HTTP {response.status_code}: {response.text}",
                metadata={
                    "title": request.title,
                    "priority": request.priority.value,
                    "has_instance_code": request.instance_code is not None,
                    "response_status": response.status_code
                }
            )
            
        except requests.exceptions.Timeout:
            print(f"‚è∞ Timeout khi g·ª≠i custom alert webhook")
            return NotificationResult(
                success=False,
                notification_type=NotificationType.CUSTOM_ALERT,
                channel=self.channel,
                instance_code=request.instance_code,
                error="Timeout khi g·ª≠i webhook"
            )
        except requests.exceptions.ConnectionError:
            print(f"üîå L·ªói k·∫øt n·ªëi khi g·ª≠i custom alert webhook")
            return NotificationResult(
                success=False,
                notification_type=NotificationType.CUSTOM_ALERT,
                channel=self.channel,
                instance_code=request.instance_code,
                error="L·ªói k·∫øt n·ªëi webhook"
            )
        except Exception as e:
            print(f"‚ùå L·ªói khi g·ª≠i custom alert: {e}")
            return NotificationResult(
                success=False,
                notification_type=NotificationType.CUSTOM_ALERT,
                channel=self.channel,
                instance_code=request.instance_code,
                error=str(e)
            )


lark_webhook_service = LarkWebhookService()
============================================================

============================================================
FILE: app\domains\notification\services\notification_coordinator.py
============================================================
"""
Notification Coordinator - B·ªô ƒëi·ªÅu ph·ªëi trung t√¢m cho t·∫•t c·∫£ k√™nh th√¥ng b√°o
"""
from typing import List, Dict, Any
from app.domains.notification.models import (
    NotificationRequest, NotificationResult, NotificationType, 
    NotificationChannel, ValidationAlertRequest, CustomAlertRequest
)
from app.domains.notification.services.lark_webhook_service import lark_webhook_service
from app.core.infrastructure.cache_service import cache_service


class NotificationCoordinator:
    """
    B·ªô ƒëi·ªÅu ph·ªëi trung t√¢m cho t·∫•t c·∫£ c√°c k√™nh th√¥ng b√°o.
    
    Class n√†y ho·∫°t ƒë·ªông nh∆∞ m·ªôt central hub ƒë·ªÉ:
    1. Qu·∫£n l√Ω v√† ƒëi·ªÅu ph·ªëi c√°c k√™nh th√¥ng b√°o kh√°c nhau (Lark, Email, SMS, etc.)
    2. NgƒÉn ch·∫∑n duplicate notifications th√¥ng qua caching mechanism
    3. Route notifications ƒë·∫øn ƒë√∫ng service d·ª±a tr√™n channel v√† type
    4. Cung c·∫•p interface th·ªëng nh·∫•t cho vi·ªác g·ª≠i th√¥ng b√°o
    5. Track v√† log k·∫øt qu·∫£ g·ª≠i th√¥ng b√°o
    
    Supported channels:
    - LARK_WEBHOOK: G·ª≠i th√¥ng b√°o qua Lark webhook
    - C√≥ th·ªÉ m·ªü r·ªông th√™m EMAIL, SMS, SLACK, etc.
    
    Supported notification types:
    - VALIDATION_ALERT: C·∫£nh b√°o validation errors
    - CUSTOM_ALERT: C·∫£nh b√°o t√πy ch·ªânh
    - QR_GENERATION: Th√¥ng b√°o t·∫°o QR (t∆∞∆°ng lai)
    
    Attributes:
        channels (Dict): Map t·ª´ notification channel ƒë·∫øn service implementation
    """
    
    def __init__(self):
        """Kh·ªüi t·∫°o NotificationCoordinator v·ªõi c√°c k√™nh th√¥ng b√°o ƒë∆∞·ª£c h·ªó tr·ª£."""
        # Mapping t·ª´ notification channel ƒë·∫øn service implementation
        # D·ªÖ d√†ng m·ªü r·ªông th√™m channels m·ªõi trong t∆∞∆°ng lai
        self.channels = {
            NotificationChannel.LARK_WEBHOOK: lark_webhook_service
            # C√≥ th·ªÉ th√™m:
            # NotificationChannel.EMAIL: email_service,
            # NotificationChannel.SMS: sms_service,
            # NotificationChannel.SLACK: slack_service,
        }
    
    async def send_notification(self, request: NotificationRequest) -> NotificationResult:
        """
        G·ª≠i th√¥ng b√°o qua k√™nh ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh v·ªõi t√≠nh nƒÉng ch·ªëng tr√πng l·∫∑p.
        
        ƒê√¢y l√† method ch√≠nh c·ªßa coordinator, th·ª±c hi·ªán:
        1. Ki·ªÉm tra duplicate notifications d·ª±a tr√™n cache
        2. Validate v√† route ƒë·∫øn ƒë√∫ng channel service  
        3. G·ªçi method ph√π h·ª£p d·ª±a tr√™n notification type
        4. Cache k·∫øt qu·∫£ ƒë·ªÉ tr√°nh duplicate trong t∆∞∆°ng lai
        5. Tr·∫£ v·ªÅ k·∫øt qu·∫£ chi ti·∫øt cho monitoring
        
        Args:
            request (NotificationRequest): Request ch·ª©a th√¥ng tin notification c·∫ßn g·ª≠i
            
        Returns:
            NotificationResult: K·∫øt qu·∫£ g·ª≠i th√¥ng b√°o bao g·ªìm:
                - success (bool): Tr·∫°ng th√°i g·ª≠i th√†nh c√¥ng
                - notification_type: Lo·∫°i th√¥ng b√°o
                - channel: K√™nh ƒë√£ s·ª≠ d·ª•ng
                - instance_code: M√£ instance li√™n quan
                - cached (bool): C√≥ ƒë∆∞·ª£c cache kh√¥ng
                - cache_hit (bool): C√≥ b·ªã skip do cache kh√¥ng
                - error (str): Th√¥ng b√°o l·ªói n·∫øu c√≥
                - metadata (Dict): Th√¥ng tin b·ªï sung
        """
        
        # B∆∞·ªõc 1: Ki·ªÉm tra duplicate notifications d·ª±a tr√™n cache
        if request.instance_code:
            # T·∫°o cache key duy nh·∫•t cho combination c·ªßa type v√† instance
            cache_key = f"{request.notification_type.value}_{request.instance_code}"
            
            print(f"üîç Ki·ªÉm tra duplicate notification cho: {cache_key}")
            
            # Ki·ªÉm tra xem ƒë√£ g·ª≠i notification t∆∞∆°ng t·ª± g·∫ßn ƒë√¢y ch∆∞a
            if cache_service.is_validation_alert_recently_sent(
                request.instance_code, 
                request.notification_type.value,
                cache_duration_minutes=10
            ):
                print(f"üîÑ PH√ÅT HI·ªÜN TH√îNG B√ÅO TR√ôNG L·∫∂P: {cache_key}")
                print(f"   ‚Üí B·ªé QUA g·ª≠i th√¥ng b√°o ƒë·ªÉ tr√°nh spam")
                
                return NotificationResult(
                    success=True,  # Tr·∫£ v·ªÅ success v√¨ ƒë√£ x·ª≠ l√Ω (cached)
                    notification_type=request.notification_type,
                    channel=request.channel,
                    instance_code=request.instance_code,
                    cached=True,
                    cache_hit=True,
                    metadata={
                        "reason": "duplicate_prevention",
                        "cache_key": cache_key,
                        "cache_duration_minutes": 10
                    }
                )
        
        # B∆∞·ªõc 2: Validate v√† l·∫•y channel service
        print(f"üì° ƒêang ƒë·ªãnh tuy·∫øn ƒë·∫øn k√™nh: {request.channel.value}")
        channel_service = self.channels.get(request.channel)
        
        if not channel_service:
            print(f"‚ùå K√™nh kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£: {request.channel.value}")
            return NotificationResult(
                success=False,
                notification_type=request.notification_type,
                channel=request.channel,
                instance_code=request.instance_code,
                error=f"K√™nh kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£: {request.channel.value}",
                metadata={
                    "available_channels": list(self.channels.keys())
                }
            )
        
        # B∆∞·ªõc 3: Route ƒë·∫øn method ph√π h·ª£p d·ª±a tr√™n notification type
        print(f"üéØ X·ª≠ l√Ω lo·∫°i th√¥ng b√°o: {request.notification_type.value}")
        
        if request.notification_type == NotificationType.VALIDATION_ALERT:
            # X·ª≠ l√Ω validation alert
            print(f"üîî T·∫°o validation alert request...")
            alert_request = ValidationAlertRequest(
                instance_code=request.instance_code,
                validation_errors=[request.message],
                priority=request.priority
            )
            
            print(f"üì§ ƒêang g·ª≠i validation alert qua {request.channel.value}...")
            result = await channel_service.send_validation_alert(alert_request)
        
        elif request.notification_type == NotificationType.CUSTOM_ALERT:
            # X·ª≠ l√Ω custom alert
            print(f"üé® T·∫°o custom alert request...")
            alert_request = CustomAlertRequest(
                title=request.title,
                message=request.message,
                instance_code=request.instance_code,
                priority=request.priority
            )
            
            print(f"üì§ ƒêang g·ª≠i custom alert qua {request.channel.value}...")
            result = await channel_service.send_custom_alert(alert_request)
        
        else:
            # Notification type kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£
            print(f"‚ùå Lo·∫°i th√¥ng b√°o kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£: {request.notification_type.value}")
            return NotificationResult(
                success=False,
                notification_type=request.notification_type,
                channel=request.channel,
                instance_code=request.instance_code,
                error=f"Lo·∫°i th√¥ng b√°o kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£: {request.notification_type.value}",
                metadata={
                    "available_types": [nt.value for nt in NotificationType]
                }
            )
        
        # B∆∞·ªõc 4: X·ª≠ l√Ω k·∫øt qu·∫£ v√† cache n·∫øu th√†nh c√¥ng
        if result.success and request.instance_code:
            print(f"‚úÖ G·ª≠i th√¥ng b√°o th√†nh c√¥ng - ƒë√°nh d·∫•u cache")
            
            # ƒê√°nh d·∫•u ƒë√£ g·ª≠i trong cache ƒë·ªÉ tr√°nh duplicate
            cache_service.mark_validation_alert_as_sent(
                request.instance_code, 
                request.notification_type.value
            )
            
            print(f"üíæ ƒê√£ l∆∞u v√†o cache ƒë·ªÉ tr√°nh duplicate trong 10 ph√∫t")
        elif result.success:
            print(f"‚úÖ G·ª≠i th√¥ng b√°o th√†nh c√¥ng (kh√¥ng c√≥ instance_code ƒë·ªÉ cache)")
        else:
            print(f"‚ùå G·ª≠i th√¥ng b√°o th·∫•t b·∫°i: {getattr(result, 'error', 'L·ªói kh√¥ng x√°c ƒë·ªãnh')}")
        
        return result


# Instance to√†n c·ª•c c·ªßa coordinator ƒë·ªÉ s·ª≠ d·ª•ng trong to√†n b·ªô h·ªá th·ªëng
notification_coordinator = NotificationCoordinator()
============================================================

============================================================
FILE: app\domains\qr_generation\__init__.py
============================================================
from .models import *
from .services import *
from .handlers import *

__all__ = [
    # Models
    "QRType", "BankInfo", "QRGenerationResult",
    # Services  
    "vietqr_service", "qr_processor",
    # Handlers
    "qr_event_handler"
]

============================================================

============================================================
FILE: app\domains\qr_generation\handlers\__init__.py
============================================================
from .qr_event_handler import qr_event_handler

__all__ = ["qr_event_handler"]

============================================================

============================================================
FILE: app\domains\qr_generation\handlers\qr_event_handler.py
============================================================
from typing import Dict
from app.core.infrastructure.lark_service import lark_service
from app.domains.qr_generation.services.qr_processor import qr_processor

class QREventHandler:
    """
    B·ªô x·ª≠ l√Ω s·ª± ki·ªán t·∫°o m√£ QR cho h·ªá th·ªëng ph√™ duy·ªát Lark.
    
    Class n√†y ho·∫°t ƒë·ªông nh∆∞ m·ªôt event handler ƒë·ªôc l·∫≠p, nh·∫≠n v√† x·ª≠ l√Ω
    c√°c s·ª± ki·ªán ph√™ duy·ªát ƒë·ªÉ t·ª± ƒë·ªông t·∫°o m√£ VietQR t∆∞∆°ng ·ª©ng.
    
    Quy tr√¨nh x·ª≠ l√Ω:
    1. Nh·∫≠n s·ª± ki·ªán ph√™ duy·ªát t·ª´ h·ªá th·ªëng
    2. Tr√≠ch xu·∫•t instance_code t·ª´ event data
    3. L·∫•y access token ƒë·ªÉ g·ªçi Lark API
    4. G·ª≠i ƒë·∫øn QRProcessor ƒë·ªÉ x·ª≠ l√Ω t·∫°o QR
    5. Tr·∫£ v·ªÅ k·∫øt qu·∫£ x·ª≠ l√Ω
    
    Attributes:
        name (str): T√™n ƒë·ªãnh danh c·ªßa service ("QR_Generator")
    """
    
    def __init__(self):
        """Kh·ªüi t·∫°o QREventHandler v·ªõi t√™n service."""
        self.name = "QR_Generator"
    
    async def handle_approval_event(self, event_data: Dict) -> Dict:
        """
        X·ª≠ l√Ω s·ª± ki·ªán ph√™ duy·ªát ƒë·ªÉ t·∫°o m√£ QR t·ª± ƒë·ªông.
        
        [N√ÇNG C·∫§P] B·ªï sung logic ki·ªÉm tra tr·∫°ng th√°i ƒë∆°n. S·∫Ω b·ªè qua x·ª≠ l√Ω
        n·∫øu ƒë∆°n ·ªü tr·∫°ng th√°i cu·ªëi c√πng nh∆∞ REJECTED, CANCELED, DELETED.
        
        ƒê√¢y l√† method ch√≠nh c·ªßa handler, ho·∫°t ƒë·ªông ho√†n to√†n ƒë·ªôc l·∫≠p
        v√† kh√¥ng ph·ª• thu·ªôc v√†o c√°c service kh√°c. Method s·∫Ω:
        
        1. Validate d·ªØ li·ªáu ƒë·∫ßu v√†o (instance_code)
        2. L·∫•y access token t·ª´ Lark service
        3. G·ªçi QRProcessor ƒë·ªÉ x·ª≠ l√Ω business logic
        4. Tr·∫£ v·ªÅ k·∫øt qu·∫£ chi ti·∫øt cho monitoring
        
        Args:
            event_data (Dict): D·ªØ li·ªáu s·ª± ki·ªán ch·ª©a th√¥ng tin ph√™ duy·ªát.
                             B·∫Øt bu·ªôc ph·∫£i c√≥ 'instance_code'
        
        Returns:
            Dict: K·∫øt qu·∫£ x·ª≠ l√Ω bao g·ªìm:
                - success (bool): Tr·∫°ng th√°i x·ª≠ l√Ω th√†nh c√¥ng
                - message (str): Th√¥ng b√°o chi ti·∫øt k·∫øt qu·∫£
                - instance_code (str): M√£ instance ƒë√£ x·ª≠ l√Ω (n·∫øu c√≥)
                - service (str): T√™n service th·ª±c hi·ªán
        
        Raises:
            Exception: C√°c l·ªói kh√¥ng x√°c ƒë·ªãnh s·∫Ω ƒë∆∞·ª£c b·∫Øt v√† tr·∫£ v·ªÅ trong response
        """
        try:
            # B∆∞·ªõc 1: Validate v√† tr√≠ch xu·∫•t instance_code t·ª´ event data
            instance_code = event_data.get('instance_code')
            if not instance_code:
                print(f"‚ùå [QR Handler] Thi·∫øu instance_code trong d·ªØ li·ªáu s·ª± ki·ªán")
                return {
                    "success": False,
                    "message": "Kh√¥ng t√¨m th·∫•y instance_code trong d·ªØ li·ªáu s·ª± ki·ªán", 
                    "service": self.name
                }
            
            # [TH√äM M·ªöI] B·∫Øt ƒë·∫ßu kh·ªëi logic ki·ªÉm tra tr·∫°ng th√°i
            FINAL_STATUSES = ['REJECTED', 'CANCELED', 'DELETED']

            # Tr√≠ch xu·∫•t tr·∫°ng th√°i t·ª´ d·ªØ li·ªáu g·ªëc c·ªßa s·ª± ki·ªán ƒë·ªÉ tr√°nh g·ªçi API kh√¥ng c·∫ßn thi·∫øt
            raw_data = event_data.get('raw_data', {})
            instance_status = raw_data.get('event', {}).get('object', {}).get('status')
            
            # Ki·ªÉm tra xem tr·∫°ng th√°i c·ªßa ƒë∆°n c√≥ n·∫±m trong danh s√°ch c·∫ßn b·ªè qua kh√¥ng
            if instance_status and instance_status in FINAL_STATUSES:
                print(f"‚è≠Ô∏è [QR Handler] B·ªè qua instance {instance_code} do c√≥ tr·∫°ng th√°i cu·ªëi c√πng: {instance_status}")
                return {
                    "success": True, # Coi nh∆∞ th√†nh c√¥ng v√¨ ƒë√£ x·ª≠ l√Ω ƒë√∫ng (b·ªè qua)
                    "message": f"B·ªè qua x·ª≠ l√Ω do tr·∫°ng th√°i ƒë∆°n l√† {instance_status}",
                    "instance_code": instance_code,
                    "service": self.name
                }
            # [TH√äM M·ªöI] K·∫øt th√∫c kh·ªëi logic ki·ªÉm tra tr·∫°ng th√°i
            
            print(f"üè¶ [QR Handler] D·ªãch v·ª• QR ƒëang x·ª≠ l√Ω instance: {instance_code} (Tr·∫°ng th√°i: {instance_status or 'N/A'})")
            
            # B∆∞·ªõc 2: L·∫•y access token ƒë·ªÉ g·ªçi Lark API
            print(f"üîë ƒêang l·∫•y access token t·ª´ Lark...")
            access_token = await lark_service.get_access_token()
            if not access_token:
                print(f"‚ùå Kh√¥ng th·ªÉ l·∫•y access token t·ª´ Lark")
                return {
                    "success": False,
                    "message": "Kh√¥ng th·ªÉ l·∫•y access token t·ª´ Lark",
                    "service": self.name
                }
            
            print(f"‚úÖ ƒê√£ l·∫•y access token th√†nh c√¥ng")
            
            # B∆∞·ªõc 3: G·ª≠i ƒë·∫øn QRProcessor ƒë·ªÉ x·ª≠ l√Ω business logic ch√≠nh
            print(f"‚öôÔ∏è B·∫Øt ƒë·∫ßu x·ª≠ l√Ω t·∫°o QR cho {instance_code}...")
            result = await qr_processor.process_approval_with_qr_comment(
                instance_code, access_token
            )
            
            # B∆∞·ªõc 4: T·∫°o response v·ªõi th√¥ng tin chi ti·∫øt
            if result:
                print(f"‚úÖ [QR Handler] Ho√†n th√†nh x·ª≠ l√Ω QR cho {instance_code}")
                return {
                    "success": True,
                    "message": f"X·ª≠ l√Ω QR ho√†n th√†nh th√†nh c√¥ng cho {instance_code}",
                    "instance_code": instance_code,
                    "service": self.name
                }
            else:
                print(f"‚ùå [QR Handler] X·ª≠ l√Ω QR th·∫•t b·∫°i cho {instance_code}")
                return {
                    "success": False,
                    "message": f"X·ª≠ l√Ω QR th·∫•t b·∫°i cho {instance_code}",
                    "instance_code": instance_code,
                    "service": self.name
                }
            
        except Exception as e:
            # B·∫Øt t·∫•t c·∫£ exception kh√¥ng x√°c ƒë·ªãnh ƒë·ªÉ tr√°nh crash service
            print(f"‚ùå L·ªói kh√¥ng x√°c ƒë·ªãnh trong QR Service: {str(e)}")
            import traceback
            print(f"üìã Chi ti·∫øt l·ªói:\n{traceback.format_exc()}")
            
            return {
                "success": False,
                "message": f"L·ªói QR Service: {str(e)}",
                "service": self.name,
                "error_type": type(e).__name__
            }

qr_event_handler = QREventHandler()
============================================================

============================================================
FILE: app\domains\qr_generation\models\__init__.py
============================================================
from .qr import (
    QRType,
    BankInfo,
    AmountDetectionResult,
    QRTypeResult,
    NodeProcessingResult,
    QRGenerationRequest,
    QRGenerationResult
)

__all__ = [
    "QRType",
    "BankInfo", 
    "AmountDetectionResult",
    "QRTypeResult",
    "NodeProcessingResult",
    "QRGenerationRequest",
    "QRGenerationResult"
]

============================================================

============================================================
FILE: app\domains\qr_generation\models\qr.py
============================================================
from pydantic import BaseModel
from typing import Optional, Dict, Any
from enum import Enum

class QRType(str, Enum):
    ADVANCE = "advance"
    PAYMENT = "payment"
    NONE = "none"

class BankInfo(BaseModel):
    bank_id: str
    account_no: str
    account_name: str

class AmountDetectionResult(BaseModel):
    advance_amount: Optional[float] = None
    payment_amount: Optional[float] = None
    advance_field_found: bool = False
    payment_field_found: bool = False
    all_amount_fields: Dict[str, Any] = {}
    fields_used: Dict[str, Optional[str]] = {}

class QRTypeResult(BaseModel):
    qr_type: QRType
    amount: Optional[float] = None
    field_used: Optional[str] = None
    reason: str

class NodeProcessingResult(BaseModel):
    success: bool
    qr_type: QRType = QRType.NONE
    amount: Optional[float] = None
    field_used: Optional[str] = None
    node_strategy: Optional[str] = None
    reason: Optional[str] = None
    error: Optional[str] = None
    field_detection: Optional[AmountDetectionResult] = None

class QRGenerationRequest(BaseModel):
    instance_code: str
    node_id: str
    qr_type: QRType
    amount: int
    bank_info: BankInfo
    description: str

class QRGenerationResult(BaseModel):
    success: bool
    qr_type: Optional[QRType] = None
    amount: Optional[float] = None
    field_used: Optional[str] = None
    node_name: Optional[str] = None
    comment_id: Optional[str] = None
    error: Optional[str] = None
    processing_info: Optional[Dict[str, Any]] = None

============================================================

============================================================
FILE: app\domains\qr_generation\routers\qr.py
============================================================
from fastapi import APIRouter, Depends
from app.domains.qr_generation.models import QRGenerationResult
from app.domains.qr_generation.services.qr_processor import qr_processor
from app.core.infrastructure.lark_service import lark_service

router = APIRouter(prefix="/qr", tags=["QR Generation"])

@router.post("/process/{instance_code}", response_model=QRGenerationResult)
async def manual_process_qr(instance_code: str):
    """Enhanced manual QR processing v·ªõi domain models"""
    try:
        access_token = await lark_service.get_access_token()
        if not access_token:
            return QRGenerationResult(
                success=False,
                error="Cannot get access token"
            )
        
        # Process the instance
        result = await qr_processor.process_approval_with_qr_comment(instance_code, access_token)
        
        return QRGenerationResult(
            success=result,
            processing_info={
                "instance_code": instance_code,
                "processed": result
            }
        )
            
    except Exception as e:
        return QRGenerationResult(
            success=False,
            error=str(e)
        )

@router.get("/cache/status")
async def get_qr_cache_status():
    """Xem tr·∫°ng th√°i QR cache"""
    from app.core.infrastructure.cache_service import cache_service
    cache_status = cache_service.get_cache_status()
    return cache_status.get('qr_cache', {})

@router.post("/cache/clear")
async def clear_qr_cache():
    """Clear QR cache"""
    from app.core.infrastructure.cache_service import cache_service
    result = cache_service.clear_cache()
    return {
        "message": "QR cache cleared",
        "details": result
    }

============================================================

============================================================
FILE: app\domains\qr_generation\services\__init__.py
============================================================
from .vietqr_service import vietqr_service
from .amount_detector import AmountDetector
from .qr_processor import qr_processor

__all__ = [
    "vietqr_service",
    "AmountDetector", 
    "qr_processor"
]

============================================================

============================================================
FILE: app\domains\qr_generation\services\amount_detector.py
============================================================
from typing import Dict, List, Optional
from app.core.config.node_config import get_node_config
from app.core.config.field_constants import FFN
from app.core.utils.field_extractor import FieldExtractor
from app.domains.qr_generation.models import AmountDetectionResult, QRTypeResult, QRType


class AmountDetector:
    """
    B·ªô ph√°t hi·ªán v√† x√°c ƒë·ªãnh s·ªë ti·ªÅn cho vi·ªác t·∫°o m√£ QR.

    Class n√†y ch·ªãu tr√°ch nhi·ªám ph√¢n t√≠ch d·ªØ li·ªáu form ƒë·ªÉ:
    - T√¨m ki·∫øm c√°c tr∆∞·ªùng ch·ª©a th√¥ng tin s·ªë ti·ªÅn
    - X√°c ƒë·ªãnh lo·∫°i QR (t·∫°m ·ª©ng ho·∫∑c thanh to√°n) d·ª±a tr√™n node strategy
    - Validate v√† tr·∫£ v·ªÅ s·ªë ti·ªÅn ph√π h·ª£p cho t·ª´ng node

    H·ªó tr·ª£ nhi·ªÅu chi·∫øn l∆∞·ª£c x·ª≠ l√Ω kh√°c nhau:
    - detect_both_fields: Ph√°t hi·ªán c·∫£ t·∫°m ·ª©ng v√† thanh to√°n
    - payment_field_only: Ch·ªâ x·ª≠ l√Ω tr∆∞·ªùng thanh to√°n

    Attributes:
        field_extractor (FieldExtractor): C√¥ng c·ª• tr√≠ch xu·∫•t d·ªØ li·ªáu t·ª´ form
    """

    def __init__(self):
        """Kh·ªüi t·∫°o AmountDetector v·ªõi FieldExtractor."""
        self.field_extractor = FieldExtractor()

    def detect_available_amount_fields(self, form_data: List[Dict], node_config: Dict = None) -> Dict:
        """
        Qu√©t d·ªØ li·ªáu form ƒë·ªÉ t√¨m c√°c tr∆∞·ªùng s·ªë ti·ªÅn theo c·∫•u h√¨nh node.
        
        Ph∆∞∆°ng th·ª©c n√†y s·∫Ω t√¨m ki·∫øm c√°c tr∆∞·ªùng t·∫°m ·ª©ng v√† thanh to√°n d·ª±a tr√™n
        c·∫•u h√¨nh c·ªßa node. N·∫øu kh√¥ng c√≥ c·∫•u h√¨nh, s·∫Ω s·ª≠ d·ª•ng t√™n tr∆∞·ªùng m·∫∑c ƒë·ªãnh.
        
        Args:
            form_data (List[Dict]): D·ªØ li·ªáu form t·ª´ API response c·ªßa Lark
            node_config (Dict, optional): C·∫•u h√¨nh node ch·ª©a t√™n c√°c tr∆∞·ªùng c·∫ßn t√¨m
            
        Returns:
            Dict: K·∫øt qu·∫£ ph√°t hi·ªán bao g·ªìm:
                - advance_amount: Gi√° tr·ªã s·ªë ti·ªÅn t·∫°m ·ª©ng
                - payment_amount: Gi√° tr·ªã s·ªë ti·ªÅn thanh to√°n  
                - advance_field_found: C√≥ t√¨m th·∫•y tr∆∞·ªùng t·∫°m ·ª©ng kh√¥ng
                - payment_field_found: C√≥ t√¨m th·∫•y tr∆∞·ªùng thanh to√°n kh√¥ng
                - all_amount_fields: T·∫•t c·∫£ tr∆∞·ªùng ch·ª©a t·ª´ kh√≥a ti·ªÅn
                - fields_used: T√™n c√°c tr∆∞·ªùng ƒë√£ s·ª≠ d·ª•ng ƒë·ªÉ t√¨m ki·∫øm
        """
        try:
            # L·∫•y t√™n tr∆∞·ªùng t·ª´ c·∫•u h√¨nh node ho·∫∑c s·ª≠ d·ª•ng gi√° tr·ªã m·∫∑c ƒë·ªãnh
            if node_config:
                advance_field = node_config.get('advance_field')
                payment_field = node_config.get('payment_field')
            else:
                # Gi√° tr·ªã m·∫∑c ƒë·ªãnh ƒë·ªÉ t∆∞∆°ng th√≠ch ng∆∞·ª£c
                advance_field = FFN.ADVANCE_AMOUNT
                payment_field = FFN.PAYMENT_AMOUNT
            
            # Tr√≠ch xu·∫•t gi√° tr·ªã t·ª´ c·∫£ 2 tr∆∞·ªùng (ch·ªâ khi t√™n tr∆∞·ªùng kh√¥ng ph·∫£i None)
            advance_value = None
            payment_value = None
            
            if advance_field:
                advance_value = self.field_extractor.extract_field_value(form_data, advance_field)
            
            if payment_field:
                payment_value = self.field_extractor.extract_field_value(form_data, payment_field)
            
            # Debug: T√¨m t·∫•t c·∫£ tr∆∞·ªùng c√≥ ch·ª©a t·ª´ kh√≥a "ti·ªÅn" ho·∫∑c "amount"
            all_amount_fields = self.field_extractor.get_amount_fields(form_data)
            
            # T·∫°o k·∫øt qu·∫£ chi ti·∫øt
            result = {
                'advance_amount': advance_value,
                'payment_amount': payment_value,
                'advance_field_found': advance_value is not None,
                'payment_field_found': payment_value is not None,
                'all_amount_fields': all_amount_fields,
                'fields_used': {
                    'advance_field': advance_field,
                    'payment_field': payment_field
                }
            }
            
            # Hi·ªÉn th·ªã k·∫øt qu·∫£ ph√°t hi·ªán tr∆∞·ªùng
            print(f"üí∞ K·∫øt qu·∫£ ph√°t hi·ªán tr∆∞·ªùng s·ªë ti·ªÅn:")
            if advance_field:
                status = f"‚úÖ {advance_value}" if advance_value else "‚ùå Kh√¥ng t√¨m th·∫•y"
                print(f"   - {advance_field}: {status}")
            else:
                print(f"   - Tr∆∞·ªùng t·∫°m ·ª©ng: ‚ùå Ch∆∞a ƒë∆∞·ª£c c·∫•u h√¨nh")
                
            if payment_field:
                status = f"‚úÖ {payment_value}" if payment_value else "‚ùå Kh√¥ng t√¨m th·∫•y"
                print(f"   - {payment_field}: {status}")
            else:
                print(f"   - Tr∆∞·ªùng thanh to√°n: ‚ùå Ch∆∞a ƒë∆∞·ª£c c·∫•u h√¨nh")
                
            print(f"   - T·∫•t c·∫£ tr∆∞·ªùng s·ªë ti·ªÅn: {list(all_amount_fields.keys())}")
            
            return result
            
        except Exception as e:
            print(f"‚ùå L·ªói khi ph√°t hi·ªán tr∆∞·ªùng s·ªë ti·ªÅn: {e}")
            return {
                'advance_amount': None,
                'payment_amount': None,
                'advance_field_found': False,
                'payment_field_found': False,
                'all_amount_fields': {},
                'fields_used': {'advance_field': None, 'payment_field': None},
                'error': str(e)
            }

    def determine_qr_type_by_fields(self, field_detection_result: Dict) -> Dict:
        """
        X√°c ƒë·ªãnh lo·∫°i QR d·ª±a tr√™n c√°c tr∆∞·ªùng c√≥ gi√° tr·ªã h·ª£p l·ªá.
        
        Logic ∆∞u ti√™n: T·∫°m ·ª©ng ƒë∆∞·ª£c ∆∞u ti√™n tr∆∞·ªõc, sau ƒë√≥ ƒë·∫øn thanh to√°n.
        Ch·ªâ ch·ªçn tr∆∞·ªùng c√≥ gi√° tr·ªã s·ªë h·ª£p l·ªá v√† l·ªõn h∆°n 0.
        
        Args:
            field_detection_result (Dict): K·∫øt qu·∫£ t·ª´ detect_available_amount_fields()
            
        Returns:
            Dict: K·∫øt qu·∫£ quy·∫øt ƒë·ªãnh lo·∫°i QR bao g·ªìm:
                - qr_type: Lo·∫°i QR ('advance', 'payment', ho·∫∑c 'none')
                - amount: S·ªë ti·ªÅn ƒë√£ ch·ªçn
                - field_used: T√™n tr∆∞·ªùng ƒë√£ s·ª≠ d·ª•ng
                - reason: L√Ω do quy·∫øt ƒë·ªãnh
        """
        try:
            # Tr√≠ch xu·∫•t th√¥ng tin t·ª´ k·∫øt qu·∫£ ph√°t hi·ªán tr∆∞·ªùng
            advance_found = field_detection_result.get('advance_field_found', False)
            payment_found = field_detection_result.get('payment_field_found', False)
            advance_amount = field_detection_result.get('advance_amount')
            payment_amount = field_detection_result.get('payment_amount')

            # L·∫•y t√™n tr∆∞·ªùng ƒë·ªÉ hi·ªÉn th·ªã trong k·∫øt qu·∫£
            fields_used = field_detection_result.get('fields_used', {})
            advance_field_name = fields_used.get('advance_field', FFN.ADVANCE_AMOUNT)
            payment_field_name = fields_used.get('payment_field', FFN.PAYMENT_AMOUNT)

            print(f"üéØ ƒêang x√°c ƒë·ªãnh lo·∫°i QR: t·∫°m_·ª©ng={advance_found}, thanh_to√°n={payment_found}")
            
            # Logic ∆∞u ti√™n: Ki·ªÉm tra t·∫°m ·ª©ng tr∆∞·ªõc
            if advance_found and advance_amount:
                try:
                    amount_value = float(advance_amount)
                    if amount_value > 0:
                        print(f"‚úÖ Ch·ªçn t·∫°m ·ª©ng: {amount_value:,} VND")
                        return {
                            'qr_type': 'advance',
                            'amount': amount_value,
                            'field_used': advance_field_name,
                            'reason': 'T√¨m th·∫•y s·ªë ti·ªÅn t·∫°m ·ª©ng h·ª£p l·ªá'
                        }
                except (ValueError, TypeError):
                    print(f"‚ö†Ô∏è S·ªë ti·ªÅn t·∫°m ·ª©ng kh√¥ng h·ª£p l·ªá: {advance_amount}")
            
            # N·∫øu kh√¥ng c√≥ t·∫°m ·ª©ng, ki·ªÉm tra thanh to√°n
            if payment_found and payment_amount:
                try:
                    amount_value = float(payment_amount)
                    if amount_value > 0:
                        print(f"‚úÖ Ch·ªçn thanh to√°n: {amount_value:,} VND")
                        return {
                            'qr_type': 'payment', 
                            'amount': amount_value,
                            'field_used': payment_field_name,
                            'reason': 'T√¨m th·∫•y s·ªë ti·ªÅn thanh to√°n h·ª£p l·ªá'
                        }
                except (ValueError, TypeError):
                    print(f"‚ö†Ô∏è S·ªë ti·ªÅn thanh to√°n kh√¥ng h·ª£p l·ªá: {payment_amount}")
            
            # Kh√¥ng t√¨m th·∫•y tr∆∞·ªùng h·ª£p l·ªá n√†o
            print(f"‚ùå Kh√¥ng t√¨m th·∫•y s·ªë ti·ªÅn h·ª£p l·ªá")
            return {
                'qr_type': 'none',
                'amount': None,
                'field_used': None,
                'reason': f'Kh√¥ng t√¨m th·∫•y s·ªë ti·ªÅn h·ª£p l·ªá (t·∫°m_·ª©ng={advance_found}, thanh_to√°n={payment_found})'
            }
            
        except Exception as e:
            print(f"‚ùå L·ªói khi x√°c ƒë·ªãnh lo·∫°i QR: {e}")
            return {
                'qr_type': 'none',
                'amount': None,
                'field_used': None,
                'reason': f'L·ªói: {str(e)}'
            }

    def get_amount_and_type_for_node(self, node_id: str, form_data: List[Dict]) -> Dict:
        """
        L·∫•y s·ªë ti·ªÅn v√† lo·∫°i QR cho m·ªôt node c·ª• th·ªÉ d·ª±a tr√™n chi·∫øn l∆∞·ª£c c·ªßa node.
        
        ƒê√¢y l√† ph∆∞∆°ng th·ª©c ch√≠nh ƒë·ªÉ x·ª≠ l√Ω node, s·∫Ω:
        1. L·∫•y c·∫•u h√¨nh node t·ª´ node_id
        2. √Åp d·ª•ng chi·∫øn l∆∞·ª£c ph√π h·ª£p (detect_both_fields ho·∫∑c payment_field_only)
        3. Ph√¢n t√≠ch form data v√† tr·∫£ v·ªÅ k·∫øt qu·∫£
        
        Args:
            node_id (str): ID c·ªßa node c·∫ßn x·ª≠ l√Ω
            form_data (List[Dict]): D·ªØ li·ªáu form t·ª´ Lark API
            
        Returns:
            Dict: K·∫øt qu·∫£ x·ª≠ l√Ω bao g·ªìm:
                - success (bool): X·ª≠ l√Ω th√†nh c√¥ng hay kh√¥ng
                - qr_type (str): Lo·∫°i QR ƒë√£ x√°c ƒë·ªãnh
                - amount (float): S·ªë ti·ªÅn cho QR
                - field_used (str): Tr∆∞·ªùng ƒë√£ s·ª≠ d·ª•ng
                - node_strategy (str): Chi·∫øn l∆∞·ª£c c·ªßa node
                - reason (str): L√Ω do k·∫øt qu·∫£
                - field_detection (Dict): Chi ti·∫øt ph√°t hi·ªán tr∆∞·ªùng
        """
        try:
            # L·∫•y c·∫•u h√¨nh node t·ª´ h·ªá th·ªëng
            node_config = get_node_config(node_id)
            if not node_config:
                print(f"‚ùå Kh√¥ng t√¨m th·∫•y c·∫•u h√¨nh cho node {node_id}")
                return {
                    'success': False,
                    'qr_type': 'none',
                    'error': f'Kh√¥ng t√¨m th·∫•y node {node_id} trong c·∫•u h√¨nh'
                }
            
            # Tr√≠ch xu·∫•t th√¥ng tin node
            strategy = node_config['strategy']
            node_name = node_config['name']
            
            print(f"üîç ƒêang x·ª≠ l√Ω node: {node_name} (chi·∫øn l∆∞·ª£c: {strategy})")
            
            # Ph√°t hi·ªán c√°c tr∆∞·ªùng c√≥ s·∫µn trong form
            field_detection = self.detect_available_amount_fields(form_data, node_config)
            
            # √Åp d·ª•ng chi·∫øn l∆∞·ª£c x·ª≠ l√Ω theo c·∫•u h√¨nh
            if strategy == "detect_both_fields":
                # Chi·∫øn l∆∞·ª£c ph√°t hi·ªán k√©p: c√≥ th·ªÉ l√† t·∫°m ·ª©ng ho·∫∑c thanh to√°n
                print(f"üìã √Åp d·ª•ng chi·∫øn l∆∞·ª£c ph√°t hi·ªán k√©p")
                qr_decision = self.determine_qr_type_by_fields(field_detection)
                
                return {
                    'success': qr_decision['qr_type'] != 'none',
                    'qr_type': qr_decision['qr_type'],
                    'amount': qr_decision['amount'],
                    'field_used': qr_decision['field_used'],
                    'node_strategy': strategy,
                    'reason': f"K·∫øt qu·∫£ ph√°t hi·ªán k√©p: {qr_decision['reason']}",
                    'field_detection': field_detection
                }
                
            elif strategy == "payment_field_only":
                # Chi·∫øn l∆∞·ª£c ch·ªâ thanh to√°n: ch·ªâ ki·ªÉm tra tr∆∞·ªùng thanh to√°n
                print(f"üí≥ √Åp d·ª•ng chi·∫øn l∆∞·ª£c ch·ªâ thanh to√°n")
                payment_amount = field_detection.get('payment_amount')
                payment_found = field_detection.get('payment_field_found', False)
                payment_field_name = node_config.get('payment_field')

                if payment_found and payment_amount:
                    try:
                        amount_value = float(payment_amount)
                        if amount_value > 0:
                            print(f"‚úÖ T√¨m th·∫•y s·ªë ti·ªÅn thanh to√°n h·ª£p l·ªá: {amount_value:,} VND")
                            return {
                                'success': True,
                                'qr_type': 'payment',
                                'amount': amount_value,
                                'field_used': payment_field_name,
                                'node_strategy': strategy,
                                'reason': 'Chi·∫øn l∆∞·ª£c ch·ªâ thanh to√°n: t√¨m th·∫•y s·ªë ti·ªÅn h·ª£p l·ªá',
                                'field_detection': field_detection
                            }
                    except (ValueError, TypeError):
                        print(f"‚ö†Ô∏è S·ªë ti·ªÅn thanh to√°n kh√¥ng h·ª£p l·ªá: {payment_amount}")
                
                print(f"‚ùå Kh√¥ng t√¨m th·∫•y s·ªë ti·ªÅn thanh to√°n h·ª£p l·ªá")
                return {
                    'success': False,
                    'qr_type': 'none',
                    'amount': None,
                    'field_used': None,
                    'node_strategy': strategy,
                    'reason': f'Chi·∫øn l∆∞·ª£c ch·ªâ thanh to√°n: kh√¥ng c√≥ s·ªë ti·ªÅn h·ª£p l·ªá (t√¨m_th·∫•y={payment_found}, gi√°_tr·ªã={payment_amount})',
                    'field_detection': field_detection
                }
            
            else:
                print(f"‚ùå Chi·∫øn l∆∞·ª£c kh√¥ng x√°c ƒë·ªãnh: {strategy}")
                return {
                    'success': False,
                    'qr_type': 'none',
                    'error': f'Chi·∫øn l∆∞·ª£c kh√¥ng x√°c ƒë·ªãnh: {strategy}'
                }
                
        except Exception as e:
            print(f"‚ùå L·ªói khi x·ª≠ l√Ω node {node_id}: {e}")
            return {
                'success': False,
                'qr_type': 'none',
                'error': str(e)
            }
============================================================

============================================================
FILE: app\domains\qr_generation\services\qr_processor.py
============================================================
import json
from app.core.config.settings import settings
# NODE_CONFIG v√† AmountDetector kh√¥ng c√≤n c·∫ßn thi·∫øt cho logic ch√≠nh, nh∆∞ng gi·ªØ l·∫°i import ƒë·ªÉ kh√¥ng ·∫£nh h∆∞·ªüng c√°c h√†m ph·ª•
from app.core.config.node_config import NODE_CONFIG
from app.core.config.field_constants import FFN
from app.core.infrastructure.lark_service import lark_service
from app.core.infrastructure.cache_service import cache_service
from app.core.utils.field_extractor import FieldExtractor
from app.domains.qr_generation.services.vietqr_service import vietqr_service
# AmountDetector kh√¥ng c√≤n ƒë∆∞·ª£c s·ª≠ d·ª•ng trong h√†m ch√≠nh n·ªØa
# from app.domains.qr_generation.services.amount_detector import AmountDetector
from app.domains.qr_generation.models import QRType, BankInfo

class QRProcessor:
    """
    B·ªô x·ª≠ l√Ω QR ch√≠nh - Qu·∫£n l√Ω logic nghi·ªáp v·ª• t·∫°o v√† x·ª≠ l√Ω m√£ QR cho h·ªá th·ªëng ph√™ duy·ªát.
    
    Class n√†y x·ª≠ l√Ω to√†n b·ªô quy tr√¨nh t·ª´ vi·ªác ki·ªÉm tra node ph√™ duy·ªát, tr√≠ch xu·∫•t d·ªØ li·ªáu,
    validate th√¥ng tin, t·∫°o m√£ VietQR v√† upload l√™n h·ªá th·ªëng Lark.
    
    Attributes:
        field_extractor (FieldExtractor): B·ªô tr√≠ch xu·∫•t tr∆∞·ªùng d·ªØ li·ªáu t·ª´ form
    """

    def __init__(self):
        """Kh·ªüi t·∫°o QRProcessor v·ªõi c√°c service c·∫ßn thi·∫øt."""
        self.field_extractor = FieldExtractor()
        # self.amount_detector kh√¥ng c√≤n c·∫ßn thi·∫øt n·ªØa
        # self.amount_detector = AmountDetector()

    # --- H√ÄM C≈® N√ÄY V·∫™N GI·ªÆ L·∫†I NH∆ØNG KH√îNG ƒê∆Ø·ª¢C G·ªåI TRONG H√ÄM CH√çNH ---
    def check_pending_allowed_node_in_task_list(self, api_response: dict, node_config: dict = None) -> dict:
        """
        Ki·ªÉm tra node c√≥ tr·∫°ng th√°i ph√π h·ª£p v√† ƒë√°p ·ª©ng c√°c ƒëi·ªÅu ki·ªán b·ªï sung.
        (H√†m n√†y kh√¥ng c√≤n ƒë∆∞·ª£c s·ª≠ d·ª•ng trong lu·ªìng ch√≠nh t·∫°o QR ƒë·ªông)
        """
        if node_config is None:
            node_config = NODE_CONFIG
        # ... logic c·ªßa h√†m c≈© gi·ªØ nguy√™n ...
        try:
            # Tr√≠ch xu·∫•t d·ªØ li·ªáu t·ª´ API response
            data = api_response.get('data', {})
            task_list = data.get('task_list', [])
            configured_node_ids = list(node_config.keys())
            
            # T·∫°o map ƒë·ªÉ tra c·ª©u nhanh tr·∫°ng th√°i c·ªßa c√°c node
            node_status_map = {}
            for task in task_list:
                node_id = task.get('node_id')
                status = task.get('status', 'UNKNOWN')
                if node_id:
                    node_status_map[node_id] = status
            
            print(f"üîç ƒêang ki·ªÉm tra c√°c node v·ªõi ƒëi·ªÅu ki·ªán b·ªï sung:")
            for node_id, config in node_config.items():
                required_status = config.get('required_status', 'PENDING')
                additional_conditions = config.get('additional_conditions', [])
                print(f"   ‚Ä¢ {node_id[:8]}... - {config['name']} (y√™u c·∫ßu: {required_status})")
                if additional_conditions:
                    for condition in additional_conditions:
                        print(f"     + ƒêi·ªÅu ki·ªán th√™m: {condition['node_id'][:8]}... ph·∫£i ·ªü tr·∫°ng th√°i {condition['required_status']}")
            
            print(f"üìã Danh s√°ch task ch·ª©a {len(task_list)} nhi·ªám v·ª•")
            
            matching_configured_nodes = []
            
            # Duy·ªát qua t·ª´ng node ƒë√£ c·∫•u h√¨nh
            for node_id in configured_node_ids:
                config = node_config[node_id]
                required_status = config.get('required_status', 'PENDING')
                current_status = node_status_map.get(node_id, 'NOT_FOUND')
                
                # Ki·ªÉm tra ƒëi·ªÅu ki·ªán ch√≠nh
                if current_status != required_status:
                    continue
                    
                # Ki·ªÉm tra c√°c ƒëi·ªÅu ki·ªán b·ªï sung
                additional_conditions = config.get('additional_conditions', [])
                all_conditions_met = True
                
                for condition in additional_conditions:
                    condition_node_id = condition['node_id']
                    condition_required_status = condition['required_status']
                    condition_current_status = node_status_map.get(condition_node_id, 'NOT_FOUND')
                    
                    print(f"üîç Ki·ªÉm tra ƒëi·ªÅu ki·ªán b·ªï sung: {condition_node_id[:8]}... ")
                    print(f"   Y√™u c·∫ßu: {condition_required_status}, Hi·ªán t·∫°i: {condition_current_status}")
                    
                    if condition_current_status != condition_required_status:
                        all_conditions_met = False
                        print(f"‚ùå ƒêi·ªÅu ki·ªán b·ªï sung kh√¥ng ƒë√°p ·ª©ng cho {node_id[:8]}...")
                        break
                    else:
                        print(f"‚úÖ ƒêi·ªÅu ki·ªán b·ªï sung ƒë√£ ƒë√°p ·ª©ng")
                
                # N·∫øu t·∫•t c·∫£ ƒëi·ªÅu ki·ªán ƒë·ªÅu th·ªèa m√£n
                if all_conditions_met:
                    matching_configured_nodes.append({
                        'node_id': node_id,
                        'config': config,
                        'strategy': config['strategy'],
                        'matched_status': current_status,
                        'required_status': required_status,
                        'additional_conditions_met': True
                    })
                    print(f"‚úÖ T√¨m th·∫•y node ph√π h·ª£p: {node_id[:8]}... ({config['name']}) - Tr·∫°ng th√°i: {current_status}")
            
            # Tr·∫£ v·ªÅ node ph√π h·ª£p ƒë·∫ßu ti√™n
            if matching_configured_nodes:
                first_matching = matching_configured_nodes[0]
                return {
                    'found': True,
                    'node_id': first_matching['node_id'],
                    'node_config': first_matching['config'],
                    'strategy': first_matching['strategy'],
                    'matched_status': first_matching['matched_status'],
                    'required_status': first_matching['required_status'],
                    'all_tasks': task_list,
                    'all_matching_configured': matching_configured_nodes,
                    'node_status_map': node_status_map
                }
            else:
                print(f"‚ùå Kh√¥ng t√¨m th·∫•y node n√†o ƒë√°p ·ª©ng t·∫•t c·∫£ ƒëi·ªÅu ki·ªán")
                return {
                    'found': False,
                    'node_id': None,
                    'node_config': None,
                    'strategy': None,
                    'matched_status': None,
                    'all_tasks': task_list,
                    'all_matching_configured': [],
                    'node_status_map': node_status_map
                }
            
        except Exception as e:
            print(f"‚ùå L·ªói khi ki·ªÉm tra node: {e}")
            return {
                'found': False,
                'error': str(e),
                'all_tasks': [],
                'all_matching_configured': []
            }


    def validate_amount_value(self, amount_value) -> dict:
        """
        Validate v√† chuy·ªÉn ƒë·ªïi gi√° tr·ªã s·ªë ti·ªÅn.
        """
        try:
            if amount_value is None:
                return {'valid': False, 'amount': None, 'error': 'S·ªë ti·ªÅn kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng'}
            
            amount_float = float(amount_value)
            amount_int = int(amount_float)
            
            if amount_int <= 0:
                return {'valid': False, 'amount': amount_int, 'error': 'S·ªë ti·ªÅn ph·∫£i l·ªõn h∆°n 0'}
                
            return {'valid': True, 'amount': amount_int, 'error': None}
            
        except (ValueError, TypeError) as e:
            return {'valid': False, 'amount': None, 'error': f'ƒê·ªãnh d·∫°ng s·ªë ti·ªÅn kh√¥ng h·ª£p l·ªá: {str(e)}'}

    async def process_approval_with_qr_comment(self, instance_code: str, access_token: str) -> bool:
        """
        X·ª≠ l√Ω ph√™ duy·ªát v·ªõi t·∫°o QR code v√† comment (phi√™n b·∫£n n√¢ng c·∫•p h·ªó tr·ª£ nhi·ªÅu l·∫ßn t·∫°m ·ª©ng).
        """
        try:
            # B∆∞·ªõc 1: L·∫•y th√¥ng tin chi ti·∫øt c·ªßa instance
            api_response = await lark_service.get_approval_instance(instance_code, access_token)
            if not api_response or 'data' not in api_response:
                print(f"‚ùå Kh√¥ng th·ªÉ l·∫•y th√¥ng tin instance {instance_code}")
                return False
            
            task_list = api_response['data'].get('task_list', [])
            form_str = api_response['data'].get('form', '[]')
            form_data = json.loads(form_str)

            # --- [LOGIC M·ªöI] B·∫Øt ƒë·∫ßu ph·∫ßn t√¨m ki·∫øm l·∫ßn t·∫°m ·ª©ng ho·∫°t ƒë·ªông ---
            
            # 2.1: T√¨m t·∫•t c·∫£ c√°c node "Th·ªß qu·ªπ chi ti·ªÅn t·∫°m ·ª©ng" trong quy tr√¨nh
            cashier_nodes = [task for task in task_list if "Th·ªß qu·ªπ chi ti·ªÅn t·∫°m ·ª©ng" in task.get('node_name', '')]
            print(f"üîç T√¨m th·∫•y {len(cashier_nodes)} node 'Th·ªß qu·ªπ chi ti·ªÅn t·∫°m ·ª©ng' trong quy tr√¨nh.")

            active_advance_info = None
            
            # 2.2: L·∫∑p qua c√°c node th·ªß qu·ªπ ƒë·ªÉ t√¨m node ƒëang PENDING
            for i, node in enumerate(cashier_nodes, 1):
                node_id = node.get('node_id')
                node_status = node.get('status')
                print(f"   - Ki·ªÉm tra l·∫ßn t·∫°m ·ª©ng {i} (Node ID: {node_id[:8]}..., Tr·∫°ng th√°i: {node_status})...")

                # ƒêi·ªÅu ki·ªán 1: Node ph·∫£i ·ªü tr·∫°ng th√°i PENDING
                if node_status == 'PENDING':
                    # ƒêi·ªÅu ki·ªán 2: Ng∆∞·ªùi d√πng ph·∫£i ch·ªçn "Yes" cho l·∫ßn t·∫°m ·ª©ng t∆∞∆°ng ·ª©ng
                    yes_no_field_name = f"Thanh to√°n t·∫°m ·ª©ng l·∫ßn {i}: Y/N"
                    amount_field_name = f"S·ªë ti·ªÅn t·∫°m ·ª©ng l·∫ßn {i}:"

                    yes_no_value = self.field_extractor.extract_field_value(form_data, yes_no_field_name)
                    
                    if yes_no_value == "Yes":
                        print(f"     ‚úÖ ƒêi·ªÅu ki·ªán th·ªèa m√£n: Node PENDING v√† ng∆∞·ªùi d√πng ch·ªçn 'Yes'.")
                        amount_value = self.field_extractor.extract_field_value(form_data, amount_field_name)
                        
                        active_advance_info = {
                            "amount": amount_value,
                            "node_id": node_id,
                            "node_name": node.get('node_name'),
                            "qr_type": "advance",
                            "field_used": amount_field_name,
                            "advance_round": i
                        }
                        print(f"     ‚û°Ô∏è L·∫ßn t·∫°m ·ª©ng {i} ƒë∆∞·ª£c k√≠ch ho·∫°t v·ªõi s·ªë ti·ªÅn: {amount_value}")
                        break # T√¨m th·∫•y r·ªìi th√¨ d·ª´ng l·∫°i
                    else:
                        print(f"     - B·ªè qua: Ng∆∞·ªùi d√πng kh√¥ng ch·ªçn 'Yes' cho l·∫ßn {i} (Gi√° tr·ªã: {yes_no_value}).")
                else:
                    print(f"     - B·ªè qua: Tr·∫°ng th√°i node kh√¥ng ph·∫£i PENDING.")

            # 2.3: X·ª≠ l√Ω k·∫øt qu·∫£ t√¨m ki·∫øm
            if not active_advance_info:
                print(f"‚è≠Ô∏è  Kh√¥ng c√≥ l·∫ßn t·∫°m ·ª©ng n√†o ƒëang ho·∫°t ƒë·ªông (PENDING v√† ƒë∆∞·ª£c ch·ªçn 'Yes'). B·ªè qua t·∫°o QR.")
                return True # Coi nh∆∞ th√†nh c√¥ng v√¨ ƒë√£ x·ª≠ l√Ω ƒë√∫ng (b·ªè qua)

            # --- [LOGIC M·ªöI] K·∫øt th√∫c ph·∫ßn t√¨m ki·∫øm ---


            # --- [PH·∫¶N GI·ªÆ NGUY√äN] Ti·∫øp t·ª•c x·ª≠ l√Ω v·ªõi th√¥ng tin ƒë√£ t√¨m ƒë∆∞·ª£c ---

            # L·∫•y c√°c bi·∫øn t·ª´ k·∫øt qu·∫£ t√¨m ki·∫øm
            matching_node_id = active_advance_info['node_id']
            qr_type = active_advance_info['qr_type']
            amount_value = active_advance_info['amount']
            field_used = active_advance_info['field_used']
            node_name = active_advance_info['node_name']
            
            # B∆∞·ªõc 5: Ki·ªÉm tra duplicate TR∆Ø·ªöC KHI t·∫°o QR
            if cache_service.is_qr_recently_generated(
                instance_code, matching_node_id, qr_type, 
                settings.QR_CACHE_DURATION_MINUTES
            ):
                print(f"‚ö†Ô∏è PH√ÅT HI·ªÜN TR√ôNG L·∫∂P: QR {qr_type.upper()} cho node {node_name} ƒë√£ ƒë∆∞·ª£c t·∫°o g·∫ßn ƒë√¢y.")
                print(f"   ‚Üí B·ªé QUA t·∫°o QR ƒë·ªÉ tr√°nh tr√πng l·∫∑p.")
                return True
            
            print(f"üí∞ Chi ti·∫øt t·∫°o QR cho l·∫ßn t·∫°m ·ª©ng {active_advance_info['advance_round']}:")
            print(f"   - Lo·∫°i: {qr_type}")
            print(f"   - S·ªë ti·ªÅn: {amount_value}")
            print(f"   - Tr∆∞·ªùng s·ª≠ d·ª•ng: {field_used}")
            print(f"   - Node k√≠ch ho·∫°t: {node_name} ({matching_node_id[:8]}...)")
            
            # B∆∞·ªõc 6: Validate s·ªë ti·ªÅn
            amount_validation = self.validate_amount_value(amount_value)
            if not amount_validation['valid']:
                print(f"‚ùå S·ªë ti·ªÅn kh√¥ng h·ª£p l·ªá: {amount_validation['error']}")
                return False
                
            amount_int = amount_validation['amount']

            # B∆∞·ªõc 7: Tr√≠ch xu·∫•t th√¥ng tin ng√¢n h√†ng
            bank_id = self.field_extractor.extract_field_value(form_data, FFN.BANK_NAME)
            account_no = self.field_extractor.extract_field_value(form_data, FFN.BANK_ACCOUNT_NUMBER)
            account_name = self.field_extractor.extract_field_value(form_data, FFN.BENEFICIARY_NAME)

            if not all([bank_id, account_no, account_name]):
                missing = [f for f, v in {FFN.BANK_NAME: bank_id, FFN.BANK_ACCOUNT_NUMBER: account_no, FFN.BENEFICIARY_NAME: account_name}.items() if not v]
                print(f"‚ùå Thi·∫øu th√¥ng tin ng√¢n h√†ng: {', '.join(missing)}")
                return False
            
            # B∆∞·ªõc 8: T·∫°o m√¥ t·∫£ QR theo lo·∫°i
            description = vietqr_service.generate_qr_description(f"{qr_type}{active_advance_info['advance_round']}", instance_code)
            
            print(f"üè¶ T·∫°o VietQR v·ªõi th√¥ng tin:")
            print(f"   - Ng√¢n h√†ng: {bank_id}")
            print(f"   - S·ªë t√†i kho·∫£n: {account_no}")
            print(f"   - T√™n ng∆∞·ªùi nh·∫≠n: {account_name}")
            print(f"   - S·ªë ti·ªÅn: {amount_int:,} VND")
            print(f"   - M√¥ t·∫£: {description}")
            
            # B∆∞·ªõc 9: T·∫°o VietQR code trong b·ªô nh·ªõ
            qr_image_buffer = vietqr_service.create_qr_in_memory(
                bank_id=bank_id,
                account_no=account_no,
                amount=amount_int,
                description=description,
                account_name=account_name
            )
            
            if not qr_image_buffer:
                print("‚ùå Kh√¥ng th·ªÉ t·∫°o m√£ VietQR")
                return False
            
            # B∆∞·ªõc 10: Upload ·∫£nh l√™n Lark Approval
            filename = f"{instance_code}_{qr_type}{active_advance_info['advance_round']}_qr.png"
            upload_result = await lark_service.upload_image_to_approval(qr_image_buffer, filename, access_token)
            
            if not upload_result['success']:
                print(f"‚ùå Upload th·∫•t b·∫°i: {upload_result['error']}")
                return False
            
            # B∆∞·ªõc 11: ƒê√°nh d·∫•u ƒë√£ t·∫°o QR SAU KHI upload th√†nh c√¥ng
            cache_service.mark_qr_as_generated(instance_code, matching_node_id, qr_type)
            
            # B∆∞·ªõc 12: T·∫°o comment n√¢ng cao v·ªõi th√¥ng tin chi ti·∫øt
            comment_result = await lark_service.create_enhanced_comment_with_image(
                instance_code=instance_code,
                file_url=upload_result['file_url'],
                file_code=upload_result['file_code'],
                filename=filename,
                qr_type=f"{qr_type} L·∫ßn {active_advance_info['advance_round']}", # L√†m r√µ h∆°n trong comment
                amount=amount_int,
                node_name=node_name,
                access_token=access_token
            )
            
            if comment_result['success']:
                print(f"‚úÖ Ho√†n th√†nh x·ª≠ l√Ω ph√™ duy·ªát {instance_code}")
                print(f"üí∞ Lo·∫°i: {qr_type.upper()} L·∫¶N {active_advance_info['advance_round']} | S·ªë ti·ªÅn: {amount_int:,} VND")
                print(f"üè∑Ô∏è Node: {node_name}")
                print(f"üìã Tr∆∞·ªùng: {field_used}")
                print(f"üí¨ ID Comment: {comment_result['comment_id']}")
                return True
            else:
                print(f"‚ùå T·∫°o comment th·∫•t b·∫°i: {comment_result['error']}")
                return False
                
        except Exception as e:
            print(f"‚ùå L·ªói x·ª≠ l√Ω ph√™ duy·ªát: {e}")
            import traceback
            traceback.print_exc()
            return False

qr_processor = QRProcessor()
============================================================

============================================================
FILE: app\domains\qr_generation\services\vietqr_service.py
============================================================
import requests
from urllib.parse import quote
from PIL import Image
from io import BytesIO
from app.core.config.settings import settings
from app.domains.qr_generation.models import QRType


class VietQRService:
    """
    D·ªãch v·ª• t·∫°o m√£ QR thanh to√°n VietQR.
    
    Class n√†y cung c·∫•p c√°c ch·ª©c nƒÉng ƒë·ªÉ t·∫°o m√£ QR VietQR th√¥ng qua API,
    x·ª≠ l√Ω h√¨nh ·∫£nh v√† t·∫°o m√¥ t·∫£ ph√π h·ª£p cho t·ª´ng lo·∫°i giao d·ªãch.
    
    VietQR l√† h·ªá th·ªëng thanh to√°n QR code chu·∫©n c·ªßa Vi·ªát Nam, cho ph√©p
    t·∫°o m√£ QR ch·ª©a th√¥ng tin ng√¢n h√†ng, s·ªë ti·ªÅn v√† n·ªôi dung chuy·ªÉn kho·∫£n.
    
    Attributes:
        base_url (str): URL c∆° s·ªü c·ªßa VietQR API t·ª´ settings
    """

    def __init__(self):
        """Kh·ªüi t·∫°o VietQRService v·ªõi URL API t·ª´ c·∫•u h√¨nh."""
        self.base_url = settings.VIETQR_BASE_URL
    
    def create_qr_in_memory(self, bank_id: str, account_no: str, amount: int, 
                           description: str, account_name: str, 
                           template: str = None) -> BytesIO:
        """
        T·∫°o m√£ QR VietQR v·ªõi th√¥ng tin thanh to√°n v√† tr·∫£ v·ªÅ d·ªØ li·ªáu ·∫£nh trong b·ªô nh·ªõ.
        
        Ph∆∞∆°ng th·ª©c n√†y s·∫Ω:
        1. T·∫°o URL request ƒë·∫øn VietQR API v·ªõi c√°c tham s·ªë ƒë√£ m√£ h√≥a
        2. G·ª≠i HTTP request ƒë·ªÉ l·∫•y h√¨nh ·∫£nh QR
        3. X·ª≠ l√Ω h√¨nh ·∫£nh b·∫±ng PIL (chuy·ªÉn ƒë·ªïi format n·∫øu c·∫ßn)
        4. Tr·∫£ v·ªÅ BytesIO object ch·ª©a d·ªØ li·ªáu PNG
        
        Args:
            bank_id (str): M√£ ng√¢n h√†ng (v√≠ d·ª•: 970422 cho MB Bank)
            account_no (str): S·ªë t√†i kho·∫£n th·ª• h∆∞·ªüng
            amount (int): S·ªë ti·ªÅn giao d·ªãch (ƒë∆°n v·ªã: VND)
            description (str): N·ªôi dung chuy·ªÉn kho·∫£n (s·∫Ω ƒë∆∞·ª£c m√£ h√≥a URL)
            account_name (str): T√™n ch·ªß t√†i kho·∫£n (s·∫Ω ƒë∆∞·ª£c m√£ h√≥a URL)
            template (str, optional): Template QR. Defaults to settings.VIETQR_TEMPLATE
        
        Returns:
            BytesIO: D·ªØ li·ªáu ·∫£nh QR d·∫°ng PNG trong b·ªô nh·ªõ, ho·∫∑c None n·∫øu c√≥ l·ªói
            
        Raises:
            requests.exceptions.RequestException: L·ªói khi g·ªçi API
            PIL.UnidentifiedImageError: L·ªói khi x·ª≠ l√Ω h√¨nh ·∫£nh
        """
        # S·ª≠ d·ª•ng template m·∫∑c ƒë·ªãnh n·∫øu kh√¥ng ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh
        if template is None:
            template = settings.VIETQR_TEMPLATE
        
        # M√£ h√≥a URL cho c√°c tham s·ªë ti·∫øng Vi·ªát ƒë·ªÉ tr√°nh l·ªói encoding
        encoded_desc = quote(description)
        encoded_name = quote(account_name)
        
        # T·∫°o URL request theo format c·ªßa VietQR API
        url = (f"{self.base_url}/{bank_id}-{account_no}-{template}.jpg?"
               f"amount={amount}&addInfo={encoded_desc}&accountName={encoded_name}")
        
        print(f"üåê URL VietQR: {url}")
        
        try:
            # G·ª≠i HTTP GET request v·ªõi timeout ƒë·ªÉ tr√°nh treo
            print(f"üì° ƒêang g·ª≠i y√™u c·∫ßu t·∫°o QR ƒë·∫øn VietQR API...")
            response = requests.get(url, timeout=10)
            response.raise_for_status()  # Raise exception n·∫øu HTTP status code kh√¥ng th√†nh c√¥ng
            
            print(f"‚úÖ Nh·∫≠n ƒë∆∞·ª£c d·ªØ li·ªáu QR t·ª´ API ({len(response.content)} bytes)")
            
            # M·ªü v√† x·ª≠ l√Ω h√¨nh ·∫£nh t·ª´ response content
            image = Image.open(BytesIO(response.content))
            print(f"üñºÔ∏è ƒê√£ t·∫£i ·∫£nh QR - K√≠ch th∆∞·ªõc: {image.size}, Mode: {image.mode}")
            
            # Chuy·ªÉn ƒë·ªïi sang RGB n·∫øu ·∫£nh c√≥ mode kh√¥ng t∆∞∆°ng th√≠ch v·ªõi PNG
            # RGBA (c√≥ alpha channel), LA (grayscale + alpha), P (palette mode)
            if image.mode in ('RGBA', 'LA', 'P'):
                print(f"üîÑ Chuy·ªÉn ƒë·ªïi ·∫£nh t·ª´ mode {image.mode} sang RGB")
                image = image.convert('RGB')
            
            # T·∫°o BytesIO buffer ƒë·ªÉ l∆∞u ·∫£nh PNG
            img_buffer = BytesIO()
            image.save(img_buffer, format='PNG')
            img_buffer.seek(0)  # Reset con tr·ªü v·ªÅ ƒë·∫ßu buffer ƒë·ªÉ ƒë·ªçc t·ª´ ƒë·∫ßu
            
            print(f"‚úÖ T·∫°o m√£ VietQR th√†nh c√¥ng trong b·ªô nh·ªõ")
            print(f"üì¶ K√≠ch th∆∞·ªõc buffer: {img_buffer.getbuffer().nbytes} bytes")
            return img_buffer
            
        except requests.exceptions.Timeout:
            print(f"‚è∞ Timeout khi g·ªçi VietQR API (qu√° 10 gi√¢y)")
            return None
        except requests.exceptions.ConnectionError:
            print(f"üîå L·ªói k·∫øt n·ªëi ƒë·∫øn VietQR API")
            return None
        except requests.exceptions.HTTPError as e:
            print(f"üö´ L·ªói HTTP t·ª´ VietQR API: {e}")
            print(f"    Status code: {response.status_code}")
            return None
        except requests.exceptions.RequestException as e:
            print(f"‚ùå L·ªói request khi g·ªçi VietQR API: {e}")
            return None
        except Exception as e:
            print(f"‚ùå L·ªói kh√¥ng x√°c ƒë·ªãnh khi x·ª≠ l√Ω VietQR: {e}")
            return None

    def generate_qr_description(self, qr_type: str, instance_code: str) -> str:
        """
        T·∫°o m√¥ t·∫£ (n·ªôi dung chuy·ªÉn kho·∫£n) cho m√£ QR d·ª±a tr√™n lo·∫°i giao d·ªãch.
        
        M√¥ t·∫£ s·∫Ω ƒë∆∞·ª£c hi·ªÉn th·ªã trong n·ªôi dung chuy·ªÉn kho·∫£n c·ªßa ng√¢n h√†ng,
        gi√∫p ng∆∞·ªùi nh·∫≠n d·ªÖ d√†ng nh·∫≠n bi·∫øt m·ª•c ƒë√≠ch giao d·ªãch.
        
        Args:
            qr_type (str): Lo·∫°i QR code ('advance', 'payment', ho·∫∑c gi√° tr·ªã kh√°c)
            instance_code (str): M√£ ƒë∆°n ph√™ duy·ªát ƒë·ªÉ tham chi·∫øu
            
        Returns:
            str: N·ªôi dung m√¥ t·∫£ cho QR code
            
        Examples:
            >>> generate_qr_description('advance', 'AP123456')
            'Tam ung don AP123456'
            
            >>> generate_qr_description('payment', 'AP123456') 
            'Thanh toan don AP123456'
            
            >>> generate_qr_description('other', 'AP123456')
            'Don AP123456'
        """
        # X√°c ƒë·ªãnh m√¥ t·∫£ d·ª±a tr√™n lo·∫°i QR
        if qr_type == 'advance':
            description = f"Tam ung don {instance_code}"
            print(f"üìù T·∫°o m√¥ t·∫£ QR t·∫°m ·ª©ng: {description}")
        elif qr_type == 'payment':
            description = f"Thanh toan don {instance_code}"
            print(f"üìù T·∫°o m√¥ t·∫£ QR thanh to√°n: {description}")
        else:
            # Fallback cho c√°c lo·∫°i kh√°c
            description = f"Don {instance_code}"
            print(f"üìù T·∫°o m√¥ t·∫£ QR chung: {description}")
            
        return description

vietqr_service = VietQRService()
============================================================

============================================================
FILE: app\domains\validation\__init__.py
============================================================
# app/domains/validation/__init__.py
from .models import *
from .services import *
from .handlers import *

__all__ = [
    # Models
    "ValidationType", "ValidationResult", "ValidationResponse",
    # Services
    "validation_service",
    # Handlers  
    "validation_event_handler"
]

============================================================

============================================================
FILE: app\domains\validation\handlers\__init__.py
============================================================
from .validation_event_handler import validation_event_handler

__all__ = ["validation_event_handler"]

============================================================

============================================================
FILE: app\domains\validation\handlers\validation_event_handler.py
============================================================
"""
Validation Event Handler - B·ªô x·ª≠ l√Ω s·ª± ki·ªán validation cho h·ªá th·ªëng ph√™ duy·ªát
"""
from typing import Dict, List, Optional
import json
from app.domains.validation.services import validation_service
from app.core.infrastructure import lark_service
from app.domains.notification.services import lark_webhook_service
from app.core.infrastructure import cache_service

class ValidationEventHandler:
    """
    B·ªô x·ª≠ l√Ω s·ª± ki·ªán validation cho h·ªá th·ªëng ph√™ duy·ªát.
    
    Class n√†y ch·ªãu tr√°ch nhi·ªám:
    1. Nh·∫≠n v√† x·ª≠ l√Ω c√°c s·ª± ki·ªán ph√™ duy·ªát ƒë·ªÉ validation
    2. Ch·∫°y c√°c quy t·∫Øc validation tr√™n d·ªØ li·ªáu form v√† workflow
    3. G·ª≠i c·∫£nh b√°o qua webhook khi ph√°t hi·ªán v·∫•n ƒë·ªÅ
    4. NgƒÉn ch·∫∑n duplicate alerts ƒë·ªÉ tr√°nh spam notification
    5. X·ª≠ l√Ω l·ªói v√† g·ª≠i error alerts khi c·∫ßn thi·∫øt
    
    Attributes:
        name (str): T√™n ƒë·ªãnh danh c·ªßa service
        webhook_service: Service g·ª≠i webhook notifications
    """
    
    def __init__(self):
        """Kh·ªüi t·∫°o ValidationEventHandler v·ªõi webhook service."""
        self.name = "Validation_Service"
        self.webhook_service = lark_webhook_service

    async def handle_approval_event(self, event_data: Dict) -> Dict:
        """
        X·ª≠ l√Ω s·ª± ki·ªán ph√™ duy·ªát ƒë·ªÉ th·ª±c hi·ªán validation v·ªõi c∆° ch·∫ø anti-spam n√¢ng cao.

        [N√ÇNG C·∫§P] B·ªï sung logic ki·ªÉm tra tr·∫°ng th√°i ƒë∆°n. S·∫Ω b·ªè qua x·ª≠ l√Ω
        n·∫øu ƒë∆°n ·ªü tr·∫°ng th√°i cu·ªëi c√πng nh∆∞ REJECTED, CANCELED, DELETED.
        
        Quy tr√¨nh x·ª≠ l√Ω m·ªõi:
        1. L·∫•y d·ªØ li·ªáu instance t·ª´ Lark.
        2. Ch·∫°y t·∫•t c·∫£ c√°c validation rules.
        3. L·ªçc ra c√°c k·∫øt qu·∫£ kh√¥ng h·ª£p l·ªá (invalid).
        4. **[LOGIC M·ªöI]** L·∫∑p qua t·ª´ng l·ªói kh√¥ng h·ª£p l·ªá:
            a. D√πng `validation_type` c·ª• th·ªÉ c·ªßa l·ªói ƒë·ªÉ ki·ªÉm tra cache.
            b. N·∫øu l·ªói ch∆∞a ƒë∆∞·ª£c cache, th√™m n√≥ v√†o danh s√°ch c·∫ßn g·ª≠i c·∫£nh b√°o.
        5. N·∫øu c√≥ l·ªói c·∫ßn c·∫£nh b√°o, g·ª≠i m·ªôt webhook duy nh·∫•t ch·ª©a t·∫•t c·∫£ c√°c l·ªói m·ªõi.
        6. **[LOGIC M·ªöI]** Sau khi g·ª≠i, ghi cache cho t·ª´ng lo·∫°i l·ªói ƒë√£ ƒë∆∞·ª£c c·∫£nh b√°o.
        """
        instance_code = event_data.get('instance_code')
        if not instance_code:
            return {"success": False, "message": "Kh√¥ng t√¨m th·∫•y instance_code", "service": self.name}

        try:
            # [TH√äM M·ªöI] B·∫Øt ƒë·∫ßu kh·ªëi logic ki·ªÉm tra tr·∫°ng th√°i
            FINAL_STATUSES = ['REJECTED', 'CANCELED', 'DELETED']

            # Tr√≠ch xu·∫•t tr·∫°ng th√°i t·ª´ d·ªØ li·ªáu g·ªëc c·ªßa s·ª± ki·ªán ƒë·ªÉ tr√°nh g·ªçi API kh√¥ng c·∫ßn thi·∫øt
            raw_data = event_data.get('raw_data', {})
            instance_status = raw_data.get('event', {}).get('object', {}).get('status')

            # N·∫øu kh√¥ng c√≥ trong payload, th√¨ t√¨m trong event body
            event_body = raw_data.get('event', {})
            if not instance_status:
                instance_status = event_body.get('status')


            # Ki·ªÉm tra xem tr·∫°ng th√°i c·ªßa ƒë∆°n c√≥ n·∫±m trong danh s√°ch c·∫ßn b·ªè qua kh√¥ng
            if instance_status and instance_status in FINAL_STATUSES:
                print(f"‚è≠Ô∏è [Validation Handler] B·ªè qua instance {instance_code} do c√≥ tr·∫°ng th√°i cu·ªëi c√πng: {instance_status}")
                return {
                    "success": True, # Coi nh∆∞ th√†nh c√¥ng v√¨ ƒë√£ x·ª≠ l√Ω ƒë√∫ng (b·ªè qua)
                    "message": f"B·ªè qua validation do tr·∫°ng th√°i ƒë∆°n l√† {instance_status}",
                    "instance_code": instance_code,
                    "webhook_sent": False, # Kh√¥ng c√≥ webhook n√†o ƒë∆∞·ª£c g·ª≠i
                    "service": self.name
                }
            # [TH√äM M·ªöI] K·∫øt th√∫c kh·ªëi logic ki·ªÉm tra tr·∫°ng th√°i

            print(f"üîç [Validation Handler] D·ªãch v·ª• Validation ƒëang x·ª≠ l√Ω: {instance_code} (Tr·∫°ng th√°i: {instance_status or 'N/A'})")
            
            # B∆∞·ªõc 1 & 2: L·∫•y d·ªØ li·ªáu t·ª´ Lark
            access_token = await lark_service.get_access_token()
            if not access_token:
                return {"success": False, "message": "Kh√¥ng th·ªÉ l·∫•y access token", "service": self.name}

            api_response = await lark_service.get_approval_instance(instance_code, access_token)
            if not api_response or 'data' not in api_response:
                return {"success": False, "message": "Kh√¥ng th·ªÉ l·∫•y d·ªØ li·ªáu instance", "service": self.name}
            
            serial_number = api_response.get('data', {}).get('serial_number')
            form_data = json.loads(api_response['data'].get('form', '[]'))
            task_list = api_response['data'].get('task_list', [])
            
            # B∆∞·ªõc 3: Ch·∫°y validations v√† l·ªçc ra c√°c l·ªói
            validation_results = validation_service.run_all_validations(
                form_data, task_list, "dummy_node_id" # node_id c√≥ th·ªÉ c·∫ßn ƒë∆∞·ª£c truy·ªÅn v√†o t·ª´ event_data n·∫øu logic y√™u c·∫ßu
            )
            invalid_results = [r for r in validation_results if not r.is_valid]
            
            if not invalid_results:
                print("‚úÖ [Validation Handler] T·∫•t c·∫£ validation ƒë·ªÅu th√†nh c√¥ng.")
                return {
                    "success": True, "message": "T·∫•t c·∫£ validation ƒë·ªÅu th√†nh c√¥ng",
                    "webhook_sent": False, "webhook_skipped_count": 0,
                    "service": self.name
                }
            
            # --- PH·∫¶N LOGIC ANTI-SPAM ƒê∆Ø·ª¢C THAY TH·∫æ HO√ÄN TO√ÄN ---
            # B∆∞·ªõc 4: L·ªçc ra c√°c c·∫£nh b√°o ch∆∞a ƒë∆∞·ª£c g·ª≠i (ch∆∞a c√≥ trong cache)
            alerts_to_send = []
            skipped_count = 0
            
            print(f"‚ö†Ô∏è [Validation Handler] Ph√°t hi·ªán {len(invalid_results)} v·∫•n ƒë·ªÅ. ƒêang ki·ªÉm tra cache anti-spam...")
            for result in invalid_results:
                # T·∫†O CACHE KEY C·ª§ TH·ªÇ CHO T·ª™NG L·ªñI
                # D√πng hash c·ªßa message ƒë·ªÉ ƒë·∫£m b·∫£o m·ªói l·ªói l√† duy nh·∫•t
                specific_error_key = f"{result.validation_type.value}_{hash(result.message)}"
                
                if cache_service.is_validation_alert_recently_sent(
                    instance_code, specific_error_key, cache_duration_minutes=10
                ):
                    print(f"  üîÑ B·ªè qua (ƒë√£ cache): {result.message[:80]}...") # Log m·ªôt ph·∫ßn message
                    skipped_count += 1
                else:
                    print(f"  üÜï C·∫ßn g·ª≠i c·∫£nh b√°o cho: {result.message[:80]}...")
                    alerts_to_send.append(result)

            # B∆∞·ªõc 5: G·ª≠i webhook n·∫øu c√≥ c·∫£nh b√°o m·ªõi c·∫ßn g·ª≠i
            webhook_sent = False
            if alerts_to_send:
                error_messages = [r.message for r in alerts_to_send]
                print(f"üì® [Validation Handler] ƒêang g·ª≠i {len(error_messages)} c·∫£nh b√°o m·ªõi qua webhook...")
                
                webhook_sent = await self._send_validation_alert(instance_code, error_messages, serial_number)
                
                # B∆∞·ªõc 6: N·∫øu g·ª≠i th√†nh c√¥ng, ghi cache cho t·ª´ng l·ªói ƒë√£ g·ª≠i
                if webhook_sent:
                    print("‚úÖ [Validation Handler] G·ª≠i webhook th√†nh c√¥ng. ƒêang c·∫≠p nh·∫≠t cache...")
                    for result in alerts_to_send:
                        # D√ôNG L·∫†I CACHE KEY C·ª§ TH·ªÇ ƒê√É T·∫†O ·ªû TR√äN
                        specific_error_key = f"{result.validation_type.value}_{hash(result.message)}"
                        cache_service.mark_validation_alert_as_sent(instance_code, specific_error_key)
                        print(f"  üîí ƒê√£ cache cho: {result.message[:80]}...")
                else:
                    print("‚ùå [Validation Handler] G·ª≠i webhook th·∫•t b·∫°i.")
            else:
                print("‚úÖ [Validation Handler] Kh√¥ng c√≥ c·∫£nh b√°o m·ªõi n√†o c·∫ßn g·ª≠i. T·∫•t c·∫£ ƒë√£ ƒë∆∞·ª£c cache.")

            return {
                "success": True,
                "message": f"Ho√†n th√†nh validation. {len(alerts_to_send)} c·∫£nh b√°o m·ªõi ƒë√£ ƒë∆∞·ª£c g·ª≠i. {skipped_count} c·∫£nh b√°o b·ªã b·ªè qua do cache.",
                "alerts_sent_count": len(alerts_to_send),
                "webhook_sent": webhook_sent,
                "webhook_skipped_count": skipped_count,
                "validation_details": [r.dict() for r in validation_results],
                "service": self.name
            }
            
        except Exception as e:
            # X·ª≠ l√Ω l·ªói h·ªá th·ªëng (gi·ªØ nguy√™n logic c≈©)
            print(f"‚ùå [Validation Handler] L·ªói nghi√™m tr·ªçng trong Validation Service: {str(e)}")
            # ... (ph·∫ßn x·ª≠ l√Ω l·ªói n√†y c√≥ th·ªÉ gi·ªØ nguy√™n ho·∫∑c c·∫£i ti·∫øn sau)
            return {
                "success": False,
                "message": f"L·ªói Validation Service: {str(e)}",
                "service": self.name
            }

    async def _send_validation_alert(self, instance_code: str, error_messages: List[str], serial_number: Optional[str]) -> bool:
        """G·ª≠i c·∫£nh b√°o validation qua webhook service."""
        try:
            from app.domains.notification.models import ValidationAlertRequest, NotificationPriority
            request = ValidationAlertRequest(
                instance_code=instance_code,
                serial_number=serial_number,
                validation_errors=error_messages,
                priority=NotificationPriority.HIGH
            )
            result = await self.webhook_service.send_validation_alert(request)
            return result.success
        except Exception as e:
            print(f"‚ùå L·ªói khi g·ª≠i validation alert: {e}")
            return False

    async def _send_error_alert(self, instance_code: str, error_message: str) -> bool:
        """G·ª≠i c·∫£nh b√°o l·ªói h·ªá th·ªëng qua webhook service."""
        try:
            # Logic n√†y hi·ªán kh√¥ng ƒë∆∞·ª£c d√πng trong lu·ªìng ch√≠nh nh∆∞ng gi·ªØ l·∫°i ƒë·ªÉ c√≥ th·ªÉ d√πng sau
            result = await self.webhook_service.send_custom_alert(
                title="L·ªñI VALIDATION SERVICE",
                message=f"L·ªói x·ª≠ l√Ω validation cho {instance_code}: {error_message}",
                instance_code=instance_code
            )
            return result.success
        except Exception as e:
            print(f"‚ùå L·ªói khi g·ª≠i error alert: {e}")
            return False


validation_event_handler = ValidationEventHandler()
============================================================

============================================================
FILE: app\domains\validation\models\__init__.py
============================================================
from .validation import (
    ValidationType,
    ValidationStatus,
    ValidationResult,
    ValidationRequest,
    ValidationResponse
)

__all__ = [
    "ValidationType",
    "ValidationStatus", 
    "ValidationResult",
    "ValidationRequest",
    "ValidationResponse"
]

============================================================

============================================================
FILE: app\domains\validation\models\validation.py
============================================================
from pydantic import BaseModel
from typing import Optional, Dict, Any, List
from enum import Enum


class ValidationType(str, Enum):
    AMOUNT_SUM = "amount_sum_validation"

    ADVANCE_AMOUNT_MISMATCH = "advance_amount_mismatch"      # T·∫°m ·ª©ng
    PAYMENT_AMOUNT_MISMATCH = "payment_amount_mismatch"      # Thanh to√°n  
    TOTAL_AMOUNT_MISMATCH = "total_amount_mismatch"          # T·ªïng amount
    
    WORKFLOW_STATUS = "workflow_status_validation" 
    FIELD_CONSISTENCY = "field_consistency_validation"
    PAYMENT_CONSISTENCY = "payment_consistency_validation"
    TOTAL_PAYMENT_VALIDATION = "total_payment_validation"


class ValidationStatus(str, Enum):
    VALID = "valid"
    INVALID = "invalid"
    SKIPPED = "skipped"
    ERROR = "error"


class ValidationResult(BaseModel):
    """Enhanced validation result model with proper enums"""
    is_valid: bool
    validation_type: ValidationType
    status: ValidationStatus
    message: str
    details: Optional[Dict[str, Any]] = None
    
    @classmethod
    def create_valid(cls, validation_type: ValidationType, message: str, details: Dict = None):
        return cls(
            is_valid=True,
            validation_type=validation_type,
            status=ValidationStatus.VALID,
            message=message,
            details=details or {}
        )
    
    @classmethod
    def create_invalid(cls, validation_type: ValidationType, message: str, details: Dict = None):
        return cls(
            is_valid=False,
            validation_type=validation_type,
            status=ValidationStatus.INVALID,
            message=message,
            details=details or {}
        )
    
    @classmethod
    def create_skipped(cls, validation_type: ValidationType, message: str, details: Dict = None):
        return cls(
            is_valid=True,  # Skipped is not a failure
            validation_type=validation_type,
            status=ValidationStatus.SKIPPED,
            message=message,
            details=details or {}
        )
    
    @classmethod
    def create_error(cls, validation_type: ValidationType, message: str, details: Dict = None):
        return cls(
            is_valid=False,
            validation_type=validation_type,
            status=ValidationStatus.ERROR,
            message=message,
            details=details or {}
        )


class ValidationRequest(BaseModel):
    instance_code: str
    form_data: List[Dict[str, Any]]
    task_list: List[Dict[str, Any]]
    node_id: Optional[str] = None


class ValidationResponse(BaseModel):
    success: bool
    instance_code: str
    validation_results: List[ValidationResult]
    invalid_count: int
    total_validations: int
    alerts_sent: bool = False
    webhook_sent: bool = False
    message: Optional[str] = None
============================================================

============================================================
FILE: app\domains\validation\routers\notification.py
============================================================
from fastapi import APIRouter
from app.domains.notification.models import NotificationRequest, NotificationResult
from app.domains.notification.services.notification_coordinator import notification_coordinator

router = APIRouter(prefix="/notification", tags=["Notification"])

@router.post("/send", response_model=NotificationResult)
async def send_notification(request: NotificationRequest):
    """Manual g·ª≠i notification"""
    return await notification_coordinator.send_notification(request)

@router.get("/channels")
async def get_notification_channels():
    """Xem danh s√°ch notification channels"""
    from app.domains.notification.models import NotificationChannel, NotificationType
    return {
        "channels": [ch.value for ch in NotificationChannel],
        "types": [nt.value for nt in NotificationType],
        "supported_combinations": {
            "lark_webhook": ["validation_alert", "custom_alert", "service_error"]
        }
    }

@router.get("/cache/status")
async def get_notification_cache_status():
    """Xem tr·∫°ng th√°i notification cache"""
    from app.core.infrastructure.cache_service import cache_service
    cache_status = cache_service.get_cache_status()
    return cache_status.get('validation_cache', {})

============================================================

============================================================
FILE: app\domains\validation\routers\validation.py
============================================================
from fastapi import APIRouter
from app.domains.validation.models import ValidationRequest, ValidationResponse
from app.domains.validation.services.validation_service import validation_service

router = APIRouter(prefix="/validation", tags=["Validation"])

@router.post("/validate", response_model=ValidationResponse)
async def validate_instance(request: ValidationRequest):
    """Manual validation c·ªßa m·ªôt instance"""
    try:
        # Ch·∫°y validations
        validation_results = validation_service.run_all_validations(
            request.form_data, 
            request.task_list, 
            request.node_id or "manual_validation"
        )
        
        invalid_count = len([r for r in validation_results if not r.is_valid])
        
        return ValidationResponse(
            success=True,
            instance_code=request.instance_code,
            validation_results=validation_results,
            invalid_count=invalid_count,
            total_validations=len(validation_results),
            message=f"Completed {len(validation_results)} validations, {invalid_count} issues found"
        )
        
    except Exception as e:
        return ValidationResponse(
            success=False,
            instance_code=request.instance_code,
            validation_results=[],
            invalid_count=0,
            total_validations=0,
            message=f"Validation error: {str(e)}"
        )

@router.get("/rules")
async def get_validation_rules():
    """Xem danh s√°ch validation rules"""
    from app.domains.validation.models import ValidationType
    return {
        "available_rules": [vt.value for vt in ValidationType],
        "total_rules": len(ValidationType)
    }

============================================================

============================================================
FILE: app\domains\validation\services\__init__.py
============================================================
# app/domains/validation/services/__init__.py
from .validation_service import validation_service

__all__ = ["validation_service"]

============================================================

============================================================
FILE: app\domains\validation\services\validation_service.py
============================================================
"""
Validation Service - D·ªãch v·ª• domain cho c√°c quy t·∫Øc validation
"""
from typing import Dict, List, Any, Optional
from app.domains.validation.models import ValidationResult, ValidationType, ValidationStatus
from app.core.utils.field_extractor import FieldExtractor
from app.core.config.field_constants import FFN

class ValidationService:
    """
    D·ªãch v·ª• validation cho h·ªá th·ªëng ph√™ duy·ªát.
    
    Class n√†y cung c·∫•p c√°c quy t·∫Øc validation kh√°c nhau ƒë·ªÉ ki·ªÉm tra
    t√≠nh nh·∫•t qu√°n v√† h·ª£p l·ªá c·ªßa d·ªØ li·ªáu trong quy tr√¨nh ph√™ duy·ªát:
    
    - ADVANCE_AMOUNT_MISMATCH: So s√°nh t·ªïng s·ªë ti·ªÅn t·∫°m ·ª©ng
    - PAYMENT_AMOUNT_MISMATCH: So s√°nh s·ªë ti·ªÅn thanh to√°n
    - TOTAL_AMOUNT_MISMATCH: Ki·ªÉm tra t·ªïng s·ªë ti·ªÅn thanh to√°n
    - WORKFLOW_STATUS: Ki·ªÉm tra tr·∫°ng th√°i node
    - FIELD_CONSISTENCY: Ki·ªÉm tra logic gi·ªØa c√°c tr∆∞·ªùng
    
    M·ªói validation s·∫Ω tr·∫£ v·ªÅ ValidationResult v·ªõi m·ªôt trong c√°c tr·∫°ng th√°i:
    - VALID: Validation pass
    - INVALID: Validation fail  
    - SKIPPED: B·ªè qua do thi·∫øu d·ªØ li·ªáu
    - ERROR: C√≥ l·ªói trong qu√° tr√¨nh validation
    
    Attributes:
        field_extractor (FieldExtractor): C√¥ng c·ª• tr√≠ch xu·∫•t d·ªØ li·ªáu t·ª´ form
        validation_rules (Dict): Map t·ª´ validation type ƒë·∫øn method t∆∞∆°ng ·ª©ng
    """
    
    def __init__(self):
        """Kh·ªüi t·∫°o ValidationService v·ªõi field extractor v√† mapping rules."""
        self.field_extractor = FieldExtractor()
        
        self.validation_rules = {
            ValidationType.ADVANCE_AMOUNT_MISMATCH: self.validate_advance_amount_mismatch,
            ValidationType.PAYMENT_AMOUNT_MISMATCH: self.validate_payment_amount_mismatch,
            #ValidationType.TOTAL_AMOUNT_MISMATCH: self.validate_total_amount_mismatch,
            ValidationType.WORKFLOW_STATUS: self.validate_workflow_status,
            ValidationType.FIELD_CONSISTENCY: self.validate_field_consistency,
        }
    
    # Thay v√¨ tr·∫£ v·ªÅ ValidationResult, gi·ªù ƒë√¢y h√†m s·∫Ω tr·∫£ v·ªÅ List[ValidationResult]
    def validate_advance_amount_mismatch(self, form_data: List[Dict], **kwargs) -> List[ValidationResult]:
        """
        Tr·∫£ v·ªÅ m·ªôt danh s√°ch c√°c ValidationResult, m·ªói result cho m·ªôt l·ªói.
        """
        try:
            accountant_expenditures = self.field_extractor.extract_all_values_from_fieldlist(
                form_data, FFN.ACCOUNTING_ADVANCE_INFO, FFN.EXPENDITURE_AMOUNT
            )
            
            results = []
            found_data = False

            for i in range(1, 5): # Ch·ªâ ki·ªÉm tra 4 l·∫ßn
                user_advance_field = f"S·ªë ti·ªÅn t·∫°m ·ª©ng l·∫ßn {i}:"
                user_advance_value = self.field_extractor.extract_field_value(form_data, user_advance_field)
                
                if user_advance_value is not None:
                    found_data = True

                if (i - 1) >= len(accountant_expenditures) or user_advance_value is None:
                    continue
                
                accountant_expenditure_value = accountant_expenditures[i-1]
                
                try:
                    user_amount = float(user_advance_value)
                    accountant_amount = float(accountant_expenditure_value)
                    
                    if abs(user_amount - accountant_amount) >= 0.01:
                        message = (f"‚ùå L·ªói T·∫°m ·ª©ng L·∫ßn {i}: Y√™u c·∫ßu ({user_amount:,.0f}) ‚â† K·∫ø to√°n chi ({accountant_amount:,.0f}). "
                                f"L·ªách: {abs(user_amount - accountant_amount):,.0f} VND")
                        # T·∫°o m·ªôt result ri√™ng cho l·ªói n√†y
                        results.append(ValidationResult.create_invalid(ValidationType.ADVANCE_AMOUNT_MISMATCH, message))
                except (ValueError, TypeError):
                    message = f"‚ùå L·ªói ƒë·ªãnh d·∫°ng s·ªë T·∫°m ·ª©ng L·∫ßn {i}."
                    results.append(ValidationResult.create_invalid(ValidationType.ADVANCE_AMOUNT_MISMATCH, message))

            # N·∫øu kh√¥ng c√≥ l·ªói n√†o ƒë∆∞·ª£c t√¨m th·∫•y v√† c√≥ d·ªØ li·ªáu ƒë·ªÉ ki·ªÉm tra
            if not results and found_data:
                results.append(ValidationResult.create_valid(
                    ValidationType.ADVANCE_AMOUNT_MISMATCH,
                    "‚úÖ T·∫•t c·∫£ c√°c l·∫ßn t·∫°m ·ª©ng ƒë√£ kh·ªõp."
                ))
            
            # N·∫øu kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ ki·ªÉm tra
            if not found_data:
                results.append(ValidationResult.create_skipped(
                    ValidationType.ADVANCE_AMOUNT_MISMATCH,
                    "‚ÑπÔ∏è B·ªè qua: Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu t·∫°m ·ª©ng ƒë·ªÉ so s√°nh."
                ))
            
            return results
                
        except Exception as e:
            return [ValidationResult.create_error(
                ValidationType.ADVANCE_AMOUNT_MISMATCH,
                f"‚ùå L·ªói h·ªá th·ªëng khi validation ti·ªÅn t·∫°m ·ª©ng: {e}",
            )]

    def validate_payment_amount_mismatch(self, form_data: List[Dict], **kwargs) -> ValidationResult:
        """
        Validation t√≠nh nh·∫•t qu√°n s·ªë ti·ªÅn thanh to√°n (gi·ªØ nguy√™n logic c≈©).
        
        So s√°nh "K·∫ø to√°n - Th√¥ng tin thanh to√°n" v·ªõi "S·ªë ti·ªÅn c√≤n ph·∫£i thanh to√°n" 
        ho·∫∑c "S·ªë ti·ªÅn thanh to√°n".
        """
        try:
            payment_info_amount = self.field_extractor.extract_field_from_fieldlist(
                form_data,  FFN.ACCOUNTING_PAYMENT_INFO, FFN.EXPENDITURE_AMOUNT
            )
            amount_due = self.field_extractor.extract_field_value(
                form_data,  FFN.REMAINING_PAYMENT_AMOUNT
            )
            amount_paid = self.field_extractor.extract_field_value(
                form_data, FFN.PAYMENT_AMOUNT
            )
            
            compare_amount = amount_due if amount_due is not None else amount_paid
            compare_field_name = FFN.REMAINING_PAYMENT_AMOUNT if amount_due is not None else FFN.PAYMENT_AMOUNT

            if payment_info_amount is None or compare_amount is None:
                return ValidationResult.create_skipped(
                    ValidationType.PAYMENT_AMOUNT_MISMATCH,
                    "‚ÑπÔ∏è B·ªè qua: Kh√¥ng t√¨m th·∫•y ƒë·ªß c√°c tr∆∞·ªùng v·ªÅ s·ªë ti·ªÅn thanh to√°n ƒë·ªÉ so s√°nh."
                )

            payment_info_float = float(payment_info_amount)
            compare_amount_float = float(compare_amount)

            if abs(payment_info_float - compare_amount_float) < 0.01:
                return ValidationResult.create_valid(
                    ValidationType.PAYMENT_AMOUNT_MISMATCH,
                    f"‚úÖ S·ªë ti·ªÅn thanh to√°n nh·∫•t qu√°n: {payment_info_float:,.0f} VND"
                )
            else:
                message = (f"‚ùå L·ªói thanh to√°n: 'K·∫ø to√°n' ({payment_info_float:,.0f}) ‚â† "
                           f"'{compare_field_name}' ({compare_amount_float:,.0f}). "
                           f"Ch√™nh l·ªách: {abs(payment_info_float - compare_amount_float):,.0f} VND")
                details = {"payment_info_amount": payment_info_float, "compare_amount": compare_amount_float}
                return ValidationResult.create_invalid(ValidationType.PAYMENT_AMOUNT_MISMATCH, message, details)
        except (ValueError, TypeError) as e:
            return ValidationResult.create_error(
                ValidationType.PAYMENT_AMOUNT_MISMATCH, f"‚ùå L·ªói ƒë·ªãnh d·∫°ng s·ªë ti·ªÅn thanh to√°n: {e}",
            )
        except Exception as e:
            return ValidationResult.create_error(
                ValidationType.PAYMENT_AMOUNT_MISMATCH, f"‚ùå L·ªói kh√¥ng x√°c ƒë·ªãnh khi validation ti·ªÅn thanh to√°n: {e}",
            )

    def validate_total_amount_mismatch(self, form_data: List[Dict], **kwargs) -> ValidationResult:
        """
        Validation t·ªïng s·ªë ti·ªÅn thanh to√°n d·ª±a tr√™n c√°c kho·∫£n chi ƒë√£ ƒë∆∞·ª£c k·∫ø to√°n x√°c nh·∫≠n.
        
        C√¥ng th·ª©c: Total = (T·ªïng c√°c kho·∫£n chi trong FieldList "K·∫ø to√°n - Th√¥ng tin t·∫°m ·ª©ng") + (S·ªë ti·ªÅn c√≤n ph·∫£i thanh to√°n).
        """
        try:
            # L·∫•y t·ªïng c√°c kho·∫£n chi t·∫°m ·ª©ng TH·ª∞C T·∫æ t·ª´ k·∫ø to√°n
            accountant_expenditures = self.field_extractor.extract_all_values_from_fieldlist(
                form_data, FFN.ACCOUNTING_ADVANCE_INFO, FFN.EXPENDITURE_AMOUNT
            )
            total_accountant_advance = sum(float(v) for v in accountant_expenditures if v is not None and str(v).strip() != '')

            # L·∫•y c√°c tr∆∞·ªùng c√≤n l·∫°i
            amount_due = self.field_extractor.extract_field_value(form_data, FFN.REMAINING_PAYMENT_AMOUNT)
            total_payment_actual = self.field_extractor.extract_field_value(form_data, FFN.TOTAL_PAYMENT_AMOUNT)

            if total_accountant_advance == 0 and amount_due is None:
                return ValidationResult.create_skipped(
                    ValidationType.TOTAL_AMOUNT_MISMATCH,
                    f"‚ÑπÔ∏è B·ªè qua: K·∫ø to√°n ch∆∞a ƒëi·ªÅn th√¥ng tin chi ho·∫∑c s·ªë ti·ªÅn c√≤n l·∫°i."
                )

            if total_payment_actual is None:
                return ValidationResult.create_skipped(
                    ValidationType.TOTAL_AMOUNT_MISMATCH,
                    f"‚ÑπÔ∏è B·ªè qua: Kh√¥ng t√¨m th·∫•y tr∆∞·ªùng '{FFN.TOTAL_PAYMENT_AMOUNT}' ƒë·ªÉ t√≠nh t·ªïng."
                )

            amount_due_float = float(amount_due) if amount_due is not None else 0.0
            total_actual_float = float(total_payment_actual)
            
            total_expected = total_accountant_advance + amount_due_float

            if abs(total_expected - total_actual_float) < 0.01:
                return ValidationResult.create_valid(
                    ValidationType.TOTAL_AMOUNT_MISMATCH,
                    f"‚úÖ T·ªïng s·ªë ti·ªÅn h·ª£p l·ªá: {total_actual_float:,.0f} VND"
                )
            else:
                case_description = f"T·ªïng K·∫ø to√°n chi ({total_accountant_advance:,.0f}) + C√≤n L·∫°i ({amount_due_float:,.0f})"
                message = (f"‚ùå L·ªói t·ªïng ti·ªÅn: Th·ª±c t·∫ø ({total_actual_float:,.0f}) ‚â† "
                        f"D·ª± ki·∫øn ({total_expected:,.0f} t·ª´ {case_description}). "
                        f"Ch√™nh l·ªách: {abs(total_expected - total_actual_float):,.0f} VND")
                details = {
                    "total_expected": total_expected, 
                    "total_actual": total_actual_float,
                    "total_accountant_advance": total_accountant_advance,
                    "remaining_payment": amount_due_float
                }
                return ValidationResult.create_invalid(ValidationType.TOTAL_AMOUNT_MISMATCH, message, details)
        except (ValueError, TypeError) as e:
            return ValidationResult.create_error(
                ValidationType.TOTAL_AMOUNT_MISMATCH, f"‚ùå L·ªói ƒë·ªãnh d·∫°ng s·ªë khi t√≠nh t·ªïng ti·ªÅn: {e}",
            )
        except Exception as e:
            return ValidationResult.create_error(
                ValidationType.TOTAL_AMOUNT_MISMATCH, f"‚ùå L·ªói kh√¥ng x√°c ƒë·ªãnh khi validation t·ªïng ti·ªÅn: {e}",
            )
    
    def validate_workflow_status(self, task_list: List[Dict], node_id: str, **kwargs) -> ValidationResult:
        """
        Validation tr·∫°ng th√°i workflow ƒë·ªÉ ph√°t hi·ªán node b·ªã thu h·ªìi.
        """
        try:
            target_node = next((task for task in task_list if task.get('node_id') == node_id), None)
            
            if not target_node:
                return ValidationResult.create_skipped(
                    ValidationType.WORKFLOW_STATUS,
                    f"‚ÑπÔ∏è B·ªè qua: Node {node_id[:8]}... kh√¥ng t√¨m th·∫•y trong danh s√°ch task"
                )
            
            current_status = target_node.get('status', 'UNKNOWN')
            problematic_statuses = ['REJECTED', 'CANCELED', 'WITHDRAWN']
            if current_status in problematic_statuses:
                return ValidationResult.create_invalid(
                    ValidationType.WORKFLOW_STATUS,
                    f"‚ö†Ô∏è C·∫¢NH B√ÅO: Node {node_id[:8]}... c√≥ tr·∫°ng th√°i {current_status} - c√≥ th·ªÉ ƒë√£ b·ªã thu h·ªìi ho·∫∑c t·ª´ ch·ªëi"
                )
            
            return ValidationResult.create_valid(
                ValidationType.WORKFLOW_STATUS,
                f"‚úÖ Node {node_id[:8]}... c√≥ tr·∫°ng th√°i b√¨nh th∆∞·ªùng: {current_status}"
            )
        except Exception as e:
            return ValidationResult.create_error(
                ValidationType.WORKFLOW_STATUS,
                f"‚ùå L·ªói ki·ªÉm tra tr·∫°ng th√°i workflow: {str(e)}"
            )
    
    def validate_field_consistency(self, form_data: List[Dict], **kwargs) -> ValidationResult:
        """
        Placeholder cho c√°c logic validation v·ªÅ t√≠nh nh·∫•t qu√°n c·ªßa c√°c tr∆∞·ªùng kh√°c.
        """
        return ValidationResult.create_valid(
            ValidationType.FIELD_CONSISTENCY,
            "‚úÖ Ki·ªÉm tra t√≠nh nh·∫•t qu√°n c√°c tr∆∞·ªùng th√†nh c√¥ng (placeholder)"
        )
    
    def run_validation(self, validation_type: ValidationType, **kwargs) -> ValidationResult:
        """
        Ch·∫°y m·ªôt quy t·∫Øc validation c·ª• th·ªÉ.
        """
        if validation_type in self.validation_rules:
            return self.validation_rules[validation_type](**kwargs)
        else:
            return ValidationResult.create_error(
                validation_type,
                f"‚ùå Lo·∫°i validation kh√¥ng x√°c ƒë·ªãnh: {validation_type}"
            )
    
    def run_all_validations(self, form_data: List[Dict], task_list: List[Dict], 
                           node_id: str) -> List[ValidationResult]:
        """
        Ch·∫°y t·∫•t c·∫£ c√°c validation rules ƒë√£ ƒë∆∞·ª£c ƒëƒÉng k√Ω.
        """
        print(f"üöÄ B·∫Øt ƒë·∫ßu ch·∫°y t·∫•t c·∫£ validation cho node {node_id[:8]}...")
        results = []
        
        for validation_type in self.validation_rules.keys():
            print(f"‚ñ∂Ô∏è ƒêang ch·∫°y: {validation_type.value}...")
            # S·ª≠ d·ª•ng extend ƒë·ªÉ x·ª≠ l√Ω vi·ªác m·ªôt rule c√≥ th·ªÉ tr·∫£ v·ªÅ nhi·ªÅu result
            validation_func = self.validation_rules[validation_type]
            
            # C·∫ßn ki·ªÉm tra xem h√†m c√≥ tr·∫£ v·ªÅ list hay kh√¥ng
            # V√¨ c√°c h√†m kh√°c v·∫´n tr·∫£ v·ªÅ 1 result ƒë∆°n l·∫ª
            result_or_list = validation_func(
                form_data=form_data,
                task_list=task_list,
                node_id=node_id
            )

            if isinstance(result_or_list, list):
                results.extend(result_or_list)
            else:
                results.append(result_or_list)

        invalid_count = sum(1 for r in results if not r.is_valid)
        print(f"üìà Ho√†n th√†nh validation: T√¨m th·∫•y {invalid_count} v·∫•n ƒë·ªÅ.")
        
        return results

validation_service = ValidationService()
============================================================

============================================================
FILE: README.md
============================================================
1. Lark Platform ‚îÄ‚îÄPOST‚îÄ‚îÄ‚ñ∫ handle_lark_webhook()
                              ‚îÇ
2. Extract & Filter ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
                              ‚îÇ
3. event_bus.publish("approval.instance.updated", data)
                              ‚îÇ
4. EventBus ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    ‚îÇ
    ‚îú‚îÄ Save to event_history[]
    ‚îÇ
    ‚îú‚îÄ Find registered handlers for "approval.instance.updated"
    ‚îÇ
    ‚îî‚îÄ asyncio.gather() ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚ñ∫ _run_handler_safe(qr_handler, data)
                          ‚îÇ      ‚îÇ
                          ‚îÇ      ‚îî‚îÄ‚îÄ‚ñ∫ QRHandler.handle() ‚îÄ‚îÄ‚ñ∫ Generate QR
                          ‚îÇ
                          ‚îî‚îÄ‚îÄ‚ñ∫ _run_handler_safe(validation_handler, data)  
                                 ‚îÇ
                                 ‚îî‚îÄ‚îÄ‚ñ∫ ValidationHandler.handle() ‚îÄ‚îÄ‚ñ∫ Send Alert
5. Results ‚îÄ‚îÄ‚ñ∫ Log success/failure cho m·ªói handler



4. EventBus ‚îÄ‚îÄ‚ñ∫ asyncio.gather() ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚ñ∫ _run_handler_safe(qr_handler, data)
                                   ‚îÇ      ‚îÇ
                                   ‚îÇ      ‚îî‚îÄ‚îÄ‚ñ∫ QRHandler.handle() 
                                   ‚îÇ             ‚îÇ
                                   ‚îÇ             ‚ñº
                                   ‚îÇ      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                                   ‚îÇ      ‚îÇ    QR Generation Flow       ‚îÇ
                                   ‚îÇ      ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
                                   ‚îÇ      ‚îÇ 1. Extract instance_code    ‚îÇ
                                   ‚îÇ      ‚îÇ    ‚Üì                        ‚îÇ
                                   ‚îÇ      ‚îÇ 2. lark_service.get_instance(instance_code)
                                   ‚îÇ      ‚îÇ    ‚Üì (API Call)             ‚îÇ
                                   ‚îÇ      ‚îÇ 3. Lark API ‚îÄ‚îÄ‚ñ∫ Instance Data
                                   ‚îÇ      ‚îÇ    ‚Üì                        ‚îÇ
                                   ‚îÇ      ‚îÇ 4. Check NODE_CONFIG        ‚îÇ
                                   ‚îÇ      ‚îÇ    ‚îú‚îÄ Valid Node? ‚îÄ‚îÄ‚ñ∫ Continue
                                   ‚îÇ      ‚îÇ    ‚îî‚îÄ Invalid? ‚îÄ‚îÄ‚ñ∫ Skip & Return
                                   ‚îÇ      ‚îÇ    ‚Üì                        ‚îÇ
                                   ‚îÇ      ‚îÇ 5. cache_service.check()    ‚îÇ
                                   ‚îÇ      ‚îÇ    key: "qr:{instance}:{node}"
                                   ‚îÇ      ‚îÇ    ‚îú‚îÄ Exists? ‚îÄ‚îÄ‚ñ∫ Skip (Duplicate)
                                   ‚îÇ      ‚îÇ    ‚îî‚îÄ Not exists? ‚îÄ‚îÄ‚ñ∫ Continue
                                   ‚îÇ      ‚îÇ    ‚Üì                        ‚îÇ
                                   ‚îÇ      ‚îÇ 6. amount_detector.extract()‚îÇ
                                   ‚îÇ      ‚îÇ    ‚îÄ‚îÄ‚ñ∫ Parse amount from form
                                   ‚îÇ      ‚îÇ    ‚Üì                        ‚îÇ
                                   ‚îÇ      ‚îÇ 7. vietqr_service.generate()‚îÇ
                                   ‚îÇ      ‚îÇ    ‚îÄ‚îÄ‚ñ∫ VietQR API Call     ‚îÇ
                                   ‚îÇ      ‚îÇ    ‚îÄ‚îÄ‚ñ∫ Get QR image bytes  ‚îÇ
                                   ‚îÇ      ‚îÇ    ‚Üì                        ‚îÇ
                                   ‚îÇ      ‚îÇ 8. lark_service.upload_image()
                                   ‚îÇ      ‚îÇ    ‚îÄ‚îÄ‚ñ∫ Lark API ‚îÄ‚îÄ‚ñ∫ file_code
                                   ‚îÇ      ‚îÇ    ‚Üì                        ‚îÇ
                                   ‚îÇ      ‚îÇ 9. lark_service.post_comment()
                                   ‚îÇ      ‚îÇ    ‚îÄ‚îÄ‚ñ∫ Post QR to approval  ‚îÇ
                                   ‚îÇ      ‚îÇ    ‚Üì                        ‚îÇ
                                   ‚îÇ      ‚îÇ10. cache_service.set()      ‚îÇ
                                   ‚îÇ      ‚îÇ    ‚îÄ‚îÄ‚ñ∫ Mark QR created (15min TTL)
                                   ‚îÇ      ‚îÇ    ‚Üì                        ‚îÇ
                                   ‚îÇ      ‚îÇ‚úÖ Return success            ‚îÇ
                                   ‚îÇ      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                   ‚îÇ
                                   ‚îî‚îÄ‚îÄ‚ñ∫ _run_handler_safe(validation_handler, data)
                                          ‚îÇ
                                          ‚îî‚îÄ‚îÄ‚ñ∫ ValidationHandler.handle()
                                                 ‚îÇ
                                                 ‚ñº
                                        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                                        ‚îÇ   Validation & Alert Flow   ‚îÇ
                                        ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
                                        ‚îÇ 1. Extract instance_code    ‚îÇ
                                        ‚îÇ    ‚Üì                        ‚îÇ
                                        ‚îÇ 2. lark_service.get_instance()
                                        ‚îÇ    ‚Üì (API Call)             ‚îÇ
                                        ‚îÇ 3. Lark API ‚îÄ‚îÄ‚ñ∫ Instance Data
                                        ‚îÇ    ‚Üì                        ‚îÇ
                                        ‚îÇ 4. validation_service.validate()
                                        ‚îÇ    ‚îú‚îÄ Check amount consistency
                                        ‚îÇ    ‚îú‚îÄ Verify required fields‚îÇ
                                        ‚îÇ    ‚îú‚îÄ Business rule validation
                                        ‚îÇ    ‚îî‚îÄ Return errors[]       ‚îÇ
                                        ‚îÇ    ‚Üì                        ‚îÇ
                                        ‚îÇ 5. Check validation results ‚îÇ
                                        ‚îÇ    ‚îú‚îÄ No errors? ‚îÄ‚îÄ‚ñ∫ Skip & Return
                                        ‚îÇ    ‚îî‚îÄ Has errors? ‚îÄ‚îÄ‚ñ∫ Continue
                                        ‚îÇ    ‚Üì                        ‚îÇ
                                        ‚îÇ 6. cache_service.check()    ‚îÇ
                                        ‚îÇ    key: "alert:{instance}:{hash}"
                                        ‚îÇ    ‚îú‚îÄ Exists? ‚îÄ‚îÄ‚ñ∫ Skip (Duplicate)
                                        ‚îÇ    ‚îî‚îÄ Not exists? ‚îÄ‚îÄ‚ñ∫ Continue
                                        ‚îÇ    ‚Üì                        ‚îÇ
                                        ‚îÇ 7. notification_coordinator.send()
                                        ‚îÇ    ‚îÄ‚îÄ‚ñ∫ Format alert message ‚îÇ
                                        ‚îÇ    ‚Üì                        ‚îÇ
                                        ‚îÇ 8. lark_webhook_service.send()
                                        ‚îÇ    ‚îÄ‚îÄ‚ñ∫ Call Lark Bot API   ‚îÇ
                                        ‚îÇ    ‚îÄ‚îÄ‚ñ∫ Send to user/group  ‚îÇ
                                        ‚îÇ    ‚Üì                        ‚îÇ
                                        ‚îÇ 9. cache_service.set()      ‚îÇ
                                        ‚îÇ    ‚îÄ‚îÄ‚ñ∫ Mark alert sent (15min TTL)
                                        ‚îÇ    ‚Üì                        ‚îÇ
                                        ‚îÇ‚úÖ Return success            ‚îÇ
                                        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
============================================================

============================================================
FILE: requirements.txt
============================================================
fastapi==0.104.1
uvicorn[standard]==0.24.0
requests==2.31.0
pandas==2.1.3
Pillow==10.1.0
python-multipart==0.0.6
pydantic==2.5.0

============================================================


üìä TH·ªêNG K√ä
------------------------------
T·ªïng s·ªë file: 53
File code: 49
C√°c lo·∫°i file code:
  .md: 1 file
  .py: 46 file
  .txt: 2 file
