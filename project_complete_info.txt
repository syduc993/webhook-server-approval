================================================================================
THÔNG TIN DỰ ÁN HOÀN CHỈNH
================================================================================
Thời gian tạo: 2025-10-03 14:17:39
Thư mục gốc: d:\Atino\extension\webhook-server-approval
================================================================================

📁 CẤU TRÚC THU MỤC
--------------------------------------------------
├── 📁 app/
│   ├── 📁 api/
│   ├── 📁 core/
│   │   ├── 📁 bootstrap/
│   │   │   └── 📄 application.py
│   │   ├── 📁 config/
│   │   │   ├── 📄 __init__.py
│   │   │   ├── 📄 field_constants.py
│   │   │   ├── 📄 node_config.py
│   │   │   └── 📄 settings.py
│   │   ├── 📁 events/
│   │   │   └── 📄 event_registry.py
│   │   ├── 📁 infrastructure/
│   │   │   ├── 📄 __init__.py
│   │   │   ├── 📄 cache_service.py
│   │   │   ├── 📄 event_bus.py
│   │   │   └── 📄 lark_service.py
│   │   ├── 📁 models/
│   │   │   ├── 📄 event.py
│   │   │   ├── 📄 response.py
│   │   │   └── 📄 shared.py
│   │   ├── 📁 routers/
│   │   │   ├── 📄 monitoring.py
│   │   │   └── 📄 webhook.py
│   │   ├── 📁 utils/
│   │   │   ├── 📄 __init__.py
│   │   │   ├── 📄 amount_detector.py
│   │   │   ├── 📄 field_extractor.py
│   │   │   └── 📄 helpers.py
│   │   └── 📄 __init__.py
│   └── 📁 domains/
│       ├── 📁 notification/
│       │   ├── 📁 models/
│       │   │   ├── 📄 __init__.py
│       │   │   └── 📄 notification.py
│       │   ├── 📁 services/
│       │   │   ├── 📄 __init__.py
│       │   │   ├── 📄 lark_webhook_service.py
│       │   │   └── 📄 notification_coordinator.py
│       │   └── 📄 __init__.py
│       ├── 📁 qr_generation/
│       │   ├── 📁 handlers/
│       │   │   ├── 📄 __init__.py
│       │   │   └── 📄 qr_event_handler.py
│       │   ├── 📁 models/
│       │   │   ├── 📄 __init__.py
│       │   │   └── 📄 qr.py
│       │   ├── 📁 routers/
│       │   │   └── 📄 qr.py
│       │   ├── 📁 services/
│       │   │   ├── 📄 __init__.py
│       │   │   ├── 📄 amount_detector.py
│       │   │   ├── 📄 qr_processor.py
│       │   │   └── 📄 vietqr_service.py
│       │   └── 📄 __init__.py
│       ├── 📁 validation/
│       │   ├── 📁 handlers/
│       │   │   ├── 📄 __init__.py
│       │   │   └── 📄 validation_event_handler.py
│       │   ├── 📁 models/
│       │   │   ├── 📄 __init__.py
│       │   │   └── 📄 validation.py
│       │   ├── 📁 routers/
│       │   │   ├── 📄 notification.py
│       │   │   └── 📄 validation.py
│       │   ├── 📁 services/
│       │   │   ├── 📄 __init__.py
│       │   │   └── 📄 validation_service.py
│       │   └── 📄 __init__.py
│       └── 📄 __init__.py
├── 📄 .gitignore
├── 📄 Dockerfile
├── 📄 Get detail code.ipynb
├── 📄 lark_events.csv
├── 📄 project_complete_info.txt
├── 📄 README.md
└── 📄 requirements.txt


📄 DANH SÁCH TẤT CẢ FILE
--------------------------------------------------
.gitignore (594 bytes)
app\core\__init__.py (376 bytes)
app\core\bootstrap\application.py (8435 bytes)
app\core\config\__init__.py (271 bytes)
app\core\config\field_constants.py (1232 bytes)
app\core\config\node_config.py (5382 bytes)
app\core\config\settings.py (3520 bytes)
app\core\events\event_registry.py (2702 bytes)
app\core\infrastructure\__init__.py (176 bytes)
app\core\infrastructure\cache_service.py (11934 bytes)
app\core\infrastructure\event_bus.py (5703 bytes)
app\core\infrastructure\lark_service.py (11949 bytes)
app\core\models\event.py (899 bytes)
app\core\models\response.py (1015 bytes)
app\core\models\shared.py (553 bytes)
app\core\routers\monitoring.py (1619 bytes)
app\core\routers\webhook.py (2919 bytes)
app\core\utils\__init__.py (332 bytes)
app\core\utils\amount_detector.py (10162 bytes)
app\core\utils\field_extractor.py (12805 bytes)
app\core\utils\helpers.py (2198 bytes)
app\domains\__init__.py (593 bytes)
app\domains\notification\__init__.py (262 bytes)
app\domains\notification\models\__init__.py (425 bytes)
app\domains\notification\models\notification.py (1578 bytes)
app\domains\notification\services\__init__.py (235 bytes)
app\domains\notification\services\lark_webhook_service.py (12787 bytes)
app\domains\notification\services\notification_coordinator.py (8726 bytes)
app\domains\qr_generation\__init__.py (251 bytes)
app\domains\qr_generation\handlers\__init__.py (82 bytes)
app\domains\qr_generation\handlers\qr_event_handler.py (6616 bytes)
app\domains\qr_generation\models\__init__.py (359 bytes)
app\domains\qr_generation\models\qr.py (1571 bytes)
app\domains\qr_generation\routers\qr.py (1789 bytes)
app\domains\qr_generation\services\__init__.py (214 bytes)
app\domains\qr_generation\services\amount_detector.py (15034 bytes)
app\domains\qr_generation\services\qr_processor.py (17581 bytes)
app\domains\qr_generation\services\vietqr_service.py (6971 bytes)
app\domains\validation\__init__.py (301 bytes)
app\domains\validation\handlers\__init__.py (106 bytes)
app\domains\validation\handlers\validation_event_handler.py (10972 bytes)
app\domains\validation\models\__init__.py (289 bytes)
app\domains\validation\models\validation.py (2871 bytes)
app\domains\validation\routers\notification.py (1283 bytes)
app\domains\validation\routers\validation.py (1756 bytes)
app\domains\validation\services\__init__.py (135 bytes)
app\domains\validation\services\validation_service.py (15465 bytes)
Dockerfile (1896 bytes)
Get detail code.ipynb (10463 bytes)
lark_events.csv (111947 bytes)
project_complete_info.txt (0 bytes)
README.md (7974 bytes)
requirements.txt (136 bytes)

Tổng cộng: 53 file

💻 NỘI DUNG TẤT CẢ FILE CODE
================================================================================

============================================================
FILE: app\core\__init__.py
============================================================
"""
Core infrastructure exports
"""
from app.core.config import *
from app.core.infrastructure import *
from app.core.utils import *

__all__ = [
    # Configuration
    "settings", "NODE_CONFIG",
    
    # Infrastructure  
    "event_bus", "cache_service", "lark_service",
    
    # Utils
    "extract_instance_code", "get_event_type", "format_currency"
]

============================================================

============================================================
FILE: app\core\bootstrap\application.py
============================================================
import asyncio
from datetime import datetime
from app.core.events.event_registry import event_registry
from app.core.config.settings import settings


class ApplicationBootstrap:
    """
    Bootstrap toàn bộ ứng dụng theo kiến trúc DDD (Domain-Driven Design).
    
    Lớp này chịu trách nhiệm khởi tạo và cấu hình tất cả các thành phần cần thiết
    của ứng dụng bao gồm event handlers, infrastructure services và kiểm tra
    sức khỏe hệ thống.
    
    Attributes:
        startup_time (datetime): Thời điểm bắt đầu khởi tạo ứng dụng
        is_initialized (bool): Trạng thái khởi tạo của ứng dụng
    """
    
    def __init__(self):
        """Khởi tạo ApplicationBootstrap với trạng thái ban đầu."""
        self.startup_time = None
        self.is_initialized = False
        
    async def initialize(self):
        """
        Khởi tạo toàn bộ ứng dụng theo thứ tự ưu tiên.
        
        Quá trình khởi tạo bao gồm:
        1. Đăng ký event handlers
        2. Khởi tạo infrastructure services  
        3. Kiểm tra sức khỏe hệ thống
        
        Raises:
            Exception: Khi có lỗi trong quá trình khởi tạo
        """
        print("🚀 Bắt đầu khởi tạo ứng dụng...")
        self.startup_time = datetime.now()
        
        try:
            # 1. Đăng ký các event handlers
            await self._register_event_handlers()
            
            # 2. Khởi tạo các infrastructure services
            await self._initialize_infrastructure()
            
            # 3. Kiểm tra sức khỏe hệ thống
            await self._validate_system_health()
            
            # Đánh dấu ứng dụng đã khởi tạo thành công
            self.is_initialized = True
            elapsed = (datetime.now() - self.startup_time).total_seconds()
            
            print(f"✅ Khởi tạo ứng dụng hoàn tất trong {elapsed:.2f}s")
            
        except Exception as e:
            print(f"❌ Khởi tạo ứng dụng thất bại: {e}")
            raise
    
    async def _register_event_handlers(self):
        """
        Đăng ký tất cả event handlers từ domain layer.
        
        Method này sử dụng event_registry để tự động đăng ký tất cả
        handlers được định nghĩa trong các domain modules.
        
        Raises:
            Exception: Khi không thể đăng ký event handlers
        """
        print("📝 Đang đăng ký event handlers...")
        
        try:
            # Gọi registry để đăng ký tất cả domain handlers
            event_registry.register_domain_handlers()
            
            # Lấy thông tin trạng thái đăng ký để log
            status = event_registry.get_registration_status()
            print(f"   • Đã đăng ký {status['total_handlers']} handlers cho {status['total_event_types']} loại event")
            
        except Exception as e:
            print(f"❌ Đăng ký event handlers thất bại: {e}")
            raise
    
    async def _initialize_infrastructure(self):
        """
        Khởi tạo và kiểm tra các infrastructure services.
        
        Bao gồm:
        - Lark API service (kết nối đến Lark/Feishu)
        - Cache service (Redis hoặc in-memory cache)
        - Notification service (webhook alerts)
        
        Raises:
            Exception: Khi không thể khởi tạo infrastructure services
        """
        print("🏗️ Đang khởi tạo infrastructure services...")
        
        try:
            # Kiểm tra kết nối Lark API
            from app.core.infrastructure.lark_service import lark_service
            
            print("   • Đang kiểm tra kết nối Lark API...")
            token = await lark_service.get_access_token()
            if token:
                print("   ✅ Kết nối Lark API thành công")
            else:
                print("   ⚠️ Kết nối Lark API thất bại - kiểm tra lại thông tin xác thực")
            
            # Khởi tạo cache service
            from app.core.infrastructure.cache_service import cache_service
            print("   • Cache service đã được khởi tạo")
            print(f"   • Thời gian cache QR code: {settings.QR_CACHE_DURATION_MINUTES} phút")
            
            # Kiểm tra notification service nếu được bật
            if settings.ENABLE_VALIDATION_ALERTS:
                print("   • Cảnh báo validation đã được bật")
                if settings.LARK_WEBHOOK_URL:
                    print("   ✅ Webhook URL đã được cấu hình")
                else:
                    print("   ⚠️ Chưa cấu hình webhook URL")
            else:
                print("   • Cảnh báo validation đã được tắt")
            
        except Exception as e:
            print(f"❌ Khởi tạo infrastructure thất bại: {e}")
            raise
    
    async def _validate_system_health(self):
        """
        Kiểm tra sức khỏe tổng thể của hệ thống.
        
        Validates:
        - Event bus hoạt động bình thường
        - Node configuration đã được load
        - Environment variables cần thiết đã được cấu hình
        
        Raises:
            Exception: Khi phát hiện vấn đề nghiêm trọng với hệ thống
        """
        print("🔍 Đang kiểm tra sức khỏe hệ thống...")
        
        try:
            # Kiểm tra event bus
            from app.core.infrastructure.event_bus import event_bus
            handler_count = len(event_bus.handlers.get("approval.instance.updated", []))
            print(f"   • Event bus: {handler_count} handlers đã đăng ký cho approval events")
            
            # Kiểm tra node configuration
            from app.core.config.node_config import NODE_CONFIG
            print(f"   • Cấu hình node: {len(NODE_CONFIG)} nodes đã được cấu hình")
            
            # Kiểm tra các environment variables bắt buộc
            required_vars = ["LARK_APP_ID", "LARK_APP_SECRET"]
            missing_vars = []
            
            # Duyệt qua từng biến môi trường bắt buộc
            for var in required_vars:
                if not getattr(settings, var, None):
                    missing_vars.append(var)
            
            # Báo cáo kết quả kiểm tra environment variables
            if missing_vars:
                print(f"   ⚠️ Thiếu các biến môi trường: {', '.join(missing_vars)}")
            else:
                print("   ✅ Tất cả biến môi trường bắt buộc đều có")
            
            print("   ✅ Kiểm tra sức khỏe hệ thống hoàn tất")
            
        except Exception as e:
            print(f"❌ Kiểm tra sức khỏe hệ thống thất bại: {e}")
            raise
    
    def get_startup_info(self) -> dict:
        """
        Lấy thông tin chi tiết về quá trình khởi động ứng dụng.
        
        Returns:
            dict: Dictionary chứa thông tin startup bao gồm:
                - startup_time: Thời điểm bắt đầu khởi tạo
                - is_initialized: Trạng thái khởi tạo
                - uptime_seconds: Thời gian hoạt động (giây)
                - event_handlers: Thông tin về event handlers đã đăng ký
                - architecture: Loại kiến trúc được sử dụng
                - version: Phiên bản ứng dụng
        """
        return {
            "startup_time": self.startup_time.isoformat() if self.startup_time else None,
            "is_initialized": self.is_initialized,
            "uptime_seconds": (datetime.now() - self.startup_time).total_seconds() if self.startup_time else 0,
            "event_handlers": event_registry.get_registration_status(),
            "architecture": "DDD",
            "version": "2.0.0"
        }


app_bootstrap = ApplicationBootstrap()

============================================================

============================================================
FILE: app\core\config\__init__.py
============================================================
from .settings import settings
from .node_config import NODE_CONFIG, get_node_config, get_configured_node_ids
from .field_constants import FFN

__all__ = [
    "settings", 
    "NODE_CONFIG", 
    "get_node_config", 
    "get_configured_node_ids",
    "FFN"
]

============================================================

============================================================
FILE: app\core\config\field_constants.py
============================================================
# app/core/config/field_constants.py

class FormFieldNames:
    """
    Single Source of Truth for all Lark Approval form field names.
    Tập trung tất cả tên trường của form phê duyệt Lark tại một nơi duy nhất.
    """
    
    # === Trường Tiền Tệ Cấp Cao (Top-level Amount Fields) ===
    ADVANCE_AMOUNT = "Số tiền tạm ứng"
    PAYMENT_AMOUNT = "Số tiền thanh toán"
    REMAINING_PAYMENT_AMOUNT = "Số tiền còn phải thanh toán"
    TOTAL_PAYMENT_AMOUNT = "Total số tiền thanh toán"

    # === Trường Trong FieldList Kế Toán (Accounting FieldList Fields) ===
    ACCOUNTING_ADVANCE_INFO = "Kế toán - Thông tin tạm ứng"
    ACCOUNTING_PAYMENT_INFO = "Kế toán - Thông tin thanh toán"
    EXPENDITURE_AMOUNT = "Số tiền chi" # Dùng chung cho cả tạm ứng và thanh toán

    # === Trường Thông Tin Ngân Hàng (Bank Information Fields) ===
    BANK_NAME = "Ngân hàng"
    BANK_ACCOUNT_NUMBER = "Số tài khoản ngân hàng"
    BENEFICIARY_NAME = "Tên người thụ hưởng"

# Tạo một instance để dễ dàng import và sử dụng
# from app.core.config.field_constants import FFN
FFN = FormFieldNames()
============================================================

============================================================
FILE: app\core\config\node_config.py
============================================================
from .field_constants import FFN

# Cấu hình chi tiết cho từng node trong approval workflow
NODE_CONFIG = {
    # Node trưởng phòng duyệt - Có thể detect cả advance và payment (Không bắt được node submit, node này luôn là node tiếp theo)
    "30e5338b60587c64c7cef5f6a7211ccb": {
        "name": "truong_phong_duyet",
        "type": "dual_detection",                   # Loại node hỗ trợ cả advance và payment
        "advance_field": FFN.ADVANCE_AMOUNT,        # Tên field chứa số tiền tạm ứng
        "payment_field": FFN.PAYMENT_AMOUNT,        # Tên field chứa số tiền thanh toán
        "strategy": "detect_both_fields",           # Strategy tự động detect loại QR dựa trên fields
        "required_status": "PENDING",               # Status cần thiết để trigger QR generation
        "description": "Trưởng phòng duyệt - Auto detect advance/payment"
    },
    
    # Node thanh toán
    "f23535375a26847ef71c1cbf0755f246": {
        "name": "thanh_toan_sau_tam_ung", 
        "type": "payment_only",                          # Loại node chỉ xử lý payment
        "advance_field": None,                           # Không có field advance
        "payment_field": FFN.REMAINING_PAYMENT_AMOUNT,   # Field chứa số tiền cần thanh toán
        "strategy": "payment_field_only",                # Strategy chỉ xử lý payment field
        "required_status": "APPROVED",                   # Node này cần status APPROVED
        
        # Điều kiện bổ sung để trigger QR generation
        "additional_conditions": [
            {
                "node_id": "ef83b231885a1a77658f32808a199764",  # Node tiếp theo
                "required_status": "PENDING",                   # Node tiếp theo phải PENDING
                "description": "Node tiếp theo phải PENDING"    # Mô tả điều kiện
            }
        ],
        "description": "Thanh toán sau tạm ứng - Payment only (trigger on APPROVED + next node PENDING)"
    }
}


def get_node_config(node_id: str) -> dict:
    """
    Lấy configuration chi tiết cho một node_id cụ thể.
    
    Args:
        node_id (str): Node ID cần lấy configuration
        
    Returns:
        dict: Dictionary chứa cấu hình node bao gồm:
            - name: Tên node
            - type: Loại node (dual_detection, payment_only, etc.)
            - advance_field: Tên field chứa số tiền tạm ứng
            - payment_field: Tên field chứa số tiền thanh toán
            - strategy: Chiến lược xử lý (detect_both_fields, payment_field_only, etc.)
            - required_status: Status cần thiết để trigger
            - additional_conditions: Các điều kiện bổ sung (optional)
            - description: Mô tả node
        Trả về None nếu không tìm thấy node_id
    """
    return NODE_CONFIG.get(node_id)


def get_node_strategy(node_id: str) -> str:
    """
    Lấy strategy xử lý của một node cụ thể.
    
    Args:
        node_id (str): Node ID cần lấy strategy
        
    Returns:
        str: Tên strategy của node như:
            - "detect_both_fields": Tự động detect advance/payment
            - "payment_field_only": Chỉ xử lý payment
            - "unknown": Nếu không tìm thấy node hoặc strategy
    """
    config = get_node_config(node_id)
    return config.get("strategy", "unknown") if config else "unknown"


def print_node_config_summary():
    """
    In ra tóm tắt chi tiết của NODE_CONFIG bao gồm additional conditions.
    
    Function này hiển thị thông tin tổng quan về tất cả nodes được cấu hình,
    bao gồm strategy, fields, required status và các điều kiện bổ sung.
    """
    print("📋 Tóm tắt cấu hình NODE_CONFIG:")
    
    # Duyệt qua từng node trong configuration
    for node_id, config in NODE_CONFIG.items():
        required_status = config.get('required_status', 'PENDING')
        additional_conditions = config.get('additional_conditions', [])
        
        # Hiển thị thông tin cơ bản của node
        print(f"   • {node_id[:8]}... - {config['name']} ({config['strategy']})")
        print(f"     Các trường: advance='{config['advance_field']}', payment='{config['payment_field']}'")
        print(f"     Status yêu cầu: {required_status}")
        
        # Hiển thị các điều kiện bổ sung nếu có
        if additional_conditions:
            print(f"     Điều kiện bổ sung:")
            for condition in additional_conditions:
                condition_node_short = condition['node_id'][:8]
                condition_status = condition['required_status']
                print(f"       - {condition_node_short}... phải có status {condition_status}")


def get_configured_node_ids():
    """
    Lấy danh sách tất cả node IDs đã được cấu hình.
    
    Returns:
        List[str]: Danh sách tất cả node IDs có trong NODE_CONFIG
    """
    return list(NODE_CONFIG.keys())


# Backward compatibility - Giữ lại tên cũ để không break existing code
ALLOWED_NODE_IDS = get_configured_node_ids()

============================================================

============================================================
FILE: app\core\config\settings.py
============================================================
import os
from typing import Optional


class Settings:
    """
    Cấu hình toàn bộ ứng dụng từ environment variables và default values.
    
    Settings class quản lý tất cả các cấu hình cần thiết cho ứng dụng bao gồm:
    - FastAPI server configuration
    - Lark/Feishu API credentials và endpoints
    - VietQR service configuration
    - Webhook và notification settings
    - Cache và performance settings
    - File storage settings
    - Validation và alert settings
    
    Tất cả settings có thể được override bằng environment variables.
    """
    
    # ===== FASTAPI SERVER SETTINGS =====
    # Cấu hình cho FastAPI web server
    DEBUG: bool = os.getenv("DEBUG", "false").lower() == "true"  # Bật/tắt debug mode
    PORT: int = int(os.getenv("PORT", "8000"))                   # Port để chạy server
    
    # ===== LARK/FEISHU API SETTINGS =====
    # Thông tin xác thực và endpoints cho Lark API
    LARK_APP_ID: str = os.getenv("LARK_APP_ID", "cli_a758ffaf41f8502f")
    LARK_APP_SECRET: str = os.getenv("LARK_APP_SECRET", "45Jsgm3TYfEwD2F67BH1LctlYEcCjZpH")
    
    # Base URL cho tất cả Lark API calls
    BASE_URL: str = "https://open.larksuite.com/open-apis"
    
    # Endpoint chuyên dụng cho upload file lên approval system
    APPROVAL_UPLOAD_URL: str = "https://www.larksuite.com/approval/openapi/v2/file/upload"
    
    # ===== VIETQR SERVICE SETTINGS =====
    # Cấu hình cho VietQR API để generate QR codes
    VIETQR_TEMPLATE: str = "compact2"                           # Template layout cho QR code
    VIETQR_BASE_URL: str = "https://img.vietqr.io/image"       # Base URL của VietQR service
    
    # ===== WEBHOOK & NOTIFICATION SETTINGS =====
    # Cấu hình webhook để gửi notifications
    LARK_WEBHOOK_URL: str = os.getenv(
        "LARK_WEBHOOK_URL", 
        "https://open.larksuite.com/open-apis/bot/v2/hook/6a53a060-40d7-4716-9a90-970a6cbdaf64"
    )
    
    # Bật/tắt validation alerts qua webhook
    ENABLE_VALIDATION_ALERTS: bool = os.getenv("ENABLE_VALIDATION_ALERTS", "true").lower() == "true"

    # ===== CACHE & PERFORMANCE SETTINGS =====
    # Cấu hình cache để tối ưu performance và tránh duplicate requests
    QR_CACHE_DURATION_MINUTES: int = 5      # Thời gian cache QR generation (phút)
    TOKEN_CACHE_BUFFER_SECONDS: int = 300   # Buffer time trước khi token hết hạn (5 phút)

    # ===== FILE STORAGE SETTINGS =====
    # Cấu hình file storage cho logging và data persistence
    EVENTS_FILE: str = "lark_events.csv"    # File lưu trữ event logs
    
    # ===== USER & AUTHENTICATION SETTINGS =====
    # User ID mặc định để tạo comments trong Lark approval
    DEFAULT_USER_ID: str = "cd11b141"
    
    # ===== VALIDATION & MONITORING SETTINGS =====
    # Cấu hình các tính năng validation và monitoring (cho future extensions)
    
    # Bật/tắt validation số tiền trong approval workflow
    ENABLE_AMOUNT_VALIDATION: bool = os.getenv("ENABLE_AMOUNT_VALIDATION", "true").lower() == "true"
    
    # Bật/tắt alerts cho workflow errors và anomalies
    ENABLE_WORKFLOW_ALERTS: bool = os.getenv("ENABLE_WORKFLOW_ALERTS", "true").lower() == "true"


# Global settings instance - sử dụng trong toàn bộ ứng dụng
# Import settings từ module này để truy cập tất cả configuration
settings = Settings()

============================================================

============================================================
FILE: app\core\events\event_registry.py
============================================================
"""
Event Registry - Central registration for all domain event handlers
"""
from typing import Dict, List, Callable
from app.core.infrastructure.event_bus import event_bus

class EventRegistry:
    """Central registry for domain event handlers"""
    
    def __init__(self):
        self.registered_handlers: Dict[str, List[str]] = {}
    
    def register_handler(self, event_type: str, handler: Callable, domain: str = "core"):
        """Register a handler for an event type"""
        try:
            event_bus.subscribe(event_type, handler)
            
            # Track registration for monitoring
            if event_type not in self.registered_handlers:
                self.registered_handlers[event_type] = []
            
            handler_info = f"{domain}.{handler.__name__}"
            self.registered_handlers[event_type].append(handler_info)
            
            print(f"✅ Registered {handler_info} for event: {event_type}")
            
        except Exception as e:
            print(f"❌ Failed to register handler {handler.__name__}: {e}")
    
    def register_domain_handlers(self):
        """Register all domain handlers"""
        print("🔧 Registering domain event handlers...")
        
        try:
            # QR Generation Domain Handlers
            from app.domains.qr_generation.handlers import qr_event_handler
            self.register_handler(
                "approval.instance.updated", 
                qr_event_handler.handle_approval_event,
                "qr_generation"
            )
            
            # Validation Domain Handlers  
            from app.domains.validation.handlers import validation_event_handler
            self.register_handler(
                "approval.instance.updated",
                validation_event_handler.handle_approval_event, 
                "validation"
            )
            
            print(f"✅ Successfully registered handlers for {len(self.registered_handlers)} event types")
            
        except Exception as e:
            print(f"❌ Error registering domain handlers: {e}")
            raise
    
    def get_registration_status(self) -> Dict:
        """Get current registration status"""
        total_handlers = sum(len(handlers) for handlers in self.registered_handlers.values())
        
        return {
            "total_event_types": len(self.registered_handlers),
            "total_handlers": total_handlers,
            "registrations": self.registered_handlers,
            "event_bus_handlers": len(event_bus.handlers)
        }

# Global registry instance
event_registry = EventRegistry()

============================================================

============================================================
FILE: app\core\infrastructure\__init__.py
============================================================
from .event_bus import event_bus
from .cache_service import cache_service
from .lark_service import lark_service

__all__ = ["event_bus", "cache_service", "lark_service"]

============================================================

============================================================
FILE: app\core\infrastructure\cache_service.py
============================================================
from datetime import datetime, timedelta
from typing import Dict, Optional


class CacheService:
    """
    Service quản lý cache cho QR code generation và validation alerts.
    
    CacheService giúp tránh trùng lặp bằng cách cache thời điểm tạo QR codes
    và gửi validation alerts. Service này sử dụng in-memory cache với
    automatic expiration để tiết kiệm bộ nhớ.
    
    Attributes:
        qr_generation_cache (Dict[str, datetime]): Cache thời điểm tạo QR codes
        validation_alert_cache (Dict[str, datetime]): Cache thời điểm gửi validation alerts
    """
    
    def __init__(self):
        """Khởi tạo CacheService với các cache dictionary rỗng."""
        self.qr_generation_cache: Dict[str, datetime] = {}
        self.validation_alert_cache: Dict[str, datetime] = {}
    
    def generate_cache_key(self, instance_code: str, node_id: str, qr_type: str) -> str:
        """
        Tạo cache key unique cho QR code để detect duplicates.
        
        Args:
            instance_code (str): Mã instance của approval workflow
            node_id (str): ID của node trong workflow
            qr_type (str): Loại QR code (payment, advance, etc.)
            
        Returns:
            str: Cache key format: {instance_code}_{short_node_id}_{qr_type}
        """
        # Rút ngắn node_id để cache key không quá dài
        short_node_id = node_id[:8] if len(node_id) > 8 else node_id
        return f"{instance_code}_{short_node_id}_{qr_type}"

    def generate_validation_cache_key(self, instance_code: str, validation_type: str) -> str:
        """
        Tạo cache key cho validation alerts để tránh spam alerts.
        
        Args:
            instance_code (str): Mã instance của approval workflow
            validation_type (str): Loại validation (amount_mismatch, workflow_error, etc.)
            
        Returns:
            str: Cache key format: validation_{instance_code}_{validation_type}
        """
        return f"validation_{instance_code}_{validation_type}"

    def is_qr_recently_generated(self, instance_code: str, node_id: str, qr_type: str, 
                               cache_duration_minutes: int = 5) -> bool:
        """
        Kiểm tra xem QR code đã được tạo trong khoảng thời gian gần đây chưa.
        
        Args:
            instance_code (str): Mã instance của approval workflow
            node_id (str): ID của node trong workflow
            qr_type (str): Loại QR code
            cache_duration_minutes (int, optional): Thời gian cache tính bằng phút. Mặc định 5 phút.
            
        Returns:
            bool: True nếu QR đã được tạo gần đây, False nếu chưa hoặc đã hết hạn
        """
        try:
            cache_key = self.generate_cache_key(instance_code, node_id, qr_type)
            
            # Kiểm tra xem cache key có tồn tại không
            if cache_key not in self.qr_generation_cache:
                print(f"🆕 Cache miss: {cache_key} - chưa từng tạo QR")
                return False
            
            # Tính thời gian đã trải qua kể từ lần tạo QR cuối
            generated_time = self.qr_generation_cache[cache_key]
            current_time = datetime.now()
            time_diff = current_time - generated_time
            
            # Nếu đã quá thời gian cache thì xóa entry và return False
            if time_diff > timedelta(minutes=cache_duration_minutes):
                del self.qr_generation_cache[cache_key] 
                print(f"⏰ Cache đã hết hạn: {cache_key} ({time_diff.total_seconds()/60:.1f} phút trước)")
                return False
            
            print(f"🔒 Cache hit: {cache_key} - QR đã tạo {time_diff.total_seconds()/60:.1f} phút trước")
            return True
            
        except Exception as e:
            print(f"❌ Lỗi khi kiểm tra cache: {e}")
            return False

    def is_validation_alert_recently_sent(self, instance_code: str, validation_type: str,
                                        cache_duration_minutes: int = 10) -> bool:
        """
        Kiểm tra xem validation alert đã được gửi trong khoảng thời gian gần đây chưa.
        
        Args:
            instance_code (str): Mã instance của approval workflow
            validation_type (str): Loại validation error
            cache_duration_minutes (int, optional): Thời gian cache tính bằng phút. Mặc định 10 phút.
            
        Returns:
            bool: True nếu alert đã được gửi gần đây, False nếu chưa hoặc đã hết hạn
        """
        try:
            cache_key = self.generate_validation_cache_key(instance_code, validation_type)
            
            # Kiểm tra xem cache key có tồn tại không
            if cache_key not in self.validation_alert_cache:
                print(f"🆕 Validation cache miss: {cache_key} - chưa từng gửi alert")
                return False
            
            # Tính thời gian đã trải qua kể từ lần gửi alert cuối
            sent_time = self.validation_alert_cache[cache_key]
            current_time = datetime.now()
            time_diff = current_time - sent_time
            
            # Nếu đã quá thời gian cache thì xóa entry và return False
            if time_diff > timedelta(minutes=cache_duration_minutes):
                del self.validation_alert_cache[cache_key]
                print(f"⏰ Validation cache đã hết hạn: {cache_key} ({time_diff.total_seconds()/60:.1f} phút trước)")
                return False
            
            print(f"🔒 Validation cache hit: {cache_key} - Alert đã gửi {time_diff.total_seconds()/60:.1f} phút trước")
            return True
            
        except Exception as e:
            print(f"❌ Lỗi khi kiểm tra validation cache: {e}")
            return False

    def mark_qr_as_generated(self, instance_code: str, node_id: str, qr_type: str):
        """
        Đánh dấu QR code đã được tạo bằng cách lưu timestamp vào cache.
        
        Args:
            instance_code (str): Mã instance của approval workflow
            node_id (str): ID của node trong workflow
            qr_type (str): Loại QR code
        """
        try:
            cache_key = self.generate_cache_key(instance_code, node_id, qr_type)
            self.qr_generation_cache[cache_key] = datetime.now()
            
            print(f"🔒 Đã đánh dấu QR được tạo: {cache_key}")
            print(f"📊 Kích thước QR Cache: {len(self.qr_generation_cache)} entries")
            
        except Exception as e:
            print(f"❌ Lỗi khi đánh dấu cache: {e}")

    def mark_validation_alert_as_sent(self, instance_code: str, validation_type: str):
        """
        Đánh dấu validation alert đã được gửi bằng cách lưu timestamp vào cache.
        
        Args:
            instance_code (str): Mã instance của approval workflow
            validation_type (str): Loại validation error
        """
        try:
            cache_key = self.generate_validation_cache_key(instance_code, validation_type)
            self.validation_alert_cache[cache_key] = datetime.now()
            
            print(f"🔒 Đã đánh dấu validation alert được gửi: {cache_key}")
            print(f"📊 Kích thước Validation Cache: {len(self.validation_alert_cache)} entries")
            
        except Exception as e:
            print(f"❌ Lỗi khi đánh dấu validation cache: {e}")

    def get_cache_status(self) -> Dict:
        """
        Lấy trạng thái chi tiết của tất cả cache (QR và validation).
        
        Returns:
            Dict: Dictionary chứa thông tin chi tiết về:
                - qr_cache: Thông tin về QR generation cache
                - validation_cache: Thông tin về validation alert cache
                - current_time: Thời gian hiện tại
        """
        try:
            current_time = datetime.now()
            
            # Tính toán trạng thái QR Cache
            active_qr_cache = {}
            for cache_key, generated_time in self.qr_generation_cache.items():
                time_diff = current_time - generated_time
                minutes_ago = time_diff.total_seconds() / 60
                
                active_qr_cache[cache_key] = {
                    'generated_at': generated_time.isoformat(),
                    'minutes_ago': round(minutes_ago, 1),
                    'will_expire_in_minutes': max(0, 5 - minutes_ago)  # 5 phút cho QR
                }
            
            # Tính toán trạng thái Validation Cache
            active_validation_cache = {}
            for cache_key, sent_time in self.validation_alert_cache.items():
                time_diff = current_time - sent_time
                minutes_ago = time_diff.total_seconds() / 60
                
                active_validation_cache[cache_key] = {
                    'sent_at': sent_time.isoformat(),
                    'minutes_ago': round(minutes_ago, 1),
                    'will_expire_in_minutes': max(0, 10 - minutes_ago)  # 10 phút cho validation
                }
            
            return {
                'qr_cache': {
                    'total_cached_qr': len(self.qr_generation_cache),
                    'active_cache': active_qr_cache,
                    'cache_duration_minutes': 5
                },
                'validation_cache': {
                    'total_cached_alerts': len(self.validation_alert_cache),
                    'active_cache': active_validation_cache,
                    'cache_duration_minutes': 10
                },
                'current_time': current_time.isoformat()
            }
            
        except Exception as e:
            return {"error": str(e)}

    def clear_cache(self) -> Dict:
        """
        Xóa tất cả cache entries (cả QR và validation) và trả về thông tin chi tiết.
        
        Returns:
            Dict: Dictionary chứa:
                - message: Thông báo kết quả
                - cleared_qr_keys: Danh sách QR cache keys đã bị xóa
                - cleared_validation_keys: Danh sách validation cache keys đã bị xóa
                - current_cache_sizes: Kích thước cache hiện tại (sau khi clear)
        """
        try:
            # Lưu lại thông tin trước khi clear
            old_qr_count = len(self.qr_generation_cache)
            old_validation_count = len(self.validation_alert_cache)
            old_qr_keys = list(self.qr_generation_cache.keys())
            old_validation_keys = list(self.validation_alert_cache.keys())
            
            # Clear tất cả cache
            self.qr_generation_cache.clear()
            self.validation_alert_cache.clear()
            
            return {
                'message': f'Đã xóa thành công {old_qr_count} QR cache entries và {old_validation_count} validation cache entries',
                'cleared_qr_keys': old_qr_keys,
                'cleared_validation_keys': old_validation_keys,
                'current_qr_cache_size': len(self.qr_generation_cache),
                'current_validation_cache_size': len(self.validation_alert_cache)
            }
            
        except Exception as e:
            return {"success": False, "error": str(e)}


cache_service = CacheService()

============================================================

============================================================
FILE: app\core\infrastructure\event_bus.py
============================================================
# app/services/event_bus.py
import asyncio
from typing import Dict, List, Callable, Any
from datetime import datetime


class EventBus:
    """
    Event Bus system để quản lý và phân phối events trong ứng dụng.
    
    EventBus cho phép các component đăng ký handlers cho các loại event khác nhau
    và publish events để thực thi tất cả handlers đã đăng ký một cách bất đồng bộ.
    
    Attributes:
        handlers (Dict[str, List[Callable]]): Dictionary chứa danh sách handlers cho từng event type
        event_history (List[Dict]): Lịch sử tất cả events đã được publish
    """
    
    def __init__(self):
        """Khởi tạo EventBus với handlers và event history rỗng."""
        self.handlers: Dict[str, List[Callable]] = {}
        self.event_history: List[Dict] = []
    
    def subscribe(self, event_type: str, handler: Callable):
        """
        Đăng ký handler cho một event type cụ thể.
        
        Args:
            event_type (str): Loại event cần lắng nghe
            handler (Callable): Hàm xử lý sẽ được gọi khi event được publish
            
        Note:
            Handler phải là async function và nhận event_data làm tham số
        """
        # Khởi tạo danh sách handlers cho event type nếu chưa tồn tại
        if event_type not in self.handlers:
            self.handlers[event_type] = []
        
        # Thêm handler vào danh sách
        self.handlers[event_type].append(handler)
        print(f"📝 Đã đăng ký handler cho event: {event_type}")
    
    async def publish(self, event_type: str, event_data: Dict[str, Any]):
        """
        Publish event và thực thi tất cả handlers đã đăng ký song song.
        
        Args:
            event_type (str): Loại event cần publish
            event_data (Dict[str, Any]): Dữ liệu sẽ được truyền cho các handlers
            
        Returns:
            List: Danh sách kết quả từ tất cả handlers (bao gồm cả exceptions)
        """
        print(f"📢 Đang publish event: {event_type}")
        
        # Lưu lịch sử event
        event_record = {
            "timestamp": datetime.now().isoformat(),
            "event_type": event_type,
            "data": event_data,
            "handlers_count": len(self.handlers.get(event_type, []))
        }
        self.event_history.append(event_record)
        
        # Thực thi tất cả handlers đồng thời
        if event_type in self.handlers:
            tasks = []
            
            # Tạo task cho mỗi handler
            for handler in self.handlers[event_type]:
                task = asyncio.create_task(
                    self._run_handler_safe(handler, event_data)
                )
                tasks.append(task)
            
            # Đợi tất cả handlers hoàn thành (kể cả khi có lỗi)
            results = await asyncio.gather(*tasks, return_exceptions=True)
            
            # Ghi log kết quả từ mỗi handler
            for i, result in enumerate(results):
                handler_name = self.handlers[event_type][i].__name__
                if isinstance(result, Exception):
                    print(f"❌ Handler {handler_name} thất bại: {result}")
                else:
                    print(f"✅ Handler {handler_name} hoàn thành: {result}")
            
            return results
        else:
            print(f"⚠️ Không có handler nào được đăng ký cho event: {event_type}")
            return []
    
    async def _run_handler_safe(self, handler: Callable, event_data: Dict) -> Dict:
        """
        Thực thi handler với error handling và monitoring thời gian.
        
        Args:
            handler (Callable): Handler function cần thực thi
            event_data (Dict): Dữ liệu event được truyền cho handler
            
        Returns:
            Dict: Thông tin kết quả bao gồm success status, result/error, và thời gian thực thi
        """
        handler_name = handler.__name__
        try:
            print(f"🚀 Bắt đầu thực thi handler: {handler_name}")
            start_time = datetime.now()
            
            # Gọi handler (phải là async function)
            result = await handler(event_data)
            
            # Tính thời gian thực thi
            end_time = datetime.now()
            duration = (end_time - start_time).total_seconds()
            
            return {
                "handler": handler_name,
                "success": True,
                "result": result,
                "duration_seconds": duration
            }
            
        except Exception as e:
            print(f"❌ Handler {handler_name} gặp lỗi: {e}")
            return {
                "handler": handler_name,
                "success": False,
                "error": str(e),
                "duration_seconds": 0
            }
    
    def get_event_history(self, limit: int = 50) -> List[Dict]:
        """
        Lấy lịch sử các events đã được publish.
        
        Args:
            limit (int, optional): Số lượng events gần nhất cần lấy. Mặc định là 50.
            
        Returns:
            List[Dict]: Danh sách các event records theo thứ tự thời gian (mới nhất cuối)
        """
        return self.event_history[-limit:]


event_bus = EventBus()

============================================================

============================================================
FILE: app\core\infrastructure\lark_service.py
============================================================
import requests
import json
from datetime import datetime
from typing import Optional, Dict
from app.core.config.settings import settings


class LarkService:
    """
    Service tương tác với Lark/Feishu API để quản lý approval instances.
    
    LarkService cung cấp các chức năng chính:
    - Xác thực và quản lý access tokens với caching
    - Lấy thông tin approval instances
    - Upload hình ảnh lên Lark
    - Tạo comments với attachments
    
    Attributes:
        access_token_cache (Dict): Cache lưu trữ access token và thời gian hết hạn
    """
    
    def __init__(self):
        """Khởi tạo LarkService với token cache rỗng."""
        self.access_token_cache = {"token": None, "expires_at": None}
    
    async def get_access_token(self) -> Optional[str]:
        """
        Lấy access token từ LarkSuite API với caching mechanism.
        
        Method này sẽ sử dụng cached token nếu còn hiệu lực, otherwise
        sẽ gọi API để lấy token mới và cache lại.
        
        Returns:
            Optional[str]: Access token nếu thành công, None nếu thất bại
        """
        current_time = datetime.now().timestamp()
        
        # Kiểm tra xem token đã cache còn hiệu lực không
        if (self.access_token_cache["token"] and 
            self.access_token_cache["expires_at"] and 
            current_time < self.access_token_cache["expires_at"]):
            return self.access_token_cache["token"]
        
        try:
            # Gọi API để lấy tenant access token mới
            url = f"{settings.BASE_URL}/auth/v3/tenant_access_token/internal"
            payload = {
                "app_id": settings.LARK_APP_ID,
                "app_secret": settings.LARK_APP_SECRET
            }
            
            response = requests.post(url, json=payload, timeout=10)
            data = response.json()
            
            # Kiểm tra response từ API
            if data.get("code") == 0:
                token = data["tenant_access_token"]
                expires_in = data.get("expire", 7200)  # Mặc định 2 tiếng
                
                # Cache token với buffer time để tránh token hết hạn giữa chừng
                self.access_token_cache["token"] = token
                self.access_token_cache["expires_at"] = current_time + expires_in - settings.TOKEN_CACHE_BUFFER_SECONDS
                
                print(f"✅ Lấy access token thành công")
                return token
            else:
                print(f"❌ Lấy token thất bại: {data}")
                return None
                
        except Exception as e:
            print(f"❌ Lỗi khi lấy token: {e}")
            return None

    async def get_approval_instance(self, instance_code: str, access_token: str) -> Optional[Dict]:
        """
        Lấy thông tin chi tiết của approval instance từ Lark API.
        
        Args:
            instance_code (str): Mã định danh của approval instance
            access_token (str): Access token để xác thực API call
            
        Returns:
            Optional[Dict]: Thông tin instance nếu thành công, None nếu thất bại
        """
        try:
            url = f"{settings.BASE_URL}/approval/v4/instances/{instance_code}"
            headers = {"Authorization": f"Bearer {access_token}"}
            
            print(f"🔍 Đang lấy thông tin instance: {instance_code}")
            response = requests.get(url, headers=headers, timeout=10)
            
            # Kiểm tra HTTP status code
            if response.status_code != 200:
                print(f"❌ Lỗi HTTP khi gọi API: {response.status_code}")
                return None
                
            api_response = response.json()
            
            # Kiểm tra Lark API response code
            if api_response.get("code") != 0:
                print(f"❌ Lỗi Lark API response: {api_response}")
                return None
                
            return api_response
            
        except Exception as e:
            print(f"❌ Lỗi khi lấy thông tin approval instance: {e}")
            return None

    async def upload_image_to_approval(self, image_buffer, filename: str, access_token: str) -> Dict:
        """
        Upload hình ảnh lên Lark Approval system để sử dụng trong comments.
        
        Args:
            image_buffer: Buffer chứa dữ liệu hình ảnh (bytes)
            filename (str): Tên file của hình ảnh
            access_token (str): Access token để xác thực API call
            
        Returns:
            Dict: Dictionary chứa:
                - success (bool): Trạng thái upload
                - file_code (str): Mã file từ Lark (nếu success)  
                - file_url (str): URL file từ Lark (nếu success)
                - error (str): Thông báo lỗi (nếu failed)
        """
        try:
            # Reset buffer position về đầu để đọc từ beginning
            image_buffer.seek(0)
            
            # Chuẩn bị multipart form data cho upload
            files = {
                'name': (None, filename),
                'type': (None, 'image'),
                'content': (filename, image_buffer, 'image/png')
            }
            
            headers = {
                'Authorization': f'Bearer {access_token}'
            }
            
            print(f"📤 Đang upload hình ảnh: {filename}")
            response = requests.post(settings.APPROVAL_UPLOAD_URL, files=files, headers=headers)
            
            # Xử lý response từ upload API
            if response.status_code == 200:
                data = response.json()
                if data.get('code') == 0:
                    file_code = data['data']['code']
                    file_url = data['data']['url']
                    print(f'✅ Upload hình ảnh thành công! File code: {file_code}')
                    return {
                        'success': True,
                        'file_code': file_code,
                        'file_url': file_url
                    }
                else:
                    error_msg = f"Lỗi API: {data.get('msg')} (code: {data.get('code')})"
                    print(f'❌ Upload thất bại: {error_msg}')
                    return {'success': False, 'error': error_msg}
            else:
                error_msg = f"Lỗi HTTP: {response.status_code}"
                print(f'❌ Upload thất bại: {error_msg}')
                return {'success': False, 'error': error_msg}
                
        except Exception as e:
            error_msg = f"Exception: {str(e)}"
            print(f"❌ Lỗi upload: {error_msg}")
            return {'success': False, 'error': error_msg}

    async def create_enhanced_comment_with_image(self, instance_code: str, file_url: str, file_code: str, 
                                               filename: str, qr_type: str, amount: int, node_name: str,
                                               access_token: str, user_id: str = None) -> Dict:
        """
        Tạo comment với hình ảnh QR code và thông tin chi tiết.
        
        Args:
            instance_code (str): Mã instance của approval workflow
            file_url (str): URL của file đã upload
            file_code (str): Code của file từ Lark system
            filename (str): Tên file hình ảnh
            qr_type (str): Loại QR ('advance' hoặc 'payment')
            amount (int): Số tiền của QR code
            node_name (str): Tên node trong workflow
            access_token (str): Access token để xác thực
            user_id (str, optional): User ID thực hiện comment
            
        Returns:
            Dict: Dictionary chứa:
                - success (bool): Trạng thái tạo comment
                - comment_id (str): ID của comment được tạo (nếu success)
                - error (str): Thông báo lỗi (nếu failed)
        """
        try:
            # Sử dụng default user ID nếu không được cung cấp
            if user_id is None:
                user_id = settings.DEFAULT_USER_ID
                
            create_comment_url = f'{settings.BASE_URL}/approval/v4/instances/{instance_code}/comments'
            
            # Parameters cho API call
            params = {
                "user_id": user_id,
                "user_id_type": "user_id"
            }
            
            # Tạo text hiển thị cho QR type
            qr_type_display = {
                'advance': 'TẠM ỨNG',
                'payment': 'THANH TOÁN'
            }
            
            # Tạo nội dung comment với thông tin chi tiết
            comment_text = f"""🏦 Mã VietQR {qr_type_display.get(qr_type, qr_type.upper())}
💰 Số tiền: {amount:,} VND"""

            # Ước tính kích thước file (rough estimate)
            try:
                file_size = len(filename) * 100  # Ước tính dựa trên độ dài filename
            except:
                file_size = 50000  # Giá trị mặc định

            # Tạo content data với text và file attachment
            content_data = {
                "text": comment_text,
                "files": [{
                    "url": file_url,
                    "fileSize": file_size,
                    "title": filename,
                    "type": "image",
                    "extra": file_code
                }]
            }
            
            # Request body với JSON content
            request_body = {
                "content": json.dumps(content_data, ensure_ascii=False)
            }
            
            headers_comment = {
                'Authorization': f'Bearer {access_token}',
                'Content-Type': 'application/json'
            }
            
            print(f"📤 Đang tạo enhanced comment cho instance: {instance_code}")
            print(f"   Nội dung: {comment_text.replace(chr(10), ' | ')}")
            
            # Gọi API để tạo comment
            response = requests.post(
                create_comment_url, 
                params=params,
                json=request_body, 
                headers=headers_comment
            )
            
            # Xử lý response từ comment API
            if response.status_code == 200:
                comment_result = response.json()
                if comment_result.get('code') == 0:
                    comment_id = comment_result.get("data", {}).get("comment_id", "N/A")
                    print(f'✅ Tạo enhanced comment thành công! Comment ID: {comment_id}')
                    return {'success': True, 'comment_id': comment_id}
                else:
                    error_msg = f"Lỗi API: {comment_result.get('msg')} (code: {comment_result.get('code')})"
                    print(f'❌ Tạo comment thất bại: {error_msg}')
                    return {'success': False, 'error': error_msg}
            else:
                error_msg = f"Lỗi HTTP: {response.status_code}"
                print(f'❌ Tạo comment thất bại: {error_msg}')
                return {'success': False, 'error': error_msg}
                
        except Exception as e:
            error_msg = f"Exception: {str(e)}"
            print(f"❌ Lỗi tạo enhanced comment: {error_msg}")
            return {'success': False, 'error': error_msg}


lark_service = LarkService()

============================================================

============================================================
FILE: app\core\models\event.py
============================================================
from pydantic import BaseModel
from typing import Optional, Dict, Any
from datetime import datetime

class EventHeader(BaseModel):
    event_id: Optional[str] = None
    event_type: Optional[str] = None
    create_time: Optional[str] = None
    token: Optional[str] = None
    tenant_key: Optional[str] = None
    app_id: Optional[str] = None

class EventBody(BaseModel):
    instance_code: Optional[str] = None
    type: Optional[str] = None
    object: Optional[Dict[str, Any]] = None

class LarkEvent(BaseModel):
    schema: Optional[str] = None
    header: Optional[EventHeader] = None
    event: Optional[EventBody] = None
    type: Optional[str] = None  # For URL verification
    challenge: Optional[str] = None  # For URL verification

class EventRecord(BaseModel):
    timestamp: datetime
    event_type: str
    instance_code: Optional[str]
    raw_event: str

============================================================

============================================================
FILE: app\core\models\response.py
============================================================
from pydantic import BaseModel
from typing import Optional, Dict, Any, List

class APIResponse(BaseModel):
    success: bool
    message: Optional[str] = None
    data: Optional[Dict[str, Any]] = None
    error: Optional[str] = None

class UploadResult(BaseModel):
    success: bool
    file_code: Optional[str] = None
    file_url: Optional[str] = None
    error: Optional[str] = None

class CommentResult(BaseModel):
    success: bool
    comment_id: Optional[str] = None
    error: Optional[str] = None

class QRGenerationResult(BaseModel):
    success: bool
    qr_type: Optional[str] = None
    amount: Optional[float] = None
    field_used: Optional[str] = None
    node_name: Optional[str] = None
    comment_id: Optional[str] = None
    error: Optional[str] = None
    processing_info: Optional[Dict[str, Any]] = None

class CacheStatus(BaseModel):
    total_cached_qr: int
    active_cache: Dict[str, Dict[str, Any]]
    cache_duration_minutes: int
    current_time: str

============================================================

============================================================
FILE: app\core\models\shared.py
============================================================
from pydantic import BaseModel
from typing import Optional, List, Dict, Any

class FormField(BaseModel):
    name: Optional[str] = None
    type: Optional[str] = None
    value: Optional[Any] = None

class TaskInfo(BaseModel):
    node_id: Optional[str] = None
    status: Optional[str] = None
    task_id: Optional[str] = None
    node_name: Optional[str] = None

class ApprovalInstance(BaseModel):
    instance_code: str
    status: Optional[str] = None
    form: Optional[str] = None
    task_list: Optional[List[TaskInfo]] = None

============================================================

============================================================
FILE: app\core\routers\monitoring.py
============================================================
from fastapi import APIRouter
from app.core.infrastructure.event_bus import event_bus
from app.core.bootstrap.application import app_bootstrap

router = APIRouter()

@router.get("/system/health")
async def get_system_health():
    """System health check với DDD architecture"""
    return {
        "status": "healthy" if app_bootstrap.is_initialized else "initializing",
        "application": app_bootstrap.get_startup_info(),
        "event_system": {
            "total_event_types": len(event_bus.handlers),
            "registered_events": list(event_bus.handlers.keys()),
            "total_handlers": sum(len(handlers) for handlers in event_bus.handlers.values())
        }
    }

@router.get("/events/history")
async def get_event_history(limit: int = 50):
    """Event processing history"""
    return {
        "recent_events": event_bus.get_event_history(limit),
        "handlers": {
            event_type: [handler.__name__ for handler in handlers]
            for event_type, handlers in event_bus.handlers.items()
        }
    }

@router.post("/events/test/{instance_code}")
async def test_event_processing(instance_code: str):
    """Test event processing system"""
    event_data = {
        "instance_code": instance_code,
        "event_type": "test_event",
        "timestamp": "manual_test"
    }
    
    results = await event_bus.publish("approval.instance.updated", event_data)
    
    return {
        "test_instance": instance_code,
        "handlers_executed": len(results),
        "results": results,
        "architecture": "DDD"
    }

============================================================

============================================================
FILE: app\core\routers\webhook.py
============================================================
from fastapi import APIRouter, Request
from fastapi.responses import JSONResponse
from app.core.infrastructure.event_bus import event_bus
from app.core.utils.helpers import save_event_to_csv, get_event_type, extract_instance_code
from app.core.config.settings import settings

router = APIRouter()

@router.post("/webhook")
async def handle_lark_webhook(request: Request):
    """
    Xử lý webhook từ Lark với kiến trúc DDD

    Chức năng chính:
    - Nhận và xử lý các sự kiện webhook từ Lark
    - Xác thực URL verification cho webhook setup
    - Lưu trữ tất cả events vào file CSV để audit
    - Xử lý các sự kiện phê duyệt qua event bus pattern
    - Trả về response phù hợp cho từng loại event

    Args:
        request (Request): HTTP request chứa webhook data từ Lark

    Returns:
        JSONResponse: 
            - Đối với URL verification: {"challenge": "..."}
            - Đối với events thành công: {"status": "success", "architecture": "DDD"}
            - Đối với lỗi: {"error": "..."} với status 500
    """
    try:
        data = await request.json()
        print(f"📨 Nhận được webhook: {get_event_type(data)}")

        # Xử lý xác thực URL khi setup webhook
        if data.get("type") == "url_verification":
            print("🔐 Đang xử lý URL verification")
            return JSONResponse(content={"challenge": data.get("challenge")})

        print("💾 Đang lưu event vào CSV...")
        await save_event_to_csv(data, settings.EVENTS_FILE)

        # Xử lý các sự kiện phê duyệt thông qua event bus
        event_type = get_event_type(data)
        if "approval" in event_type.lower():
            instance_code = extract_instance_code(data)
            if instance_code:
                print(f"🔍 Đang xử lý instance phê duyệt: {instance_code}")

                # Phát hành event qua event bus - sẽ kích hoạt tất cả handlers đã đăng ký
                print("📡 Đang phát hành event qua event bus...")
                await event_bus.publish("approval.instance.updated", {
                    "instance_code": instance_code,
                    "event_type": event_type,
                    "timestamp": data.get("header", {}).get("create_time"),
                    "raw_data": data
                })
                print("✅ Đã phát hành event thành công")
            else:
                print("⚠️ Không tìm thấy instance code trong event phê duyệt")

        print("🎉 Xử lý webhook hoàn tất")
        return JSONResponse(content={"status": "success", "architecture": "DDD"})

    except Exception as e:
        print(f"❌ Lỗi khi xử lý webhook: {e}")
        return JSONResponse(content={"error": str(e)}, status_code=500)
============================================================

============================================================
FILE: app\core\utils\__init__.py
============================================================
from .helpers import extract_instance_code, get_event_type, format_currency, get_short_node_id
from .field_extractor import FieldExtractor
from .amount_detector import AmountDetector

__all__ = [
    "extract_instance_code", "get_event_type", "format_currency", "get_short_node_id",
    "FieldExtractor", "AmountDetector"
]

============================================================

============================================================
FILE: app\core\utils\amount_detector.py
============================================================
from typing import Dict, List, Optional
from app.core.config.node_config import get_node_config
from app.core.utils.field_extractor import FieldExtractor

class AmountDetector:
    def __init__(self):
        self.field_extractor = FieldExtractor()
    
    def detect_available_amount_fields(self, form_data: List[Dict], node_config: Dict = None) -> Dict:
        """
        Scan form data để tìm amount fields theo config của node
        
        Args:
            form_data (list): Form data từ API response
            node_config (dict): Node configuration (optional)
            
        Returns:
            dict: Detection results với các fields và values
        """
        try:
            # Sử dụng config từ node thay vì hardcode
            if node_config:
                advance_field = node_config.get('advance_field')
                payment_field = node_config.get('payment_field')
            else:
                # Fallback cho backward compatibility
                advance_field = "Số tiền tạm ứng"
                payment_field = "Số tiền thanh toán"
            
            # Extract cả 2 fields (chỉ khi field name không phải None)
            advance_value = self.field_extractor.extract_field_value(form_data, advance_field) if advance_field else None
            payment_value = self.field_extractor.extract_field_value(form_data, payment_field) if payment_field else None
            
            # Debug: tìm tất cả fields có chứa "tiền" hoặc "amount" 
            all_amount_fields = self.field_extractor.get_amount_fields(form_data)
            
            result = {
                'advance_amount': advance_value,
                'payment_amount': payment_value,
                'advance_field_found': advance_value is not None,
                'payment_field_found': payment_value is not None,
                'all_amount_fields': all_amount_fields,
                'fields_used': {
                    'advance_field': advance_field,
                    'payment_field': payment_field
                }
            }
            
            print(f"💰 Field detection results:")
            if advance_field:
                print(f"   - {advance_field}: {'✅ ' + str(advance_value) if advance_value else '❌ Not found'}")
            else:
                print(f"   - Advance field: ❌ Not configured")
                
            if payment_field:
                print(f"   - {payment_field}: {'✅ ' + str(payment_value) if payment_value else '❌ Not found'}")
            else:
                print(f"   - Payment field: ❌ Not configured")
                
            print(f"   - All amount fields: {list(all_amount_fields.keys())}")
            
            return result
            
        except Exception as e:
            print(f"❌ Error detecting amount fields: {e}")
            return {
                'advance_amount': None,
                'payment_amount': None,
                'advance_field_found': False,
                'payment_field_found': False,
                'all_amount_fields': {},
                'fields_used': {'advance_field': None, 'payment_field': None},
                'error': str(e)
            }
    
    def determine_qr_type_by_fields(self, field_detection_result: Dict) -> Dict:
        """
        Quyết định QR type dựa trên fields có giá trị
        
        Args:
            field_detection_result (dict): Kết quả từ detect_available_amount_fields()
            
        Returns:
            dict: QR type decision result
        """
        try:
            advance_found = field_detection_result.get('advance_field_found', False)
            payment_found = field_detection_result.get('payment_field_found', False)
            advance_amount = field_detection_result.get('advance_amount')
            payment_amount = field_detection_result.get('payment_amount')

            fields_used = field_detection_result.get('fields_used', {})
            advance_field_name = fields_used.get('advance_field', 'Số tiền tạm ứng')
            payment_field_name = fields_used.get('payment_field', 'Số tiền thanh toán')

            print(f"🎯 Determining QR type: advance={advance_found}, payment={payment_found}")
            
            # Logic priority: advance trước, sau đó payment
            if advance_found and advance_amount:
                try:
                    amount_value = float(advance_amount)
                    if amount_value > 0:
                        return {
                            'qr_type': 'advance',
                            'amount': amount_value,
                            'field_used': advance_field_name,
                            'reason': 'Found valid advance amount'
                        }
                except (ValueError, TypeError):
                    print(f"⚠️ Invalid advance amount: {advance_amount}")
            
            if payment_found and payment_amount:
                try:
                    amount_value = float(payment_amount)
                    if amount_value > 0:
                        return {
                            'qr_type': 'payment', 
                            'amount': amount_value,
                            'field_used': payment_field_name,
                            'reason': 'Found valid payment amount'
                        }
                except (ValueError, TypeError):
                    print(f"⚠️ Invalid payment amount: {payment_amount}")
            
            # Không tìm thấy field hợp lệ
            return {
                'qr_type': 'none',
                'amount': None,
                'field_used': None,
                'reason': f'No valid amount found (advance_found={advance_found}, payment_found={payment_found})'
            }
            
        except Exception as e:
            print(f"❌ Error determining QR type: {e}")
            return {
                'qr_type': 'none',
                'amount': None,
                'field_used': None,
                'reason': f'Error: {str(e)}'
            }
    
    def get_amount_and_type_for_node(self, node_id: str, form_data: List[Dict]) -> Dict:
        """
        Lấy amount và QR type cho một node cụ thể dựa trên strategy của node đó
        
        Args:
            node_id (str): Node ID
            form_data (list): Form data từ API
            
        Returns:
            dict: Processing result với success, qr_type, amount, etc.
        """
        try:
            node_config = get_node_config(node_id)
            if not node_config:
                return {
                    'success': False,
                    'qr_type': 'none',
                    'error': f'Node {node_id} not found in configuration'
                }
            
            strategy = node_config['strategy']
            node_name = node_config['name']
            
            print(f"🔍 Processing node: {node_name} (strategy: {strategy})")
            
            # Detect available fields
            field_detection = self.detect_available_amount_fields(form_data, node_config)
            
            if strategy == "detect_both_fields":
                # Dual detection: có thể là advance hoặc payment
                qr_decision = self.determine_qr_type_by_fields(field_detection)
                
                return {
                    'success': qr_decision['qr_type'] != 'none',
                    'qr_type': qr_decision['qr_type'],
                    'amount': qr_decision['amount'],
                    'field_used': qr_decision['field_used'],
                    'node_strategy': strategy,
                    'reason': f"Dual detection result: {qr_decision['reason']}",
                    'field_detection': field_detection
                }
                
            elif strategy == "payment_field_only":
                # Payment only: chỉ check payment field
                payment_amount = field_detection.get('payment_amount')
                payment_found = field_detection.get('payment_field_found', False)
                payment_field_name = node_config.get('payment_field')

                if payment_found and payment_amount:
                    try:
                        amount_value = float(payment_amount)
                        if amount_value > 0:
                            return {
                                'success': True,
                                'qr_type': 'payment',
                                'amount': amount_value,
                                'field_used': payment_field_name,
                                'node_strategy': strategy,
                                'reason': 'Payment-only strategy: found valid payment amount',
                                'field_detection': field_detection
                            }
                    except (ValueError, TypeError):
                        pass
                
                return {
                    'success': False,
                    'qr_type': 'none',
                    'amount': None,
                    'field_used': None,
                    'node_strategy': strategy,
                    'reason': f'Payment-only strategy: no valid payment amount (found={payment_found}, value={payment_amount})',
                    'field_detection': field_detection
                }
            
            else:
                return {
                    'success': False,
                    'qr_type': 'none',
                    'error': f'Unknown strategy: {strategy}'
                }
                
        except Exception as e:
            print(f"❌ Error processing node {node_id}: {e}")
            return {
                'success': False,
                'qr_type': 'none',
                'error': str(e)
            }

============================================================

============================================================
FILE: app\core\utils\field_extractor.py
============================================================
from typing import List, Dict, Any, Optional

class FieldExtractor:
    def extract_field_value(self, form_data: List[Dict], field_name: str, debug: bool = False) -> Optional[Any]:
        """
        Enhanced version: Trích xuất giá trị của một field từ form data với better error handling
        
        Args:
            form_data (list): Form data từ API
            field_name (str): Tên field cần tìm
            debug (bool): In debug info
            
        Returns:
            Giá trị field hoặc None nếu không tìm thấy
        """
        try:
            if debug:
                print(f"🔍 Searching for field: '{field_name}'")
                
            # Search in top-level fields
            for field in form_data:
                if field.get('name') == field_name:
                    value = field.get('value')
                    if debug:
                        print(f"✅ Found '{field_name}' in top-level: {value}")
                    return value
                
                # Search in nested fieldList
                if field.get('type') == 'fieldList' and 'value' in field:
                    field_list_values = field['value']
                    if isinstance(field_list_values, list):
                        for field_group in field_list_values:
                            if isinstance(field_group, list):
                                for sub_field in field_group:
                                    if isinstance(sub_field, dict) and sub_field.get('name') == field_name:
                                        value = sub_field.get('value')
                                        if debug:
                                            print(f"✅ Found '{field_name}' in fieldList: {value}")
                                        return value
            
            if debug:
                print(f"❌ Field '{field_name}' not found")
                print("Available fields:", [f.get('name') for f in form_data if f.get('name')])
                
            return None
            
        except Exception as e:
            print(f"❌ Error extracting field '{field_name}': {e}")
            return None

    def get_all_field_names(self, form_data: List[Dict]) -> List[str]:
        """
        Lấy tất cả field names từ form data
        
        Args:
            form_data: Form data từ API
            
        Returns:
            List[str]: Danh sách tên fields
        """
        field_names = []
        
        try:
            for field in form_data:
                field_name = field.get('name')
                if field_name:
                    field_names.append(field_name)
                
                # Check nested fieldList
                if field.get('type') == 'fieldList' and 'value' in field:
                    field_list_values = field['value']
                    if isinstance(field_list_values, list):
                        for field_group in field_list_values:
                            if isinstance(field_group, list):
                                for sub_field in field_group:
                                    if isinstance(sub_field, dict):
                                        sub_field_name = sub_field.get('name')
                                        if sub_field_name:
                                            field_names.append(sub_field_name)
        except Exception as e:
            print(f"❌ Error getting field names: {e}")
        
        return list(set(field_names))  # Remove duplicates

    def get_amount_fields(self, form_data: List[Dict]) -> Dict[str, Any]:
        """
        Tìm tất cả fields có chứa "tiền" hoặc "amount"
        
        Args:
            form_data: Form data từ API
            
        Returns:
            Dict[str, Any]: Dict với field name là key, value là giá trị
        """
        amount_fields = {}
        
        try:
            for field in form_data:
                field_name = field.get('name', '').lower()
                if 'tiền' in field_name or 'amount' in field_name:
                    amount_fields[field.get('name')] = field.get('value')
        except Exception as e:
            print(f"❌ Error getting amount fields: {e}")
        
        return amount_fields

    def extract_field_from_fieldlist(self, form_data: List[Dict], fieldlist_name: str, 
                                target_field_name: str, debug: bool = False) -> Optional[Any]:
        """
        Trích xuất giá trị đầu tiên của một field từ bên trong một fieldList cụ thể.
        
        Hàm này chỉ trả về giá trị đầu tiên tìm thấy. Để lấy tất cả giá trị,
        sử dụng `extract_all_values_from_fieldlist`.
        
        Args:
            form_data: Form data từ API
            fieldlist_name: Tên fieldList container (vd: "Kế toán - Thông tin tạm ứng")  
            target_field_name: Tên field cần tìm (vd: "Số tiền chi")
            debug: In debug info
            
        Returns:
            Giá trị field hoặc None nếu không tìm thấy
        """
        try:
            if debug:
                print(f"🔍 Searching for first '{target_field_name}' in fieldList '{fieldlist_name}'")
                
            if not fieldlist_name or not target_field_name:
                if debug: print("❌ Invalid parameters: fieldlist_name and target_field_name required")
                return None
                
            for field in form_data:
                if field.get('name') == fieldlist_name and field.get('type') == 'fieldList':
                    field_list_values = field.get('value', [])
                    if debug: print(f"📋 Found fieldList '{fieldlist_name}' with {len(field_list_values)} items")
                    
                    for field_group in field_list_values:
                        if isinstance(field_group, list):
                            for sub_field in field_group:
                                if isinstance(sub_field, dict) and sub_field.get('name') == target_field_name:
                                    value = sub_field.get('value')
                                    if debug: print(f"✅ Found first '{target_field_name}' = {value}")
                                    return value
                    
                    if debug: print(f"❌ Field '{target_field_name}' not found in fieldList")
                    return None
            
            if debug:
                print(f"❌ fieldList '{fieldlist_name}' not found")
                available = [f.get('name') for f in form_data if f.get('type') == 'fieldList']
                print(f"Available fieldLists: {available}")
            return None
            
        except Exception as e:
            print(f"❌ Error extracting field from fieldList: {e}")
            return None
            
    def extract_all_values_from_fieldlist(self, form_data: List[Dict], fieldlist_name: str, 
                                          target_field_name: str, debug: bool = False) -> List[Any]:
        """
        ✅ MỚI: Trích xuất TẤT CẢ các giá trị của một field từ TẤT CẢ các dòng trong một fieldList.
        
        Hữu ích khi cần tính tổng các giá trị trong một danh sách, ví dụ như tổng "Số tiền chi"
        từ nhiều lần tạm ứng của kế toán.
        
        Args:
            form_data: Form data từ API.
            fieldlist_name: Tên của fieldList container (ví dụ: "Kế toán - Thông tin tạm ứng").
            target_field_name: Tên của field cần trích xuất giá trị (ví dụ: "Số tiền chi").
            debug: Bật/tắt in thông tin gỡ lỗi.
            
        Returns:
            List[Any]: Một danh sách chứa tất cả các giá trị tìm thấy. Trả về list rỗng nếu không tìm thấy gì.
        """
        extracted_values = []
        try:
            if debug:
                print(f"🔍 Searching for ALL '{target_field_name}' values in fieldList '{fieldlist_name}'")

            for field in form_data:
                if field.get('name') == fieldlist_name and field.get('type') == 'fieldList':
                    field_list_values = field.get('value', [])
                    if debug:
                        print(f"📋 Found fieldList '{fieldlist_name}' with {len(field_list_values)} rows.")
                    
                    # Duyệt qua từng dòng (field_group) trong fieldList
                    for i, field_group in enumerate(field_list_values):
                        if isinstance(field_group, list):
                            # Duyệt qua từng trường (sub_field) trong dòng
                            for sub_field in field_group:
                                if isinstance(sub_field, dict) and sub_field.get('name') == target_field_name:
                                    value = sub_field.get('value')
                                    extracted_values.append(value)
                                    if debug:
                                        print(f"   ✅ Row {i+1}: Found value '{value}'")
                    
                    # Sau khi duyệt xong, không cần tìm nữa
                    if debug:
                        print(f"📊 Total values found: {len(extracted_values)}")
                    return extracted_values
            
            if debug:
                print(f"❌ FieldList '{fieldlist_name}' not found in form data.")
            return extracted_values

        except Exception as e:
            print(f"❌ Error extracting all values from fieldList: {e}")
            return extracted_values

    def extract_fields_by_prefix(self, form_data: List[Dict], prefix: str, debug: bool = False) -> Dict[str, Any]:
        """
        ✅ MỚI: Trích xuất tất cả các trường có tên bắt đầu bằng một tiền tố (prefix) cho trước.
        
        Hữu ích để tìm các trường động như "Số tiền tạm ứng lần 1:", "Số tiền tạm ứng lần 2:",...
        
        Args:
            form_data: Form data từ API.
            prefix: Tiền tố dùng để tìm kiếm (ví dụ: "Số tiền tạm ứng lần").
            debug: Bật/tắt in thông tin gỡ lỗi.
            
        Returns:
            Dict[str, Any]: Một dictionary với key là tên đầy đủ của trường và value là giá trị của nó.
        """
        extracted_fields = {}
        try:
            if debug:
                print(f"🔍 Searching for all fields with prefix: '{prefix}'")
            
            # Duyệt qua tất cả các trường ở mọi cấp độ
            for field in form_data:
                field_name = field.get('name')
                
                # Kiểm tra trường ở cấp cao nhất
                if field_name and field_name.startswith(prefix):
                    value = field.get('value')
                    extracted_fields[field_name] = value
                    if debug:
                        print(f"   ✅ Found top-level field: '{field_name}' = {value}")
                
                # Kiểm tra các trường lồng trong fieldList
                if field.get('type') == 'fieldList' and 'value' in field:
                    field_list_values = field.get('value', [])
                    if isinstance(field_list_values, list):
                        for field_group in field_list_values:
                            if isinstance(field_group, list):
                                for sub_field in field_group:
                                    sub_field_name = sub_field.get('name')
                                    if sub_field_name and sub_field_name.startswith(prefix):
                                        value = sub_field.get('value')
                                        extracted_fields[sub_field_name] = value
                                        if debug:
                                            print(f"   ✅ Found nested field: '{sub_field_name}' = {value}")
            
            if debug:
                print(f"📊 Total fields found with prefix: {len(extracted_fields)}")
            return extracted_fields

        except Exception as e:
            print(f"❌ Error extracting fields by prefix '{prefix}': {e}")
            return extracted_fields
============================================================

============================================================
FILE: app\core\utils\helpers.py
============================================================
from typing import Optional, Dict, Any
from datetime import datetime
import pandas as pd
import json
import os

def extract_instance_code(event_data: Dict) -> Optional[str]:
    """Trích xuất instance_code từ event"""
    try:
        event_body = event_data.get("event", {})
        if "instance_code" in event_body:
            return event_body["instance_code"]
            
        if "object" in event_body and "instance_code" in event_body["object"]:
            return event_body["object"]["instance_code"]
            
        return None
    except:
        return None

def get_event_type(event_data: Dict) -> str:
    """Lấy event type"""
    try:
        if "header" in event_data:
            return event_data["header"].get("event_type", "unknown")
        
        if "event" in event_data and "type" in event_data["event"]:
            return event_data["event"]["type"]
            
        return event_data.get("type", "unknown")
    except:
        return "unknown"

async def save_event_to_csv(event_data: Dict, events_file: str = "lark_events.csv"):
    """Lưu event vào CSV"""
    try:
        row_data = {
            "timestamp": datetime.now().isoformat(),
            "event_type": get_event_type(event_data),
            "instance_code": extract_instance_code(event_data),
            "raw_event": json.dumps(event_data, ensure_ascii=False)
        }
        
        df = pd.DataFrame([row_data])
        
        if os.path.exists(events_file):
            df.to_csv(events_file, mode='a', header=False, index=False, encoding='utf-8')
        else:
            df.to_csv(events_file, mode='w', header=True, index=False, encoding='utf-8')
            
        print(f"✅ Event saved to {events_file}")
        
    except Exception as e:
        print(f"❌ Error saving event: {e}")

def format_currency(amount: float) -> str:
    """Format số tiền theo định dạng VND"""
    return f"{amount:,} VND"

def get_short_node_id(node_id: str, length: int = 8) -> str:
    """Get short version of node ID for display"""
    return node_id[:length] + "..." if len(node_id) > length else node_id

============================================================

============================================================
FILE: app\domains\__init__.py
============================================================
"""
Domain package exports
"""
from app.domains.qr_generation import *
from app.domains.validation import *
from app.domains.notification import *

__all__ = [
    # QR Generation Domain
    "QRRequest", "QRResponse", "QRType", 
    "qr_service", "qr_event_handler",
    
    # Validation Domain  
    "ValidationResult", "ValidationResponse", "ValidationType",
    "validation_service", "validation_event_handler",
    
    # Notification Domain
    "NotificationResult", "NotificationType", "NotificationChannel",
    "notification_coordinator", "lark_webhook_service"
]

============================================================

============================================================
FILE: app\domains\notification\__init__.py
============================================================
# app/domains/notification/__init__.py
from .models import *
from .services import *

__all__ = [
    # Models
    "NotificationType", "NotificationResult", "NotificationRequest",
    # Services
    "lark_webhook_service", "notification_coordinator"
]

============================================================

============================================================
FILE: app\domains\notification\models\__init__.py
============================================================
from .notification import (
    NotificationType,
    NotificationChannel,
    NotificationPriority,
    NotificationRequest,
    NotificationResult,
    ValidationAlertRequest,
    CustomAlertRequest
)

__all__ = [
    "NotificationType",
    "NotificationChannel",
    "NotificationPriority",
    "NotificationRequest", 
    "NotificationResult",
    "ValidationAlertRequest",
    "CustomAlertRequest"
]

============================================================

============================================================
FILE: app\domains\notification\models\notification.py
============================================================
from pydantic import BaseModel
from typing import Optional, List, Dict, Any
from enum import Enum

class NotificationType(str, Enum):
    VALIDATION_ALERT = "validation_alert"
    CUSTOM_ALERT = "custom_alert"
    SERVICE_ERROR = "service_error"
    SYSTEM_NOTIFICATION = "system_notification"

class NotificationChannel(str, Enum):
    LARK_WEBHOOK = "lark_webhook"
    EMAIL = "email"
    SMS = "sms"

class NotificationPriority(str, Enum):
    LOW = "low"
    NORMAL = "normal"
    HIGH = "high"
    URGENT = "urgent"

class NotificationRequest(BaseModel):
    notification_type: NotificationType
    channel: NotificationChannel
    title: str
    message: str
    instance_code: Optional[str] = None
    priority: NotificationPriority = NotificationPriority.NORMAL
    metadata: Optional[Dict[str, Any]] = None

class NotificationResult(BaseModel):
    success: bool
    notification_type: NotificationType
    channel: NotificationChannel
    instance_code: Optional[str] = None
    sent_at: Optional[str] = None
    cached: bool = False
    cache_hit: bool = False
    error: Optional[str] = None
    metadata: Optional[Dict[str, Any]] = None

class ValidationAlertRequest(BaseModel):
    instance_code: str
    serial_number: Optional[str] = None
    validation_errors: List[str]
    priority: NotificationPriority = NotificationPriority.HIGH

class CustomAlertRequest(BaseModel):
    title: str
    message: str
    instance_code: Optional[str] = None
    priority: NotificationPriority = NotificationPriority.NORMAL

============================================================

============================================================
FILE: app\domains\notification\services\__init__.py
============================================================
# app/domains/notification/services/__init__.py
from .lark_webhook_service import lark_webhook_service
from .notification_coordinator import notification_coordinator

__all__ = ["lark_webhook_service", "notification_coordinator"]

============================================================

============================================================
FILE: app\domains\notification\services\lark_webhook_service.py
============================================================
"""
Lark Webhook Service - Dịch vụ gửi thông báo qua Lark webhook
"""
import requests
import json
from typing import List
from datetime import datetime
from app.core.config.settings import settings
from app.domains.notification.models import (
    NotificationResult, NotificationType, NotificationChannel,
    ValidationAlertRequest, CustomAlertRequest
)


class LarkWebhookService:
    """
    Dịch vụ gửi thông báo qua Lark webhook.
    
    Class này cung cấp khả năng gửi các loại thông báo khác nhau đến
    Lark (FeisHu) thông qua webhook API:
    
    - Validation alerts: Cảnh báo khi phát hiện lỗi validation
    - Custom alerts: Thông báo tùy chỉnh cho các sự kiện đặc biệt
    
    Service này hỗ trợ:
    - Format message theo chuẩn Lark webhook API
    - Error handling và retry logic
    - Tracking kết quả gửi với timestamp
    - Integration với notification coordinator
    - Configuration-based enabling/disabling
    
    Attributes:
        webhook_url (str): URL webhook của Lark từ settings
        channel (NotificationChannel): Channel type cho service này
    """
    
    def __init__(self):
        """Khởi tạo LarkWebhookService với cấu hình từ settings."""
        self.webhook_url = settings.LARK_WEBHOOK_URL
        self.channel = NotificationChannel.LARK_WEBHOOK
    
    async def send_validation_alert(self, request: ValidationAlertRequest) -> NotificationResult:
        """
        Gửi cảnh báo validation error qua Lark webhook.
        
        Method này sẽ format và gửi thông báo cảnh báo khi hệ thống
        phát hiện lỗi validation trong quy trình phê duyệt.
        
        Quy trình xử lý:
        1. Kiểm tra cấu hình có enable validation alerts không
        2. Validate webhook URL có được cấu hình không
        3. Format message theo template cảnh báo validation
        4. Gửi HTTP POST request đến Lark webhook
        5. Trả về kết quả với thông tin chi tiết
        
        Args:
            request (ValidationAlertRequest): Request chứa thông tin validation alert
                - instance_code: Mã instance có lỗi validation
                - validation_errors: Danh sách lỗi validation
                - priority: Mức độ ưu tiên của alert
        
        Returns:
            NotificationResult: Kết quả gửi thông báo bao gồm:
                - success: Trạng thái gửi thành công
                - notification_type: VALIDATION_ALERT
                - channel: LARK_WEBHOOK
                - instance_code: Mã instance liên quan
                - sent_at: Thời gian gửi (nếu thành công)
                - error: Thông báo lỗi (nếu thất bại)
                - metadata: Thông tin bổ sung (số lỗi, priority)
        """
        try:
            # Bước 1: Kiểm tra cấu hình có enable validation alerts không
            if not settings.ENABLE_VALIDATION_ALERTS:
                print(f"⚠️ Tính năng cảnh báo validation đã bị tắt, bỏ qua webhook cho {request.instance_code}")
                return NotificationResult(
                    success=True,  # Trả về success vì đã xử lý (disabled)
                    notification_type=NotificationType.VALIDATION_ALERT,
                    channel=self.channel,
                    instance_code=request.instance_code,
                    cached=True,
                    metadata={"disabled": True, "reason": "ENABLE_VALIDATION_ALERTS = False"}
                )
            
            # Bước 2: Kiểm tra webhook URL có được cấu hình không
            if not self.webhook_url:
                print(f"❌ Chưa cấu hình webhook URL cho Lark")
                return NotificationResult(
                    success=False,
                    notification_type=NotificationType.VALIDATION_ALERT,
                    channel=self.channel,
                    instance_code=request.instance_code,
                    error="Chưa cấu hình webhook URL"
                )
            
            # Bước 3: Format danh sách lỗi validation thành text dễ đọc
            print(f"📝 Đang format {len(request.validation_errors)} lỗi validation...")
            error_messages = "\n".join([f"• {error}" for error in request.validation_errors])
            
            # Tạo message data theo format của Lark webhook API
            message_data = {
                "msg_type": "text",
                "content": {
                    "text": f"""⚠️ CẢNH BÁO DỮ LIỆU KHÔNG HỢP LỆ
📄 Request No.: {request.serial_number}
❌ Các lỗi phát hiện:
{error_messages}

🔧 Vui lòng kiểm tra và xử lý."""
                }
            }
            
            # Cấu hình headers cho HTTP request
            headers = {"Content-Type": "application/json"}
            
            # Bước 4: Gửi HTTP POST request đến Lark webhook
            print(f"🚨 Đang gửi cảnh báo validation qua webhook cho {request.instance_code}")
            response = requests.post(
                self.webhook_url, 
                headers=headers, 
                data=json.dumps(message_data),
                timeout=10  # Timeout 10 giây để tránh treo
            )
            
            # Bước 5: Xử lý response và tạo kết quả
            success = response.status_code == 200
            sent_at = datetime.now().isoformat() if success else None
            
            if success:
                print(f"✅ Gửi cảnh báo validation thành công cho {request.instance_code}")
            else:
                print(f"❌ Gửi cảnh báo validation thất bại: HTTP {response.status_code} - {response.text}")
            
            return NotificationResult(
                success=success,
                notification_type=NotificationType.VALIDATION_ALERT,
                channel=self.channel,
                instance_code=request.instance_code,
                sent_at=sent_at,
                error=None if success else f"HTTP {response.status_code}: {response.text}",
                metadata={
                    "errors_count": len(request.validation_errors),
                    "priority": request.priority.value,
                    "response_status": response.status_code
                }
            )
                
        except requests.exceptions.Timeout:
            print(f"⏰ Timeout khi gửi validation webhook (quá 10 giây)")
            return NotificationResult(
                success=False,
                notification_type=NotificationType.VALIDATION_ALERT,
                channel=self.channel,
                instance_code=request.instance_code,
                error="Timeout khi gửi webhook"
            )
        except requests.exceptions.ConnectionError:
            print(f"🔌 Lỗi kết nối khi gửi validation webhook")
            return NotificationResult(
                success=False,
                notification_type=NotificationType.VALIDATION_ALERT,
                channel=self.channel,
                instance_code=request.instance_code,
                error="Lỗi kết nối webhook"
            )
        except Exception as e:
            print(f"❌ Lỗi không xác định khi gửi validation webhook: {e}")
            return NotificationResult(
                success=False,
                notification_type=NotificationType.VALIDATION_ALERT,
                channel=self.channel,
                instance_code=request.instance_code,
                error=str(e)
            )

    async def send_custom_alert(self, request: CustomAlertRequest) -> NotificationResult:
        """
        Gửi thông báo tùy chỉnh qua Lark webhook.
        
        Method này cho phép gửi các thông báo tùy chỉnh với title và message
        do người dùng định nghĩa, phù hợp cho các sự kiện đặc biệt hoặc
        thông báo hệ thống.
        
        Args:
            request (CustomAlertRequest): Request chứa thông tin custom alert
                - title: Tiêu đề thông báo
                - message: Nội dung thông báo
                - instance_code: Mã instance liên quan (optional)
                - priority: Mức độ ưu tiên
        
        Returns:
            NotificationResult: Kết quả gửi thông báo tương tự send_validation_alert
        """
        try:
            # Bước 1: Kiểm tra cấu hình và webhook URL
            if not settings.ENABLE_VALIDATION_ALERTS or not self.webhook_url:
                print(f"❌ Alerts bị tắt hoặc chưa cấu hình webhook URL")
                return NotificationResult(
                    success=False,
                    notification_type=NotificationType.CUSTOM_ALERT,
                    channel=self.channel,
                    instance_code=request.instance_code,
                    error="Alerts bị tắt hoặc chưa cấu hình webhook URL"
                )
            
            # Bước 2: Format message với title và nội dung tùy chỉnh
            print(f"📝 Đang tạo custom alert: {request.title}")
            alert_text = f"""🔔 {request.title}"""
            
            # Thêm instance code nếu có
            if request.instance_code:
                alert_text += f"\n📄 Instance: {request.instance_code}"
                
            alert_text += f"\n📢 {request.message}"
            
            # Tạo message data cho Lark webhook
            message_data = {
                "msg_type": "text",
                "content": {"text": alert_text}
            }
            
            # Bước 3: Gửi HTTP request
            print(f"📤 Đang gửi custom alert qua webhook...")
            headers = {"Content-Type": "application/json"}
            response = requests.post(
                self.webhook_url, 
                headers=headers, 
                data=json.dumps(message_data),
                timeout=10
            )
            
            # Bước 4: Xử lý kết quả
            success = response.status_code == 200
            sent_at = datetime.now().isoformat() if success else None
            
            if success:
                print(f"✅ Gửi custom alert thành công: {request.title}")
            else:
                print(f"❌ Gửi custom alert thất bại: HTTP {response.status_code} - {response.text}")
            
            return NotificationResult(
                success=success,
                notification_type=NotificationType.CUSTOM_ALERT,
                channel=self.channel,
                instance_code=request.instance_code,
                sent_at=sent_at,
                error=None if success else f"HTTP {response.status_code}: {response.text}",
                metadata={
                    "title": request.title,
                    "priority": request.priority.value,
                    "has_instance_code": request.instance_code is not None,
                    "response_status": response.status_code
                }
            )
            
        except requests.exceptions.Timeout:
            print(f"⏰ Timeout khi gửi custom alert webhook")
            return NotificationResult(
                success=False,
                notification_type=NotificationType.CUSTOM_ALERT,
                channel=self.channel,
                instance_code=request.instance_code,
                error="Timeout khi gửi webhook"
            )
        except requests.exceptions.ConnectionError:
            print(f"🔌 Lỗi kết nối khi gửi custom alert webhook")
            return NotificationResult(
                success=False,
                notification_type=NotificationType.CUSTOM_ALERT,
                channel=self.channel,
                instance_code=request.instance_code,
                error="Lỗi kết nối webhook"
            )
        except Exception as e:
            print(f"❌ Lỗi khi gửi custom alert: {e}")
            return NotificationResult(
                success=False,
                notification_type=NotificationType.CUSTOM_ALERT,
                channel=self.channel,
                instance_code=request.instance_code,
                error=str(e)
            )


lark_webhook_service = LarkWebhookService()
============================================================

============================================================
FILE: app\domains\notification\services\notification_coordinator.py
============================================================
"""
Notification Coordinator - Bộ điều phối trung tâm cho tất cả kênh thông báo
"""
from typing import List, Dict, Any
from app.domains.notification.models import (
    NotificationRequest, NotificationResult, NotificationType, 
    NotificationChannel, ValidationAlertRequest, CustomAlertRequest
)
from app.domains.notification.services.lark_webhook_service import lark_webhook_service
from app.core.infrastructure.cache_service import cache_service


class NotificationCoordinator:
    """
    Bộ điều phối trung tâm cho tất cả các kênh thông báo.
    
    Class này hoạt động như một central hub để:
    1. Quản lý và điều phối các kênh thông báo khác nhau (Lark, Email, SMS, etc.)
    2. Ngăn chặn duplicate notifications thông qua caching mechanism
    3. Route notifications đến đúng service dựa trên channel và type
    4. Cung cấp interface thống nhất cho việc gửi thông báo
    5. Track và log kết quả gửi thông báo
    
    Supported channels:
    - LARK_WEBHOOK: Gửi thông báo qua Lark webhook
    - Có thể mở rộng thêm EMAIL, SMS, SLACK, etc.
    
    Supported notification types:
    - VALIDATION_ALERT: Cảnh báo validation errors
    - CUSTOM_ALERT: Cảnh báo tùy chỉnh
    - QR_GENERATION: Thông báo tạo QR (tương lai)
    
    Attributes:
        channels (Dict): Map từ notification channel đến service implementation
    """
    
    def __init__(self):
        """Khởi tạo NotificationCoordinator với các kênh thông báo được hỗ trợ."""
        # Mapping từ notification channel đến service implementation
        # Dễ dàng mở rộng thêm channels mới trong tương lai
        self.channels = {
            NotificationChannel.LARK_WEBHOOK: lark_webhook_service
            # Có thể thêm:
            # NotificationChannel.EMAIL: email_service,
            # NotificationChannel.SMS: sms_service,
            # NotificationChannel.SLACK: slack_service,
        }
    
    async def send_notification(self, request: NotificationRequest) -> NotificationResult:
        """
        Gửi thông báo qua kênh được chỉ định với tính năng chống trùng lặp.
        
        Đây là method chính của coordinator, thực hiện:
        1. Kiểm tra duplicate notifications dựa trên cache
        2. Validate và route đến đúng channel service  
        3. Gọi method phù hợp dựa trên notification type
        4. Cache kết quả để tránh duplicate trong tương lai
        5. Trả về kết quả chi tiết cho monitoring
        
        Args:
            request (NotificationRequest): Request chứa thông tin notification cần gửi
            
        Returns:
            NotificationResult: Kết quả gửi thông báo bao gồm:
                - success (bool): Trạng thái gửi thành công
                - notification_type: Loại thông báo
                - channel: Kênh đã sử dụng
                - instance_code: Mã instance liên quan
                - cached (bool): Có được cache không
                - cache_hit (bool): Có bị skip do cache không
                - error (str): Thông báo lỗi nếu có
                - metadata (Dict): Thông tin bổ sung
        """
        
        # Bước 1: Kiểm tra duplicate notifications dựa trên cache
        if request.instance_code:
            # Tạo cache key duy nhất cho combination của type và instance
            cache_key = f"{request.notification_type.value}_{request.instance_code}"
            
            print(f"🔍 Kiểm tra duplicate notification cho: {cache_key}")
            
            # Kiểm tra xem đã gửi notification tương tự gần đây chưa
            if cache_service.is_validation_alert_recently_sent(
                request.instance_code, 
                request.notification_type.value,
                cache_duration_minutes=10
            ):
                print(f"🔄 PHÁT HIỆN THÔNG BÁO TRÙNG LẶP: {cache_key}")
                print(f"   → BỎ QUA gửi thông báo để tránh spam")
                
                return NotificationResult(
                    success=True,  # Trả về success vì đã xử lý (cached)
                    notification_type=request.notification_type,
                    channel=request.channel,
                    instance_code=request.instance_code,
                    cached=True,
                    cache_hit=True,
                    metadata={
                        "reason": "duplicate_prevention",
                        "cache_key": cache_key,
                        "cache_duration_minutes": 10
                    }
                )
        
        # Bước 2: Validate và lấy channel service
        print(f"📡 Đang định tuyến đến kênh: {request.channel.value}")
        channel_service = self.channels.get(request.channel)
        
        if not channel_service:
            print(f"❌ Kênh không được hỗ trợ: {request.channel.value}")
            return NotificationResult(
                success=False,
                notification_type=request.notification_type,
                channel=request.channel,
                instance_code=request.instance_code,
                error=f"Kênh không được hỗ trợ: {request.channel.value}",
                metadata={
                    "available_channels": list(self.channels.keys())
                }
            )
        
        # Bước 3: Route đến method phù hợp dựa trên notification type
        print(f"🎯 Xử lý loại thông báo: {request.notification_type.value}")
        
        if request.notification_type == NotificationType.VALIDATION_ALERT:
            # Xử lý validation alert
            print(f"🔔 Tạo validation alert request...")
            alert_request = ValidationAlertRequest(
                instance_code=request.instance_code,
                validation_errors=[request.message],
                priority=request.priority
            )
            
            print(f"📤 Đang gửi validation alert qua {request.channel.value}...")
            result = await channel_service.send_validation_alert(alert_request)
        
        elif request.notification_type == NotificationType.CUSTOM_ALERT:
            # Xử lý custom alert
            print(f"🎨 Tạo custom alert request...")
            alert_request = CustomAlertRequest(
                title=request.title,
                message=request.message,
                instance_code=request.instance_code,
                priority=request.priority
            )
            
            print(f"📤 Đang gửi custom alert qua {request.channel.value}...")
            result = await channel_service.send_custom_alert(alert_request)
        
        else:
            # Notification type không được hỗ trợ
            print(f"❌ Loại thông báo không được hỗ trợ: {request.notification_type.value}")
            return NotificationResult(
                success=False,
                notification_type=request.notification_type,
                channel=request.channel,
                instance_code=request.instance_code,
                error=f"Loại thông báo không được hỗ trợ: {request.notification_type.value}",
                metadata={
                    "available_types": [nt.value for nt in NotificationType]
                }
            )
        
        # Bước 4: Xử lý kết quả và cache nếu thành công
        if result.success and request.instance_code:
            print(f"✅ Gửi thông báo thành công - đánh dấu cache")
            
            # Đánh dấu đã gửi trong cache để tránh duplicate
            cache_service.mark_validation_alert_as_sent(
                request.instance_code, 
                request.notification_type.value
            )
            
            print(f"💾 Đã lưu vào cache để tránh duplicate trong 10 phút")
        elif result.success:
            print(f"✅ Gửi thông báo thành công (không có instance_code để cache)")
        else:
            print(f"❌ Gửi thông báo thất bại: {getattr(result, 'error', 'Lỗi không xác định')}")
        
        return result


# Instance toàn cục của coordinator để sử dụng trong toàn bộ hệ thống
notification_coordinator = NotificationCoordinator()
============================================================

============================================================
FILE: app\domains\qr_generation\__init__.py
============================================================
from .models import *
from .services import *
from .handlers import *

__all__ = [
    # Models
    "QRType", "BankInfo", "QRGenerationResult",
    # Services  
    "vietqr_service", "qr_processor",
    # Handlers
    "qr_event_handler"
]

============================================================

============================================================
FILE: app\domains\qr_generation\handlers\__init__.py
============================================================
from .qr_event_handler import qr_event_handler

__all__ = ["qr_event_handler"]

============================================================

============================================================
FILE: app\domains\qr_generation\handlers\qr_event_handler.py
============================================================
from typing import Dict
from app.core.infrastructure.lark_service import lark_service
from app.domains.qr_generation.services.qr_processor import qr_processor

class QREventHandler:
    """
    Bộ xử lý sự kiện tạo mã QR cho hệ thống phê duyệt Lark.
    
    Class này hoạt động như một event handler độc lập, nhận và xử lý
    các sự kiện phê duyệt để tự động tạo mã VietQR tương ứng.
    
    Quy trình xử lý:
    1. Nhận sự kiện phê duyệt từ hệ thống
    2. Trích xuất instance_code từ event data
    3. Lấy access token để gọi Lark API
    4. Gửi đến QRProcessor để xử lý tạo QR
    5. Trả về kết quả xử lý
    
    Attributes:
        name (str): Tên định danh của service ("QR_Generator")
    """
    
    def __init__(self):
        """Khởi tạo QREventHandler với tên service."""
        self.name = "QR_Generator"
    
    async def handle_approval_event(self, event_data: Dict) -> Dict:
        """
        Xử lý sự kiện phê duyệt để tạo mã QR tự động.
        
        [NÂNG CẤP] Bổ sung logic kiểm tra trạng thái đơn. Sẽ bỏ qua xử lý
        nếu đơn ở trạng thái cuối cùng như REJECTED, CANCELED, DELETED.
        
        Đây là method chính của handler, hoạt động hoàn toàn độc lập
        và không phụ thuộc vào các service khác. Method sẽ:
        
        1. Validate dữ liệu đầu vào (instance_code)
        2. Lấy access token từ Lark service
        3. Gọi QRProcessor để xử lý business logic
        4. Trả về kết quả chi tiết cho monitoring
        
        Args:
            event_data (Dict): Dữ liệu sự kiện chứa thông tin phê duyệt.
                             Bắt buộc phải có 'instance_code'
        
        Returns:
            Dict: Kết quả xử lý bao gồm:
                - success (bool): Trạng thái xử lý thành công
                - message (str): Thông báo chi tiết kết quả
                - instance_code (str): Mã instance đã xử lý (nếu có)
                - service (str): Tên service thực hiện
        
        Raises:
            Exception: Các lỗi không xác định sẽ được bắt và trả về trong response
        """
        try:
            # Bước 1: Validate và trích xuất instance_code từ event data
            instance_code = event_data.get('instance_code')
            if not instance_code:
                print(f"❌ [QR Handler] Thiếu instance_code trong dữ liệu sự kiện")
                return {
                    "success": False,
                    "message": "Không tìm thấy instance_code trong dữ liệu sự kiện", 
                    "service": self.name
                }
            
            # [THÊM MỚI] Bắt đầu khối logic kiểm tra trạng thái
            FINAL_STATUSES = ['REJECTED', 'CANCELED', 'DELETED']

            # Trích xuất trạng thái từ dữ liệu gốc của sự kiện để tránh gọi API không cần thiết
            raw_data = event_data.get('raw_data', {})
            instance_status = raw_data.get('event', {}).get('object', {}).get('status')
            
            # Kiểm tra xem trạng thái của đơn có nằm trong danh sách cần bỏ qua không
            if instance_status and instance_status in FINAL_STATUSES:
                print(f"⏭️ [QR Handler] Bỏ qua instance {instance_code} do có trạng thái cuối cùng: {instance_status}")
                return {
                    "success": True, # Coi như thành công vì đã xử lý đúng (bỏ qua)
                    "message": f"Bỏ qua xử lý do trạng thái đơn là {instance_status}",
                    "instance_code": instance_code,
                    "service": self.name
                }
            # [THÊM MỚI] Kết thúc khối logic kiểm tra trạng thái
            
            print(f"🏦 [QR Handler] Dịch vụ QR đang xử lý instance: {instance_code} (Trạng thái: {instance_status or 'N/A'})")
            
            # Bước 2: Lấy access token để gọi Lark API
            print(f"🔑 Đang lấy access token từ Lark...")
            access_token = await lark_service.get_access_token()
            if not access_token:
                print(f"❌ Không thể lấy access token từ Lark")
                return {
                    "success": False,
                    "message": "Không thể lấy access token từ Lark",
                    "service": self.name
                }
            
            print(f"✅ Đã lấy access token thành công")
            
            # Bước 3: Gửi đến QRProcessor để xử lý business logic chính
            print(f"⚙️ Bắt đầu xử lý tạo QR cho {instance_code}...")
            result = await qr_processor.process_approval_with_qr_comment(
                instance_code, access_token
            )
            
            # Bước 4: Tạo response với thông tin chi tiết
            if result:
                print(f"✅ [QR Handler] Hoàn thành xử lý QR cho {instance_code}")
                return {
                    "success": True,
                    "message": f"Xử lý QR hoàn thành thành công cho {instance_code}",
                    "instance_code": instance_code,
                    "service": self.name
                }
            else:
                print(f"❌ [QR Handler] Xử lý QR thất bại cho {instance_code}")
                return {
                    "success": False,
                    "message": f"Xử lý QR thất bại cho {instance_code}",
                    "instance_code": instance_code,
                    "service": self.name
                }
            
        except Exception as e:
            # Bắt tất cả exception không xác định để tránh crash service
            print(f"❌ Lỗi không xác định trong QR Service: {str(e)}")
            import traceback
            print(f"📋 Chi tiết lỗi:\n{traceback.format_exc()}")
            
            return {
                "success": False,
                "message": f"Lỗi QR Service: {str(e)}",
                "service": self.name,
                "error_type": type(e).__name__
            }

qr_event_handler = QREventHandler()
============================================================

============================================================
FILE: app\domains\qr_generation\models\__init__.py
============================================================
from .qr import (
    QRType,
    BankInfo,
    AmountDetectionResult,
    QRTypeResult,
    NodeProcessingResult,
    QRGenerationRequest,
    QRGenerationResult
)

__all__ = [
    "QRType",
    "BankInfo", 
    "AmountDetectionResult",
    "QRTypeResult",
    "NodeProcessingResult",
    "QRGenerationRequest",
    "QRGenerationResult"
]

============================================================

============================================================
FILE: app\domains\qr_generation\models\qr.py
============================================================
from pydantic import BaseModel
from typing import Optional, Dict, Any
from enum import Enum

class QRType(str, Enum):
    ADVANCE = "advance"
    PAYMENT = "payment"
    NONE = "none"

class BankInfo(BaseModel):
    bank_id: str
    account_no: str
    account_name: str

class AmountDetectionResult(BaseModel):
    advance_amount: Optional[float] = None
    payment_amount: Optional[float] = None
    advance_field_found: bool = False
    payment_field_found: bool = False
    all_amount_fields: Dict[str, Any] = {}
    fields_used: Dict[str, Optional[str]] = {}

class QRTypeResult(BaseModel):
    qr_type: QRType
    amount: Optional[float] = None
    field_used: Optional[str] = None
    reason: str

class NodeProcessingResult(BaseModel):
    success: bool
    qr_type: QRType = QRType.NONE
    amount: Optional[float] = None
    field_used: Optional[str] = None
    node_strategy: Optional[str] = None
    reason: Optional[str] = None
    error: Optional[str] = None
    field_detection: Optional[AmountDetectionResult] = None

class QRGenerationRequest(BaseModel):
    instance_code: str
    node_id: str
    qr_type: QRType
    amount: int
    bank_info: BankInfo
    description: str

class QRGenerationResult(BaseModel):
    success: bool
    qr_type: Optional[QRType] = None
    amount: Optional[float] = None
    field_used: Optional[str] = None
    node_name: Optional[str] = None
    comment_id: Optional[str] = None
    error: Optional[str] = None
    processing_info: Optional[Dict[str, Any]] = None

============================================================

============================================================
FILE: app\domains\qr_generation\routers\qr.py
============================================================
from fastapi import APIRouter, Depends
from app.domains.qr_generation.models import QRGenerationResult
from app.domains.qr_generation.services.qr_processor import qr_processor
from app.core.infrastructure.lark_service import lark_service

router = APIRouter(prefix="/qr", tags=["QR Generation"])

@router.post("/process/{instance_code}", response_model=QRGenerationResult)
async def manual_process_qr(instance_code: str):
    """Enhanced manual QR processing với domain models"""
    try:
        access_token = await lark_service.get_access_token()
        if not access_token:
            return QRGenerationResult(
                success=False,
                error="Cannot get access token"
            )
        
        # Process the instance
        result = await qr_processor.process_approval_with_qr_comment(instance_code, access_token)
        
        return QRGenerationResult(
            success=result,
            processing_info={
                "instance_code": instance_code,
                "processed": result
            }
        )
            
    except Exception as e:
        return QRGenerationResult(
            success=False,
            error=str(e)
        )

@router.get("/cache/status")
async def get_qr_cache_status():
    """Xem trạng thái QR cache"""
    from app.core.infrastructure.cache_service import cache_service
    cache_status = cache_service.get_cache_status()
    return cache_status.get('qr_cache', {})

@router.post("/cache/clear")
async def clear_qr_cache():
    """Clear QR cache"""
    from app.core.infrastructure.cache_service import cache_service
    result = cache_service.clear_cache()
    return {
        "message": "QR cache cleared",
        "details": result
    }

============================================================

============================================================
FILE: app\domains\qr_generation\services\__init__.py
============================================================
from .vietqr_service import vietqr_service
from .amount_detector import AmountDetector
from .qr_processor import qr_processor

__all__ = [
    "vietqr_service",
    "AmountDetector", 
    "qr_processor"
]

============================================================

============================================================
FILE: app\domains\qr_generation\services\amount_detector.py
============================================================
from typing import Dict, List, Optional
from app.core.config.node_config import get_node_config
from app.core.config.field_constants import FFN
from app.core.utils.field_extractor import FieldExtractor
from app.domains.qr_generation.models import AmountDetectionResult, QRTypeResult, QRType


class AmountDetector:
    """
    Bộ phát hiện và xác định số tiền cho việc tạo mã QR.

    Class này chịu trách nhiệm phân tích dữ liệu form để:
    - Tìm kiếm các trường chứa thông tin số tiền
    - Xác định loại QR (tạm ứng hoặc thanh toán) dựa trên node strategy
    - Validate và trả về số tiền phù hợp cho từng node

    Hỗ trợ nhiều chiến lược xử lý khác nhau:
    - detect_both_fields: Phát hiện cả tạm ứng và thanh toán
    - payment_field_only: Chỉ xử lý trường thanh toán

    Attributes:
        field_extractor (FieldExtractor): Công cụ trích xuất dữ liệu từ form
    """

    def __init__(self):
        """Khởi tạo AmountDetector với FieldExtractor."""
        self.field_extractor = FieldExtractor()

    def detect_available_amount_fields(self, form_data: List[Dict], node_config: Dict = None) -> Dict:
        """
        Quét dữ liệu form để tìm các trường số tiền theo cấu hình node.
        
        Phương thức này sẽ tìm kiếm các trường tạm ứng và thanh toán dựa trên
        cấu hình của node. Nếu không có cấu hình, sẽ sử dụng tên trường mặc định.
        
        Args:
            form_data (List[Dict]): Dữ liệu form từ API response của Lark
            node_config (Dict, optional): Cấu hình node chứa tên các trường cần tìm
            
        Returns:
            Dict: Kết quả phát hiện bao gồm:
                - advance_amount: Giá trị số tiền tạm ứng
                - payment_amount: Giá trị số tiền thanh toán  
                - advance_field_found: Có tìm thấy trường tạm ứng không
                - payment_field_found: Có tìm thấy trường thanh toán không
                - all_amount_fields: Tất cả trường chứa từ khóa tiền
                - fields_used: Tên các trường đã sử dụng để tìm kiếm
        """
        try:
            # Lấy tên trường từ cấu hình node hoặc sử dụng giá trị mặc định
            if node_config:
                advance_field = node_config.get('advance_field')
                payment_field = node_config.get('payment_field')
            else:
                # Giá trị mặc định để tương thích ngược
                advance_field = FFN.ADVANCE_AMOUNT
                payment_field = FFN.PAYMENT_AMOUNT
            
            # Trích xuất giá trị từ cả 2 trường (chỉ khi tên trường không phải None)
            advance_value = None
            payment_value = None
            
            if advance_field:
                advance_value = self.field_extractor.extract_field_value(form_data, advance_field)
            
            if payment_field:
                payment_value = self.field_extractor.extract_field_value(form_data, payment_field)
            
            # Debug: Tìm tất cả trường có chứa từ khóa "tiền" hoặc "amount"
            all_amount_fields = self.field_extractor.get_amount_fields(form_data)
            
            # Tạo kết quả chi tiết
            result = {
                'advance_amount': advance_value,
                'payment_amount': payment_value,
                'advance_field_found': advance_value is not None,
                'payment_field_found': payment_value is not None,
                'all_amount_fields': all_amount_fields,
                'fields_used': {
                    'advance_field': advance_field,
                    'payment_field': payment_field
                }
            }
            
            # Hiển thị kết quả phát hiện trường
            print(f"💰 Kết quả phát hiện trường số tiền:")
            if advance_field:
                status = f"✅ {advance_value}" if advance_value else "❌ Không tìm thấy"
                print(f"   - {advance_field}: {status}")
            else:
                print(f"   - Trường tạm ứng: ❌ Chưa được cấu hình")
                
            if payment_field:
                status = f"✅ {payment_value}" if payment_value else "❌ Không tìm thấy"
                print(f"   - {payment_field}: {status}")
            else:
                print(f"   - Trường thanh toán: ❌ Chưa được cấu hình")
                
            print(f"   - Tất cả trường số tiền: {list(all_amount_fields.keys())}")
            
            return result
            
        except Exception as e:
            print(f"❌ Lỗi khi phát hiện trường số tiền: {e}")
            return {
                'advance_amount': None,
                'payment_amount': None,
                'advance_field_found': False,
                'payment_field_found': False,
                'all_amount_fields': {},
                'fields_used': {'advance_field': None, 'payment_field': None},
                'error': str(e)
            }

    def determine_qr_type_by_fields(self, field_detection_result: Dict) -> Dict:
        """
        Xác định loại QR dựa trên các trường có giá trị hợp lệ.
        
        Logic ưu tiên: Tạm ứng được ưu tiên trước, sau đó đến thanh toán.
        Chỉ chọn trường có giá trị số hợp lệ và lớn hơn 0.
        
        Args:
            field_detection_result (Dict): Kết quả từ detect_available_amount_fields()
            
        Returns:
            Dict: Kết quả quyết định loại QR bao gồm:
                - qr_type: Loại QR ('advance', 'payment', hoặc 'none')
                - amount: Số tiền đã chọn
                - field_used: Tên trường đã sử dụng
                - reason: Lý do quyết định
        """
        try:
            # Trích xuất thông tin từ kết quả phát hiện trường
            advance_found = field_detection_result.get('advance_field_found', False)
            payment_found = field_detection_result.get('payment_field_found', False)
            advance_amount = field_detection_result.get('advance_amount')
            payment_amount = field_detection_result.get('payment_amount')

            # Lấy tên trường để hiển thị trong kết quả
            fields_used = field_detection_result.get('fields_used', {})
            advance_field_name = fields_used.get('advance_field', FFN.ADVANCE_AMOUNT)
            payment_field_name = fields_used.get('payment_field', FFN.PAYMENT_AMOUNT)

            print(f"🎯 Đang xác định loại QR: tạm_ứng={advance_found}, thanh_toán={payment_found}")
            
            # Logic ưu tiên: Kiểm tra tạm ứng trước
            if advance_found and advance_amount:
                try:
                    amount_value = float(advance_amount)
                    if amount_value > 0:
                        print(f"✅ Chọn tạm ứng: {amount_value:,} VND")
                        return {
                            'qr_type': 'advance',
                            'amount': amount_value,
                            'field_used': advance_field_name,
                            'reason': 'Tìm thấy số tiền tạm ứng hợp lệ'
                        }
                except (ValueError, TypeError):
                    print(f"⚠️ Số tiền tạm ứng không hợp lệ: {advance_amount}")
            
            # Nếu không có tạm ứng, kiểm tra thanh toán
            if payment_found and payment_amount:
                try:
                    amount_value = float(payment_amount)
                    if amount_value > 0:
                        print(f"✅ Chọn thanh toán: {amount_value:,} VND")
                        return {
                            'qr_type': 'payment', 
                            'amount': amount_value,
                            'field_used': payment_field_name,
                            'reason': 'Tìm thấy số tiền thanh toán hợp lệ'
                        }
                except (ValueError, TypeError):
                    print(f"⚠️ Số tiền thanh toán không hợp lệ: {payment_amount}")
            
            # Không tìm thấy trường hợp lệ nào
            print(f"❌ Không tìm thấy số tiền hợp lệ")
            return {
                'qr_type': 'none',
                'amount': None,
                'field_used': None,
                'reason': f'Không tìm thấy số tiền hợp lệ (tạm_ứng={advance_found}, thanh_toán={payment_found})'
            }
            
        except Exception as e:
            print(f"❌ Lỗi khi xác định loại QR: {e}")
            return {
                'qr_type': 'none',
                'amount': None,
                'field_used': None,
                'reason': f'Lỗi: {str(e)}'
            }

    def get_amount_and_type_for_node(self, node_id: str, form_data: List[Dict]) -> Dict:
        """
        Lấy số tiền và loại QR cho một node cụ thể dựa trên chiến lược của node.
        
        Đây là phương thức chính để xử lý node, sẽ:
        1. Lấy cấu hình node từ node_id
        2. Áp dụng chiến lược phù hợp (detect_both_fields hoặc payment_field_only)
        3. Phân tích form data và trả về kết quả
        
        Args:
            node_id (str): ID của node cần xử lý
            form_data (List[Dict]): Dữ liệu form từ Lark API
            
        Returns:
            Dict: Kết quả xử lý bao gồm:
                - success (bool): Xử lý thành công hay không
                - qr_type (str): Loại QR đã xác định
                - amount (float): Số tiền cho QR
                - field_used (str): Trường đã sử dụng
                - node_strategy (str): Chiến lược của node
                - reason (str): Lý do kết quả
                - field_detection (Dict): Chi tiết phát hiện trường
        """
        try:
            # Lấy cấu hình node từ hệ thống
            node_config = get_node_config(node_id)
            if not node_config:
                print(f"❌ Không tìm thấy cấu hình cho node {node_id}")
                return {
                    'success': False,
                    'qr_type': 'none',
                    'error': f'Không tìm thấy node {node_id} trong cấu hình'
                }
            
            # Trích xuất thông tin node
            strategy = node_config['strategy']
            node_name = node_config['name']
            
            print(f"🔍 Đang xử lý node: {node_name} (chiến lược: {strategy})")
            
            # Phát hiện các trường có sẵn trong form
            field_detection = self.detect_available_amount_fields(form_data, node_config)
            
            # Áp dụng chiến lược xử lý theo cấu hình
            if strategy == "detect_both_fields":
                # Chiến lược phát hiện kép: có thể là tạm ứng hoặc thanh toán
                print(f"📋 Áp dụng chiến lược phát hiện kép")
                qr_decision = self.determine_qr_type_by_fields(field_detection)
                
                return {
                    'success': qr_decision['qr_type'] != 'none',
                    'qr_type': qr_decision['qr_type'],
                    'amount': qr_decision['amount'],
                    'field_used': qr_decision['field_used'],
                    'node_strategy': strategy,
                    'reason': f"Kết quả phát hiện kép: {qr_decision['reason']}",
                    'field_detection': field_detection
                }
                
            elif strategy == "payment_field_only":
                # Chiến lược chỉ thanh toán: chỉ kiểm tra trường thanh toán
                print(f"💳 Áp dụng chiến lược chỉ thanh toán")
                payment_amount = field_detection.get('payment_amount')
                payment_found = field_detection.get('payment_field_found', False)
                payment_field_name = node_config.get('payment_field')

                if payment_found and payment_amount:
                    try:
                        amount_value = float(payment_amount)
                        if amount_value > 0:
                            print(f"✅ Tìm thấy số tiền thanh toán hợp lệ: {amount_value:,} VND")
                            return {
                                'success': True,
                                'qr_type': 'payment',
                                'amount': amount_value,
                                'field_used': payment_field_name,
                                'node_strategy': strategy,
                                'reason': 'Chiến lược chỉ thanh toán: tìm thấy số tiền hợp lệ',
                                'field_detection': field_detection
                            }
                    except (ValueError, TypeError):
                        print(f"⚠️ Số tiền thanh toán không hợp lệ: {payment_amount}")
                
                print(f"❌ Không tìm thấy số tiền thanh toán hợp lệ")
                return {
                    'success': False,
                    'qr_type': 'none',
                    'amount': None,
                    'field_used': None,
                    'node_strategy': strategy,
                    'reason': f'Chiến lược chỉ thanh toán: không có số tiền hợp lệ (tìm_thấy={payment_found}, giá_trị={payment_amount})',
                    'field_detection': field_detection
                }
            
            else:
                print(f"❌ Chiến lược không xác định: {strategy}")
                return {
                    'success': False,
                    'qr_type': 'none',
                    'error': f'Chiến lược không xác định: {strategy}'
                }
                
        except Exception as e:
            print(f"❌ Lỗi khi xử lý node {node_id}: {e}")
            return {
                'success': False,
                'qr_type': 'none',
                'error': str(e)
            }
============================================================

============================================================
FILE: app\domains\qr_generation\services\qr_processor.py
============================================================
import json
from app.core.config.settings import settings
# NODE_CONFIG và AmountDetector không còn cần thiết cho logic chính, nhưng giữ lại import để không ảnh hưởng các hàm phụ
from app.core.config.node_config import NODE_CONFIG
from app.core.config.field_constants import FFN
from app.core.infrastructure.lark_service import lark_service
from app.core.infrastructure.cache_service import cache_service
from app.core.utils.field_extractor import FieldExtractor
from app.domains.qr_generation.services.vietqr_service import vietqr_service
# AmountDetector không còn được sử dụng trong hàm chính nữa
# from app.domains.qr_generation.services.amount_detector import AmountDetector
from app.domains.qr_generation.models import QRType, BankInfo

class QRProcessor:
    """
    Bộ xử lý QR chính - Quản lý logic nghiệp vụ tạo và xử lý mã QR cho hệ thống phê duyệt.
    
    Class này xử lý toàn bộ quy trình từ việc kiểm tra node phê duyệt, trích xuất dữ liệu,
    validate thông tin, tạo mã VietQR và upload lên hệ thống Lark.
    
    Attributes:
        field_extractor (FieldExtractor): Bộ trích xuất trường dữ liệu từ form
    """

    def __init__(self):
        """Khởi tạo QRProcessor với các service cần thiết."""
        self.field_extractor = FieldExtractor()
        # self.amount_detector không còn cần thiết nữa
        # self.amount_detector = AmountDetector()

    # --- HÀM CŨ NÀY VẪN GIỮ LẠI NHƯNG KHÔNG ĐƯỢC GỌI TRONG HÀM CHÍNH ---
    def check_pending_allowed_node_in_task_list(self, api_response: dict, node_config: dict = None) -> dict:
        """
        Kiểm tra node có trạng thái phù hợp và đáp ứng các điều kiện bổ sung.
        (Hàm này không còn được sử dụng trong luồng chính tạo QR động)
        """
        if node_config is None:
            node_config = NODE_CONFIG
        # ... logic của hàm cũ giữ nguyên ...
        try:
            # Trích xuất dữ liệu từ API response
            data = api_response.get('data', {})
            task_list = data.get('task_list', [])
            configured_node_ids = list(node_config.keys())
            
            # Tạo map để tra cứu nhanh trạng thái của các node
            node_status_map = {}
            for task in task_list:
                node_id = task.get('node_id')
                status = task.get('status', 'UNKNOWN')
                if node_id:
                    node_status_map[node_id] = status
            
            print(f"🔍 Đang kiểm tra các node với điều kiện bổ sung:")
            for node_id, config in node_config.items():
                required_status = config.get('required_status', 'PENDING')
                additional_conditions = config.get('additional_conditions', [])
                print(f"   • {node_id[:8]}... - {config['name']} (yêu cầu: {required_status})")
                if additional_conditions:
                    for condition in additional_conditions:
                        print(f"     + Điều kiện thêm: {condition['node_id'][:8]}... phải ở trạng thái {condition['required_status']}")
            
            print(f"📋 Danh sách task chứa {len(task_list)} nhiệm vụ")
            
            matching_configured_nodes = []
            
            # Duyệt qua từng node đã cấu hình
            for node_id in configured_node_ids:
                config = node_config[node_id]
                required_status = config.get('required_status', 'PENDING')
                current_status = node_status_map.get(node_id, 'NOT_FOUND')
                
                # Kiểm tra điều kiện chính
                if current_status != required_status:
                    continue
                    
                # Kiểm tra các điều kiện bổ sung
                additional_conditions = config.get('additional_conditions', [])
                all_conditions_met = True
                
                for condition in additional_conditions:
                    condition_node_id = condition['node_id']
                    condition_required_status = condition['required_status']
                    condition_current_status = node_status_map.get(condition_node_id, 'NOT_FOUND')
                    
                    print(f"🔍 Kiểm tra điều kiện bổ sung: {condition_node_id[:8]}... ")
                    print(f"   Yêu cầu: {condition_required_status}, Hiện tại: {condition_current_status}")
                    
                    if condition_current_status != condition_required_status:
                        all_conditions_met = False
                        print(f"❌ Điều kiện bổ sung không đáp ứng cho {node_id[:8]}...")
                        break
                    else:
                        print(f"✅ Điều kiện bổ sung đã đáp ứng")
                
                # Nếu tất cả điều kiện đều thỏa mãn
                if all_conditions_met:
                    matching_configured_nodes.append({
                        'node_id': node_id,
                        'config': config,
                        'strategy': config['strategy'],
                        'matched_status': current_status,
                        'required_status': required_status,
                        'additional_conditions_met': True
                    })
                    print(f"✅ Tìm thấy node phù hợp: {node_id[:8]}... ({config['name']}) - Trạng thái: {current_status}")
            
            # Trả về node phù hợp đầu tiên
            if matching_configured_nodes:
                first_matching = matching_configured_nodes[0]
                return {
                    'found': True,
                    'node_id': first_matching['node_id'],
                    'node_config': first_matching['config'],
                    'strategy': first_matching['strategy'],
                    'matched_status': first_matching['matched_status'],
                    'required_status': first_matching['required_status'],
                    'all_tasks': task_list,
                    'all_matching_configured': matching_configured_nodes,
                    'node_status_map': node_status_map
                }
            else:
                print(f"❌ Không tìm thấy node nào đáp ứng tất cả điều kiện")
                return {
                    'found': False,
                    'node_id': None,
                    'node_config': None,
                    'strategy': None,
                    'matched_status': None,
                    'all_tasks': task_list,
                    'all_matching_configured': [],
                    'node_status_map': node_status_map
                }
            
        except Exception as e:
            print(f"❌ Lỗi khi kiểm tra node: {e}")
            return {
                'found': False,
                'error': str(e),
                'all_tasks': [],
                'all_matching_configured': []
            }


    def validate_amount_value(self, amount_value) -> dict:
        """
        Validate và chuyển đổi giá trị số tiền.
        """
        try:
            if amount_value is None:
                return {'valid': False, 'amount': None, 'error': 'Số tiền không được để trống'}
            
            amount_float = float(amount_value)
            amount_int = int(amount_float)
            
            if amount_int <= 0:
                return {'valid': False, 'amount': amount_int, 'error': 'Số tiền phải lớn hơn 0'}
                
            return {'valid': True, 'amount': amount_int, 'error': None}
            
        except (ValueError, TypeError) as e:
            return {'valid': False, 'amount': None, 'error': f'Định dạng số tiền không hợp lệ: {str(e)}'}

    async def process_approval_with_qr_comment(self, instance_code: str, access_token: str) -> bool:
        """
        Xử lý phê duyệt với tạo QR code và comment (phiên bản nâng cấp hỗ trợ nhiều lần tạm ứng).
        """
        try:
            # Bước 1: Lấy thông tin chi tiết của instance
            api_response = await lark_service.get_approval_instance(instance_code, access_token)
            if not api_response or 'data' not in api_response:
                print(f"❌ Không thể lấy thông tin instance {instance_code}")
                return False
            
            task_list = api_response['data'].get('task_list', [])
            form_str = api_response['data'].get('form', '[]')
            form_data = json.loads(form_str)

            # --- [LOGIC MỚI] Bắt đầu phần tìm kiếm lần tạm ứng hoạt động ---
            
            # 2.1: Tìm tất cả các node "Thủ quỹ chi tiền tạm ứng" trong quy trình
            cashier_nodes = [task for task in task_list if "Thủ quỹ chi tiền tạm ứng" in task.get('node_name', '')]
            print(f"🔍 Tìm thấy {len(cashier_nodes)} node 'Thủ quỹ chi tiền tạm ứng' trong quy trình.")

            active_advance_info = None
            
            # 2.2: Lặp qua các node thủ quỹ để tìm node đang PENDING
            for i, node in enumerate(cashier_nodes, 1):
                node_id = node.get('node_id')
                node_status = node.get('status')
                print(f"   - Kiểm tra lần tạm ứng {i} (Node ID: {node_id[:8]}..., Trạng thái: {node_status})...")

                # Điều kiện 1: Node phải ở trạng thái PENDING
                if node_status == 'PENDING':
                    # Điều kiện 2: Người dùng phải chọn "Yes" cho lần tạm ứng tương ứng
                    yes_no_field_name = f"Thanh toán tạm ứng lần {i}: Y/N"
                    amount_field_name = f"Số tiền tạm ứng lần {i}:"

                    yes_no_value = self.field_extractor.extract_field_value(form_data, yes_no_field_name)
                    
                    if yes_no_value == "Yes":
                        print(f"     ✅ Điều kiện thỏa mãn: Node PENDING và người dùng chọn 'Yes'.")
                        amount_value = self.field_extractor.extract_field_value(form_data, amount_field_name)
                        
                        active_advance_info = {
                            "amount": amount_value,
                            "node_id": node_id,
                            "node_name": node.get('node_name'),
                            "qr_type": "advance",
                            "field_used": amount_field_name,
                            "advance_round": i
                        }
                        print(f"     ➡️ Lần tạm ứng {i} được kích hoạt với số tiền: {amount_value}")
                        break # Tìm thấy rồi thì dừng lại
                    else:
                        print(f"     - Bỏ qua: Người dùng không chọn 'Yes' cho lần {i} (Giá trị: {yes_no_value}).")
                else:
                    print(f"     - Bỏ qua: Trạng thái node không phải PENDING.")

            # 2.3: Xử lý kết quả tìm kiếm
            if not active_advance_info:
                print(f"⏭️  Không có lần tạm ứng nào đang hoạt động (PENDING và được chọn 'Yes'). Bỏ qua tạo QR.")
                return True # Coi như thành công vì đã xử lý đúng (bỏ qua)

            # --- [LOGIC MỚI] Kết thúc phần tìm kiếm ---


            # --- [PHẦN GIỮ NGUYÊN] Tiếp tục xử lý với thông tin đã tìm được ---

            # Lấy các biến từ kết quả tìm kiếm
            matching_node_id = active_advance_info['node_id']
            qr_type = active_advance_info['qr_type']
            amount_value = active_advance_info['amount']
            field_used = active_advance_info['field_used']
            node_name = active_advance_info['node_name']
            
            # Bước 5: Kiểm tra duplicate TRƯỚC KHI tạo QR
            if cache_service.is_qr_recently_generated(
                instance_code, matching_node_id, qr_type, 
                settings.QR_CACHE_DURATION_MINUTES
            ):
                print(f"⚠️ PHÁT HIỆN TRÙNG LẶP: QR {qr_type.upper()} cho node {node_name} đã được tạo gần đây.")
                print(f"   → BỎ QUA tạo QR để tránh trùng lặp.")
                return True
            
            print(f"💰 Chi tiết tạo QR cho lần tạm ứng {active_advance_info['advance_round']}:")
            print(f"   - Loại: {qr_type}")
            print(f"   - Số tiền: {amount_value}")
            print(f"   - Trường sử dụng: {field_used}")
            print(f"   - Node kích hoạt: {node_name} ({matching_node_id[:8]}...)")
            
            # Bước 6: Validate số tiền
            amount_validation = self.validate_amount_value(amount_value)
            if not amount_validation['valid']:
                print(f"❌ Số tiền không hợp lệ: {amount_validation['error']}")
                return False
                
            amount_int = amount_validation['amount']

            # Bước 7: Trích xuất thông tin ngân hàng
            bank_id = self.field_extractor.extract_field_value(form_data, FFN.BANK_NAME)
            account_no = self.field_extractor.extract_field_value(form_data, FFN.BANK_ACCOUNT_NUMBER)
            account_name = self.field_extractor.extract_field_value(form_data, FFN.BENEFICIARY_NAME)

            if not all([bank_id, account_no, account_name]):
                missing = [f for f, v in {FFN.BANK_NAME: bank_id, FFN.BANK_ACCOUNT_NUMBER: account_no, FFN.BENEFICIARY_NAME: account_name}.items() if not v]
                print(f"❌ Thiếu thông tin ngân hàng: {', '.join(missing)}")
                return False
            
            # Bước 8: Tạo mô tả QR theo loại
            description = vietqr_service.generate_qr_description(f"{qr_type}{active_advance_info['advance_round']}", instance_code)
            
            print(f"🏦 Tạo VietQR với thông tin:")
            print(f"   - Ngân hàng: {bank_id}")
            print(f"   - Số tài khoản: {account_no}")
            print(f"   - Tên người nhận: {account_name}")
            print(f"   - Số tiền: {amount_int:,} VND")
            print(f"   - Mô tả: {description}")
            
            # Bước 9: Tạo VietQR code trong bộ nhớ
            qr_image_buffer = vietqr_service.create_qr_in_memory(
                bank_id=bank_id,
                account_no=account_no,
                amount=amount_int,
                description=description,
                account_name=account_name
            )
            
            if not qr_image_buffer:
                print("❌ Không thể tạo mã VietQR")
                return False
            
            # Bước 10: Upload ảnh lên Lark Approval
            filename = f"{instance_code}_{qr_type}{active_advance_info['advance_round']}_qr.png"
            upload_result = await lark_service.upload_image_to_approval(qr_image_buffer, filename, access_token)
            
            if not upload_result['success']:
                print(f"❌ Upload thất bại: {upload_result['error']}")
                return False
            
            # Bước 11: Đánh dấu đã tạo QR SAU KHI upload thành công
            cache_service.mark_qr_as_generated(instance_code, matching_node_id, qr_type)
            
            # Bước 12: Tạo comment nâng cao với thông tin chi tiết
            comment_result = await lark_service.create_enhanced_comment_with_image(
                instance_code=instance_code,
                file_url=upload_result['file_url'],
                file_code=upload_result['file_code'],
                filename=filename,
                qr_type=f"{qr_type} Lần {active_advance_info['advance_round']}", # Làm rõ hơn trong comment
                amount=amount_int,
                node_name=node_name,
                access_token=access_token
            )
            
            if comment_result['success']:
                print(f"✅ Hoàn thành xử lý phê duyệt {instance_code}")
                print(f"💰 Loại: {qr_type.upper()} LẦN {active_advance_info['advance_round']} | Số tiền: {amount_int:,} VND")
                print(f"🏷️ Node: {node_name}")
                print(f"📋 Trường: {field_used}")
                print(f"💬 ID Comment: {comment_result['comment_id']}")
                return True
            else:
                print(f"❌ Tạo comment thất bại: {comment_result['error']}")
                return False
                
        except Exception as e:
            print(f"❌ Lỗi xử lý phê duyệt: {e}")
            import traceback
            traceback.print_exc()
            return False

qr_processor = QRProcessor()
============================================================

============================================================
FILE: app\domains\qr_generation\services\vietqr_service.py
============================================================
import requests
from urllib.parse import quote
from PIL import Image
from io import BytesIO
from app.core.config.settings import settings
from app.domains.qr_generation.models import QRType


class VietQRService:
    """
    Dịch vụ tạo mã QR thanh toán VietQR.
    
    Class này cung cấp các chức năng để tạo mã QR VietQR thông qua API,
    xử lý hình ảnh và tạo mô tả phù hợp cho từng loại giao dịch.
    
    VietQR là hệ thống thanh toán QR code chuẩn của Việt Nam, cho phép
    tạo mã QR chứa thông tin ngân hàng, số tiền và nội dung chuyển khoản.
    
    Attributes:
        base_url (str): URL cơ sở của VietQR API từ settings
    """

    def __init__(self):
        """Khởi tạo VietQRService với URL API từ cấu hình."""
        self.base_url = settings.VIETQR_BASE_URL
    
    def create_qr_in_memory(self, bank_id: str, account_no: str, amount: int, 
                           description: str, account_name: str, 
                           template: str = None) -> BytesIO:
        """
        Tạo mã QR VietQR với thông tin thanh toán và trả về dữ liệu ảnh trong bộ nhớ.
        
        Phương thức này sẽ:
        1. Tạo URL request đến VietQR API với các tham số đã mã hóa
        2. Gửi HTTP request để lấy hình ảnh QR
        3. Xử lý hình ảnh bằng PIL (chuyển đổi format nếu cần)
        4. Trả về BytesIO object chứa dữ liệu PNG
        
        Args:
            bank_id (str): Mã ngân hàng (ví dụ: 970422 cho MB Bank)
            account_no (str): Số tài khoản thụ hưởng
            amount (int): Số tiền giao dịch (đơn vị: VND)
            description (str): Nội dung chuyển khoản (sẽ được mã hóa URL)
            account_name (str): Tên chủ tài khoản (sẽ được mã hóa URL)
            template (str, optional): Template QR. Defaults to settings.VIETQR_TEMPLATE
        
        Returns:
            BytesIO: Dữ liệu ảnh QR dạng PNG trong bộ nhớ, hoặc None nếu có lỗi
            
        Raises:
            requests.exceptions.RequestException: Lỗi khi gọi API
            PIL.UnidentifiedImageError: Lỗi khi xử lý hình ảnh
        """
        # Sử dụng template mặc định nếu không được chỉ định
        if template is None:
            template = settings.VIETQR_TEMPLATE
        
        # Mã hóa URL cho các tham số tiếng Việt để tránh lỗi encoding
        encoded_desc = quote(description)
        encoded_name = quote(account_name)
        
        # Tạo URL request theo format của VietQR API
        url = (f"{self.base_url}/{bank_id}-{account_no}-{template}.jpg?"
               f"amount={amount}&addInfo={encoded_desc}&accountName={encoded_name}")
        
        print(f"🌐 URL VietQR: {url}")
        
        try:
            # Gửi HTTP GET request với timeout để tránh treo
            print(f"📡 Đang gửi yêu cầu tạo QR đến VietQR API...")
            response = requests.get(url, timeout=10)
            response.raise_for_status()  # Raise exception nếu HTTP status code không thành công
            
            print(f"✅ Nhận được dữ liệu QR từ API ({len(response.content)} bytes)")
            
            # Mở và xử lý hình ảnh từ response content
            image = Image.open(BytesIO(response.content))
            print(f"🖼️ Đã tải ảnh QR - Kích thước: {image.size}, Mode: {image.mode}")
            
            # Chuyển đổi sang RGB nếu ảnh có mode không tương thích với PNG
            # RGBA (có alpha channel), LA (grayscale + alpha), P (palette mode)
            if image.mode in ('RGBA', 'LA', 'P'):
                print(f"🔄 Chuyển đổi ảnh từ mode {image.mode} sang RGB")
                image = image.convert('RGB')
            
            # Tạo BytesIO buffer để lưu ảnh PNG
            img_buffer = BytesIO()
            image.save(img_buffer, format='PNG')
            img_buffer.seek(0)  # Reset con trở về đầu buffer để đọc từ đầu
            
            print(f"✅ Tạo mã VietQR thành công trong bộ nhớ")
            print(f"📦 Kích thước buffer: {img_buffer.getbuffer().nbytes} bytes")
            return img_buffer
            
        except requests.exceptions.Timeout:
            print(f"⏰ Timeout khi gọi VietQR API (quá 10 giây)")
            return None
        except requests.exceptions.ConnectionError:
            print(f"🔌 Lỗi kết nối đến VietQR API")
            return None
        except requests.exceptions.HTTPError as e:
            print(f"🚫 Lỗi HTTP từ VietQR API: {e}")
            print(f"    Status code: {response.status_code}")
            return None
        except requests.exceptions.RequestException as e:
            print(f"❌ Lỗi request khi gọi VietQR API: {e}")
            return None
        except Exception as e:
            print(f"❌ Lỗi không xác định khi xử lý VietQR: {e}")
            return None

    def generate_qr_description(self, qr_type: str, instance_code: str) -> str:
        """
        Tạo mô tả (nội dung chuyển khoản) cho mã QR dựa trên loại giao dịch.
        
        Mô tả sẽ được hiển thị trong nội dung chuyển khoản của ngân hàng,
        giúp người nhận dễ dàng nhận biết mục đích giao dịch.
        
        Args:
            qr_type (str): Loại QR code ('advance', 'payment', hoặc giá trị khác)
            instance_code (str): Mã đơn phê duyệt để tham chiếu
            
        Returns:
            str: Nội dung mô tả cho QR code
            
        Examples:
            >>> generate_qr_description('advance', 'AP123456')
            'Tam ung don AP123456'
            
            >>> generate_qr_description('payment', 'AP123456') 
            'Thanh toan don AP123456'
            
            >>> generate_qr_description('other', 'AP123456')
            'Don AP123456'
        """
        # Xác định mô tả dựa trên loại QR
        if qr_type == 'advance':
            description = f"Tam ung don {instance_code}"
            print(f"📝 Tạo mô tả QR tạm ứng: {description}")
        elif qr_type == 'payment':
            description = f"Thanh toan don {instance_code}"
            print(f"📝 Tạo mô tả QR thanh toán: {description}")
        else:
            # Fallback cho các loại khác
            description = f"Don {instance_code}"
            print(f"📝 Tạo mô tả QR chung: {description}")
            
        return description

vietqr_service = VietQRService()
============================================================

============================================================
FILE: app\domains\validation\__init__.py
============================================================
# app/domains/validation/__init__.py
from .models import *
from .services import *
from .handlers import *

__all__ = [
    # Models
    "ValidationType", "ValidationResult", "ValidationResponse",
    # Services
    "validation_service",
    # Handlers  
    "validation_event_handler"
]

============================================================

============================================================
FILE: app\domains\validation\handlers\__init__.py
============================================================
from .validation_event_handler import validation_event_handler

__all__ = ["validation_event_handler"]

============================================================

============================================================
FILE: app\domains\validation\handlers\validation_event_handler.py
============================================================
"""
Validation Event Handler - Bộ xử lý sự kiện validation cho hệ thống phê duyệt
"""
from typing import Dict, List, Optional
import json
from app.domains.validation.services import validation_service
from app.core.infrastructure import lark_service
from app.domains.notification.services import lark_webhook_service
from app.core.infrastructure import cache_service

class ValidationEventHandler:
    """
    Bộ xử lý sự kiện validation cho hệ thống phê duyệt.
    
    Class này chịu trách nhiệm:
    1. Nhận và xử lý các sự kiện phê duyệt để validation
    2. Chạy các quy tắc validation trên dữ liệu form và workflow
    3. Gửi cảnh báo qua webhook khi phát hiện vấn đề
    4. Ngăn chặn duplicate alerts để tránh spam notification
    5. Xử lý lỗi và gửi error alerts khi cần thiết
    
    Attributes:
        name (str): Tên định danh của service
        webhook_service: Service gửi webhook notifications
    """
    
    def __init__(self):
        """Khởi tạo ValidationEventHandler với webhook service."""
        self.name = "Validation_Service"
        self.webhook_service = lark_webhook_service

    async def handle_approval_event(self, event_data: Dict) -> Dict:
        """
        Xử lý sự kiện phê duyệt để thực hiện validation với cơ chế anti-spam nâng cao.

        [NÂNG CẤP] Bổ sung logic kiểm tra trạng thái đơn. Sẽ bỏ qua xử lý
        nếu đơn ở trạng thái cuối cùng như REJECTED, CANCELED, DELETED.
        
        Quy trình xử lý mới:
        1. Lấy dữ liệu instance từ Lark.
        2. Chạy tất cả các validation rules.
        3. Lọc ra các kết quả không hợp lệ (invalid).
        4. **[LOGIC MỚI]** Lặp qua từng lỗi không hợp lệ:
            a. Dùng `validation_type` cụ thể của lỗi để kiểm tra cache.
            b. Nếu lỗi chưa được cache, thêm nó vào danh sách cần gửi cảnh báo.
        5. Nếu có lỗi cần cảnh báo, gửi một webhook duy nhất chứa tất cả các lỗi mới.
        6. **[LOGIC MỚI]** Sau khi gửi, ghi cache cho từng loại lỗi đã được cảnh báo.
        """
        instance_code = event_data.get('instance_code')
        if not instance_code:
            return {"success": False, "message": "Không tìm thấy instance_code", "service": self.name}

        try:
            # [THÊM MỚI] Bắt đầu khối logic kiểm tra trạng thái
            FINAL_STATUSES = ['REJECTED', 'CANCELED', 'DELETED']

            # Trích xuất trạng thái từ dữ liệu gốc của sự kiện để tránh gọi API không cần thiết
            raw_data = event_data.get('raw_data', {})
            instance_status = raw_data.get('event', {}).get('object', {}).get('status')

            # Nếu không có trong payload, thì tìm trong event body
            event_body = raw_data.get('event', {})
            if not instance_status:
                instance_status = event_body.get('status')


            # Kiểm tra xem trạng thái của đơn có nằm trong danh sách cần bỏ qua không
            if instance_status and instance_status in FINAL_STATUSES:
                print(f"⏭️ [Validation Handler] Bỏ qua instance {instance_code} do có trạng thái cuối cùng: {instance_status}")
                return {
                    "success": True, # Coi như thành công vì đã xử lý đúng (bỏ qua)
                    "message": f"Bỏ qua validation do trạng thái đơn là {instance_status}",
                    "instance_code": instance_code,
                    "webhook_sent": False, # Không có webhook nào được gửi
                    "service": self.name
                }
            # [THÊM MỚI] Kết thúc khối logic kiểm tra trạng thái

            print(f"🔍 [Validation Handler] Dịch vụ Validation đang xử lý: {instance_code} (Trạng thái: {instance_status or 'N/A'})")
            
            # Bước 1 & 2: Lấy dữ liệu từ Lark
            access_token = await lark_service.get_access_token()
            if not access_token:
                return {"success": False, "message": "Không thể lấy access token", "service": self.name}

            api_response = await lark_service.get_approval_instance(instance_code, access_token)
            if not api_response or 'data' not in api_response:
                return {"success": False, "message": "Không thể lấy dữ liệu instance", "service": self.name}
            
            serial_number = api_response.get('data', {}).get('serial_number')
            form_data = json.loads(api_response['data'].get('form', '[]'))
            task_list = api_response['data'].get('task_list', [])
            
            # Bước 3: Chạy validations và lọc ra các lỗi
            validation_results = validation_service.run_all_validations(
                form_data, task_list, "dummy_node_id" # node_id có thể cần được truyền vào từ event_data nếu logic yêu cầu
            )
            invalid_results = [r for r in validation_results if not r.is_valid]
            
            if not invalid_results:
                print("✅ [Validation Handler] Tất cả validation đều thành công.")
                return {
                    "success": True, "message": "Tất cả validation đều thành công",
                    "webhook_sent": False, "webhook_skipped_count": 0,
                    "service": self.name
                }
            
            # --- PHẦN LOGIC ANTI-SPAM ĐƯỢC THAY THẾ HOÀN TOÀN ---
            # Bước 4: Lọc ra các cảnh báo chưa được gửi (chưa có trong cache)
            alerts_to_send = []
            skipped_count = 0
            
            print(f"⚠️ [Validation Handler] Phát hiện {len(invalid_results)} vấn đề. Đang kiểm tra cache anti-spam...")
            for result in invalid_results:
                # TẠO CACHE KEY CỤ THỂ CHO TỪNG LỖI
                # Dùng hash của message để đảm bảo mỗi lỗi là duy nhất
                specific_error_key = f"{result.validation_type.value}_{hash(result.message)}"
                
                if cache_service.is_validation_alert_recently_sent(
                    instance_code, specific_error_key, cache_duration_minutes=10
                ):
                    print(f"  🔄 Bỏ qua (đã cache): {result.message[:80]}...") # Log một phần message
                    skipped_count += 1
                else:
                    print(f"  🆕 Cần gửi cảnh báo cho: {result.message[:80]}...")
                    alerts_to_send.append(result)

            # Bước 5: Gửi webhook nếu có cảnh báo mới cần gửi
            webhook_sent = False
            if alerts_to_send:
                error_messages = [r.message for r in alerts_to_send]
                print(f"📨 [Validation Handler] Đang gửi {len(error_messages)} cảnh báo mới qua webhook...")
                
                webhook_sent = await self._send_validation_alert(instance_code, error_messages, serial_number)
                
                # Bước 6: Nếu gửi thành công, ghi cache cho từng lỗi đã gửi
                if webhook_sent:
                    print("✅ [Validation Handler] Gửi webhook thành công. Đang cập nhật cache...")
                    for result in alerts_to_send:
                        # DÙNG LẠI CACHE KEY CỤ THỂ ĐÃ TẠO Ở TRÊN
                        specific_error_key = f"{result.validation_type.value}_{hash(result.message)}"
                        cache_service.mark_validation_alert_as_sent(instance_code, specific_error_key)
                        print(f"  🔒 Đã cache cho: {result.message[:80]}...")
                else:
                    print("❌ [Validation Handler] Gửi webhook thất bại.")
            else:
                print("✅ [Validation Handler] Không có cảnh báo mới nào cần gửi. Tất cả đã được cache.")

            return {
                "success": True,
                "message": f"Hoàn thành validation. {len(alerts_to_send)} cảnh báo mới đã được gửi. {skipped_count} cảnh báo bị bỏ qua do cache.",
                "alerts_sent_count": len(alerts_to_send),
                "webhook_sent": webhook_sent,
                "webhook_skipped_count": skipped_count,
                "validation_details": [r.dict() for r in validation_results],
                "service": self.name
            }
            
        except Exception as e:
            # Xử lý lỗi hệ thống (giữ nguyên logic cũ)
            print(f"❌ [Validation Handler] Lỗi nghiêm trọng trong Validation Service: {str(e)}")
            # ... (phần xử lý lỗi này có thể giữ nguyên hoặc cải tiến sau)
            return {
                "success": False,
                "message": f"Lỗi Validation Service: {str(e)}",
                "service": self.name
            }

    async def _send_validation_alert(self, instance_code: str, error_messages: List[str], serial_number: Optional[str]) -> bool:
        """Gửi cảnh báo validation qua webhook service."""
        try:
            from app.domains.notification.models import ValidationAlertRequest, NotificationPriority
            request = ValidationAlertRequest(
                instance_code=instance_code,
                serial_number=serial_number,
                validation_errors=error_messages,
                priority=NotificationPriority.HIGH
            )
            result = await self.webhook_service.send_validation_alert(request)
            return result.success
        except Exception as e:
            print(f"❌ Lỗi khi gửi validation alert: {e}")
            return False

    async def _send_error_alert(self, instance_code: str, error_message: str) -> bool:
        """Gửi cảnh báo lỗi hệ thống qua webhook service."""
        try:
            # Logic này hiện không được dùng trong luồng chính nhưng giữ lại để có thể dùng sau
            result = await self.webhook_service.send_custom_alert(
                title="LỖI VALIDATION SERVICE",
                message=f"Lỗi xử lý validation cho {instance_code}: {error_message}",
                instance_code=instance_code
            )
            return result.success
        except Exception as e:
            print(f"❌ Lỗi khi gửi error alert: {e}")
            return False


validation_event_handler = ValidationEventHandler()
============================================================

============================================================
FILE: app\domains\validation\models\__init__.py
============================================================
from .validation import (
    ValidationType,
    ValidationStatus,
    ValidationResult,
    ValidationRequest,
    ValidationResponse
)

__all__ = [
    "ValidationType",
    "ValidationStatus", 
    "ValidationResult",
    "ValidationRequest",
    "ValidationResponse"
]

============================================================

============================================================
FILE: app\domains\validation\models\validation.py
============================================================
from pydantic import BaseModel
from typing import Optional, Dict, Any, List
from enum import Enum


class ValidationType(str, Enum):
    AMOUNT_SUM = "amount_sum_validation"

    ADVANCE_AMOUNT_MISMATCH = "advance_amount_mismatch"      # Tạm ứng
    PAYMENT_AMOUNT_MISMATCH = "payment_amount_mismatch"      # Thanh toán  
    TOTAL_AMOUNT_MISMATCH = "total_amount_mismatch"          # Tổng amount
    
    WORKFLOW_STATUS = "workflow_status_validation" 
    FIELD_CONSISTENCY = "field_consistency_validation"
    PAYMENT_CONSISTENCY = "payment_consistency_validation"
    TOTAL_PAYMENT_VALIDATION = "total_payment_validation"


class ValidationStatus(str, Enum):
    VALID = "valid"
    INVALID = "invalid"
    SKIPPED = "skipped"
    ERROR = "error"


class ValidationResult(BaseModel):
    """Enhanced validation result model with proper enums"""
    is_valid: bool
    validation_type: ValidationType
    status: ValidationStatus
    message: str
    details: Optional[Dict[str, Any]] = None
    
    @classmethod
    def create_valid(cls, validation_type: ValidationType, message: str, details: Dict = None):
        return cls(
            is_valid=True,
            validation_type=validation_type,
            status=ValidationStatus.VALID,
            message=message,
            details=details or {}
        )
    
    @classmethod
    def create_invalid(cls, validation_type: ValidationType, message: str, details: Dict = None):
        return cls(
            is_valid=False,
            validation_type=validation_type,
            status=ValidationStatus.INVALID,
            message=message,
            details=details or {}
        )
    
    @classmethod
    def create_skipped(cls, validation_type: ValidationType, message: str, details: Dict = None):
        return cls(
            is_valid=True,  # Skipped is not a failure
            validation_type=validation_type,
            status=ValidationStatus.SKIPPED,
            message=message,
            details=details or {}
        )
    
    @classmethod
    def create_error(cls, validation_type: ValidationType, message: str, details: Dict = None):
        return cls(
            is_valid=False,
            validation_type=validation_type,
            status=ValidationStatus.ERROR,
            message=message,
            details=details or {}
        )


class ValidationRequest(BaseModel):
    instance_code: str
    form_data: List[Dict[str, Any]]
    task_list: List[Dict[str, Any]]
    node_id: Optional[str] = None


class ValidationResponse(BaseModel):
    success: bool
    instance_code: str
    validation_results: List[ValidationResult]
    invalid_count: int
    total_validations: int
    alerts_sent: bool = False
    webhook_sent: bool = False
    message: Optional[str] = None
============================================================

============================================================
FILE: app\domains\validation\routers\notification.py
============================================================
from fastapi import APIRouter
from app.domains.notification.models import NotificationRequest, NotificationResult
from app.domains.notification.services.notification_coordinator import notification_coordinator

router = APIRouter(prefix="/notification", tags=["Notification"])

@router.post("/send", response_model=NotificationResult)
async def send_notification(request: NotificationRequest):
    """Manual gửi notification"""
    return await notification_coordinator.send_notification(request)

@router.get("/channels")
async def get_notification_channels():
    """Xem danh sách notification channels"""
    from app.domains.notification.models import NotificationChannel, NotificationType
    return {
        "channels": [ch.value for ch in NotificationChannel],
        "types": [nt.value for nt in NotificationType],
        "supported_combinations": {
            "lark_webhook": ["validation_alert", "custom_alert", "service_error"]
        }
    }

@router.get("/cache/status")
async def get_notification_cache_status():
    """Xem trạng thái notification cache"""
    from app.core.infrastructure.cache_service import cache_service
    cache_status = cache_service.get_cache_status()
    return cache_status.get('validation_cache', {})

============================================================

============================================================
FILE: app\domains\validation\routers\validation.py
============================================================
from fastapi import APIRouter
from app.domains.validation.models import ValidationRequest, ValidationResponse
from app.domains.validation.services.validation_service import validation_service

router = APIRouter(prefix="/validation", tags=["Validation"])

@router.post("/validate", response_model=ValidationResponse)
async def validate_instance(request: ValidationRequest):
    """Manual validation của một instance"""
    try:
        # Chạy validations
        validation_results = validation_service.run_all_validations(
            request.form_data, 
            request.task_list, 
            request.node_id or "manual_validation"
        )
        
        invalid_count = len([r for r in validation_results if not r.is_valid])
        
        return ValidationResponse(
            success=True,
            instance_code=request.instance_code,
            validation_results=validation_results,
            invalid_count=invalid_count,
            total_validations=len(validation_results),
            message=f"Completed {len(validation_results)} validations, {invalid_count} issues found"
        )
        
    except Exception as e:
        return ValidationResponse(
            success=False,
            instance_code=request.instance_code,
            validation_results=[],
            invalid_count=0,
            total_validations=0,
            message=f"Validation error: {str(e)}"
        )

@router.get("/rules")
async def get_validation_rules():
    """Xem danh sách validation rules"""
    from app.domains.validation.models import ValidationType
    return {
        "available_rules": [vt.value for vt in ValidationType],
        "total_rules": len(ValidationType)
    }

============================================================

============================================================
FILE: app\domains\validation\services\__init__.py
============================================================
# app/domains/validation/services/__init__.py
from .validation_service import validation_service

__all__ = ["validation_service"]

============================================================

============================================================
FILE: app\domains\validation\services\validation_service.py
============================================================
"""
Validation Service - Dịch vụ domain cho các quy tắc validation
"""
from typing import Dict, List, Any, Optional
from app.domains.validation.models import ValidationResult, ValidationType, ValidationStatus
from app.core.utils.field_extractor import FieldExtractor
from app.core.config.field_constants import FFN

class ValidationService:
    """
    Dịch vụ validation cho hệ thống phê duyệt.
    
    Class này cung cấp các quy tắc validation khác nhau để kiểm tra
    tính nhất quán và hợp lệ của dữ liệu trong quy trình phê duyệt:
    
    - ADVANCE_AMOUNT_MISMATCH: So sánh tổng số tiền tạm ứng
    - PAYMENT_AMOUNT_MISMATCH: So sánh số tiền thanh toán
    - TOTAL_AMOUNT_MISMATCH: Kiểm tra tổng số tiền thanh toán
    - WORKFLOW_STATUS: Kiểm tra trạng thái node
    - FIELD_CONSISTENCY: Kiểm tra logic giữa các trường
    
    Mỗi validation sẽ trả về ValidationResult với một trong các trạng thái:
    - VALID: Validation pass
    - INVALID: Validation fail  
    - SKIPPED: Bỏ qua do thiếu dữ liệu
    - ERROR: Có lỗi trong quá trình validation
    
    Attributes:
        field_extractor (FieldExtractor): Công cụ trích xuất dữ liệu từ form
        validation_rules (Dict): Map từ validation type đến method tương ứng
    """
    
    def __init__(self):
        """Khởi tạo ValidationService với field extractor và mapping rules."""
        self.field_extractor = FieldExtractor()
        
        self.validation_rules = {
            ValidationType.ADVANCE_AMOUNT_MISMATCH: self.validate_advance_amount_mismatch,
            ValidationType.PAYMENT_AMOUNT_MISMATCH: self.validate_payment_amount_mismatch,
            #ValidationType.TOTAL_AMOUNT_MISMATCH: self.validate_total_amount_mismatch,
            ValidationType.WORKFLOW_STATUS: self.validate_workflow_status,
            ValidationType.FIELD_CONSISTENCY: self.validate_field_consistency,
        }
    
    # Thay vì trả về ValidationResult, giờ đây hàm sẽ trả về List[ValidationResult]
    def validate_advance_amount_mismatch(self, form_data: List[Dict], **kwargs) -> List[ValidationResult]:
        """
        Trả về một danh sách các ValidationResult, mỗi result cho một lỗi.
        """
        try:
            accountant_expenditures = self.field_extractor.extract_all_values_from_fieldlist(
                form_data, FFN.ACCOUNTING_ADVANCE_INFO, FFN.EXPENDITURE_AMOUNT
            )
            
            results = []
            found_data = False

            for i in range(1, 5): # Chỉ kiểm tra 4 lần
                user_advance_field = f"Số tiền tạm ứng lần {i}:"
                user_advance_value = self.field_extractor.extract_field_value(form_data, user_advance_field)
                
                if user_advance_value is not None:
                    found_data = True

                if (i - 1) >= len(accountant_expenditures) or user_advance_value is None:
                    continue
                
                accountant_expenditure_value = accountant_expenditures[i-1]
                
                try:
                    user_amount = float(user_advance_value)
                    accountant_amount = float(accountant_expenditure_value)
                    
                    if abs(user_amount - accountant_amount) >= 0.01:
                        message = (f"❌ Lỗi Tạm ứng Lần {i}: Yêu cầu ({user_amount:,.0f}) ≠ Kế toán chi ({accountant_amount:,.0f}). "
                                f"Lệch: {abs(user_amount - accountant_amount):,.0f} VND")
                        # Tạo một result riêng cho lỗi này
                        results.append(ValidationResult.create_invalid(ValidationType.ADVANCE_AMOUNT_MISMATCH, message))
                except (ValueError, TypeError):
                    message = f"❌ Lỗi định dạng số Tạm ứng Lần {i}."
                    results.append(ValidationResult.create_invalid(ValidationType.ADVANCE_AMOUNT_MISMATCH, message))

            # Nếu không có lỗi nào được tìm thấy và có dữ liệu để kiểm tra
            if not results and found_data:
                results.append(ValidationResult.create_valid(
                    ValidationType.ADVANCE_AMOUNT_MISMATCH,
                    "✅ Tất cả các lần tạm ứng đã khớp."
                ))
            
            # Nếu không có dữ liệu để kiểm tra
            if not found_data:
                results.append(ValidationResult.create_skipped(
                    ValidationType.ADVANCE_AMOUNT_MISMATCH,
                    "ℹ️ Bỏ qua: Không tìm thấy dữ liệu tạm ứng để so sánh."
                ))
            
            return results
                
        except Exception as e:
            return [ValidationResult.create_error(
                ValidationType.ADVANCE_AMOUNT_MISMATCH,
                f"❌ Lỗi hệ thống khi validation tiền tạm ứng: {e}",
            )]

    def validate_payment_amount_mismatch(self, form_data: List[Dict], **kwargs) -> ValidationResult:
        """
        Validation tính nhất quán số tiền thanh toán (giữ nguyên logic cũ).
        
        So sánh "Kế toán - Thông tin thanh toán" với "Số tiền còn phải thanh toán" 
        hoặc "Số tiền thanh toán".
        """
        try:
            payment_info_amount = self.field_extractor.extract_field_from_fieldlist(
                form_data,  FFN.ACCOUNTING_PAYMENT_INFO, FFN.EXPENDITURE_AMOUNT
            )
            amount_due = self.field_extractor.extract_field_value(
                form_data,  FFN.REMAINING_PAYMENT_AMOUNT
            )
            amount_paid = self.field_extractor.extract_field_value(
                form_data, FFN.PAYMENT_AMOUNT
            )
            
            compare_amount = amount_due if amount_due is not None else amount_paid
            compare_field_name = FFN.REMAINING_PAYMENT_AMOUNT if amount_due is not None else FFN.PAYMENT_AMOUNT

            if payment_info_amount is None or compare_amount is None:
                return ValidationResult.create_skipped(
                    ValidationType.PAYMENT_AMOUNT_MISMATCH,
                    "ℹ️ Bỏ qua: Không tìm thấy đủ các trường về số tiền thanh toán để so sánh."
                )

            payment_info_float = float(payment_info_amount)
            compare_amount_float = float(compare_amount)

            if abs(payment_info_float - compare_amount_float) < 0.01:
                return ValidationResult.create_valid(
                    ValidationType.PAYMENT_AMOUNT_MISMATCH,
                    f"✅ Số tiền thanh toán nhất quán: {payment_info_float:,.0f} VND"
                )
            else:
                message = (f"❌ Lỗi thanh toán: 'Kế toán' ({payment_info_float:,.0f}) ≠ "
                           f"'{compare_field_name}' ({compare_amount_float:,.0f}). "
                           f"Chênh lệch: {abs(payment_info_float - compare_amount_float):,.0f} VND")
                details = {"payment_info_amount": payment_info_float, "compare_amount": compare_amount_float}
                return ValidationResult.create_invalid(ValidationType.PAYMENT_AMOUNT_MISMATCH, message, details)
        except (ValueError, TypeError) as e:
            return ValidationResult.create_error(
                ValidationType.PAYMENT_AMOUNT_MISMATCH, f"❌ Lỗi định dạng số tiền thanh toán: {e}",
            )
        except Exception as e:
            return ValidationResult.create_error(
                ValidationType.PAYMENT_AMOUNT_MISMATCH, f"❌ Lỗi không xác định khi validation tiền thanh toán: {e}",
            )

    def validate_total_amount_mismatch(self, form_data: List[Dict], **kwargs) -> ValidationResult:
        """
        Validation tổng số tiền thanh toán dựa trên các khoản chi đã được kế toán xác nhận.
        
        Công thức: Total = (Tổng các khoản chi trong FieldList "Kế toán - Thông tin tạm ứng") + (Số tiền còn phải thanh toán).
        """
        try:
            # Lấy tổng các khoản chi tạm ứng THỰC TẾ từ kế toán
            accountant_expenditures = self.field_extractor.extract_all_values_from_fieldlist(
                form_data, FFN.ACCOUNTING_ADVANCE_INFO, FFN.EXPENDITURE_AMOUNT
            )
            total_accountant_advance = sum(float(v) for v in accountant_expenditures if v is not None and str(v).strip() != '')

            # Lấy các trường còn lại
            amount_due = self.field_extractor.extract_field_value(form_data, FFN.REMAINING_PAYMENT_AMOUNT)
            total_payment_actual = self.field_extractor.extract_field_value(form_data, FFN.TOTAL_PAYMENT_AMOUNT)

            if total_accountant_advance == 0 and amount_due is None:
                return ValidationResult.create_skipped(
                    ValidationType.TOTAL_AMOUNT_MISMATCH,
                    f"ℹ️ Bỏ qua: Kế toán chưa điền thông tin chi hoặc số tiền còn lại."
                )

            if total_payment_actual is None:
                return ValidationResult.create_skipped(
                    ValidationType.TOTAL_AMOUNT_MISMATCH,
                    f"ℹ️ Bỏ qua: Không tìm thấy trường '{FFN.TOTAL_PAYMENT_AMOUNT}' để tính tổng."
                )

            amount_due_float = float(amount_due) if amount_due is not None else 0.0
            total_actual_float = float(total_payment_actual)
            
            total_expected = total_accountant_advance + amount_due_float

            if abs(total_expected - total_actual_float) < 0.01:
                return ValidationResult.create_valid(
                    ValidationType.TOTAL_AMOUNT_MISMATCH,
                    f"✅ Tổng số tiền hợp lệ: {total_actual_float:,.0f} VND"
                )
            else:
                case_description = f"Tổng Kế toán chi ({total_accountant_advance:,.0f}) + Còn Lại ({amount_due_float:,.0f})"
                message = (f"❌ Lỗi tổng tiền: Thực tế ({total_actual_float:,.0f}) ≠ "
                        f"Dự kiến ({total_expected:,.0f} từ {case_description}). "
                        f"Chênh lệch: {abs(total_expected - total_actual_float):,.0f} VND")
                details = {
                    "total_expected": total_expected, 
                    "total_actual": total_actual_float,
                    "total_accountant_advance": total_accountant_advance,
                    "remaining_payment": amount_due_float
                }
                return ValidationResult.create_invalid(ValidationType.TOTAL_AMOUNT_MISMATCH, message, details)
        except (ValueError, TypeError) as e:
            return ValidationResult.create_error(
                ValidationType.TOTAL_AMOUNT_MISMATCH, f"❌ Lỗi định dạng số khi tính tổng tiền: {e}",
            )
        except Exception as e:
            return ValidationResult.create_error(
                ValidationType.TOTAL_AMOUNT_MISMATCH, f"❌ Lỗi không xác định khi validation tổng tiền: {e}",
            )
    
    def validate_workflow_status(self, task_list: List[Dict], node_id: str, **kwargs) -> ValidationResult:
        """
        Validation trạng thái workflow để phát hiện node bị thu hồi.
        """
        try:
            target_node = next((task for task in task_list if task.get('node_id') == node_id), None)
            
            if not target_node:
                return ValidationResult.create_skipped(
                    ValidationType.WORKFLOW_STATUS,
                    f"ℹ️ Bỏ qua: Node {node_id[:8]}... không tìm thấy trong danh sách task"
                )
            
            current_status = target_node.get('status', 'UNKNOWN')
            problematic_statuses = ['REJECTED', 'CANCELED', 'WITHDRAWN']
            if current_status in problematic_statuses:
                return ValidationResult.create_invalid(
                    ValidationType.WORKFLOW_STATUS,
                    f"⚠️ CẢNH BÁO: Node {node_id[:8]}... có trạng thái {current_status} - có thể đã bị thu hồi hoặc từ chối"
                )
            
            return ValidationResult.create_valid(
                ValidationType.WORKFLOW_STATUS,
                f"✅ Node {node_id[:8]}... có trạng thái bình thường: {current_status}"
            )
        except Exception as e:
            return ValidationResult.create_error(
                ValidationType.WORKFLOW_STATUS,
                f"❌ Lỗi kiểm tra trạng thái workflow: {str(e)}"
            )
    
    def validate_field_consistency(self, form_data: List[Dict], **kwargs) -> ValidationResult:
        """
        Placeholder cho các logic validation về tính nhất quán của các trường khác.
        """
        return ValidationResult.create_valid(
            ValidationType.FIELD_CONSISTENCY,
            "✅ Kiểm tra tính nhất quán các trường thành công (placeholder)"
        )
    
    def run_validation(self, validation_type: ValidationType, **kwargs) -> ValidationResult:
        """
        Chạy một quy tắc validation cụ thể.
        """
        if validation_type in self.validation_rules:
            return self.validation_rules[validation_type](**kwargs)
        else:
            return ValidationResult.create_error(
                validation_type,
                f"❌ Loại validation không xác định: {validation_type}"
            )
    
    def run_all_validations(self, form_data: List[Dict], task_list: List[Dict], 
                           node_id: str) -> List[ValidationResult]:
        """
        Chạy tất cả các validation rules đã được đăng ký.
        """
        print(f"🚀 Bắt đầu chạy tất cả validation cho node {node_id[:8]}...")
        results = []
        
        for validation_type in self.validation_rules.keys():
            print(f"▶️ Đang chạy: {validation_type.value}...")
            # Sử dụng extend để xử lý việc một rule có thể trả về nhiều result
            validation_func = self.validation_rules[validation_type]
            
            # Cần kiểm tra xem hàm có trả về list hay không
            # Vì các hàm khác vẫn trả về 1 result đơn lẻ
            result_or_list = validation_func(
                form_data=form_data,
                task_list=task_list,
                node_id=node_id
            )

            if isinstance(result_or_list, list):
                results.extend(result_or_list)
            else:
                results.append(result_or_list)

        invalid_count = sum(1 for r in results if not r.is_valid)
        print(f"📈 Hoàn thành validation: Tìm thấy {invalid_count} vấn đề.")
        
        return results

validation_service = ValidationService()
============================================================

============================================================
FILE: project_complete_info.txt
============================================================
================================================================================
THÔNG TIN DỰ ÁN HOÀN CHỈNH
================================================================================
Thời gian tạo: 2025-10-03 14:17:39
Thư mục gốc: d:\Atino\extension\webhook-server-approval
================================================================================

📁 CẤU TRÚC THU MỤC
--------------------------------------------------
├── 📁 app/
│   ├── 📁 api/
│   ├── 📁 core/
│   │   ├── 📁 bootstrap/
│   │   │   └── 📄 application.py
│   │   ├── 📁 config/
│   │   │   ├── 📄 __init__.py
│   │   │   ├── 📄 field_constants.py
│   │   │   ├── 📄 node_config.py
│   │   │   └── 📄 settings.py
│   │   ├── 📁 events/
│   │   │   └── 📄 event_registry.py
│   │   ├── 📁 infrastructure/
│   │   │   ├── 📄 __init__.py
│   │   │   ├── 📄 cache_service.py
│   │   │   ├── 📄 event_bus.py
│   │   │   └── 📄 lark_service.py
│   │   ├── 📁 models/
│   │   │   ├── 📄 event.py
│   │   │   ├── 📄 response.py
│   │   │   └── 📄 shared.py
│   │   ├── 📁 routers/
│   │   │   ├── 📄 monitoring.py
│   │   │   └── 📄 webhook.py
│   │   ├── 📁 utils/
│   │   │   ├── 📄 __init__.py
│   │   │   ├── 📄 amount_detector.py
│   │   │   ├── 📄 field_extractor.py
│   │   │   └── 📄 helpers.py
│   │   └── 📄 __init__.py
│   └── 📁 domains/
│       ├── 📁 notification/
│       │   ├── 📁 models/
│       │   │   ├── 📄 __init__.py
│       │   │   └── 📄 notification.py
│       │   ├── 📁 services/
│       │   │   ├── 📄 __init__.py
│       │   │   ├── 📄 lark_webhook_service.py
│       │   │   └── 📄 notification_coordinator.py
│       │   └── 📄 __init__.py
│       ├── 📁 qr_generation/
│       │   ├── 📁 handlers/
│       │   │   ├── 📄 __init__.py
│       │   │   └── 📄 qr_event_handler.py
│       │   ├── 📁 models/
│       │   │   ├── 📄 __init__.py
│       │   │   └── 📄 qr.py
│       │   ├── 📁 routers/
│       │   │   └── 📄 qr.py
│       │   ├── 📁 services/
│       │   │   ├── 📄 __init__.py
│       │   │   ├── 📄 amount_detector.py
│       │   │   ├── 📄 qr_processor.py
│       │   │   └── 📄 vietqr_service.py
│       │   └── 📄 __init__.py
│       ├── 📁 validation/
│       │   ├── 📁 handlers/
│       │   │   ├── 📄 __init__.py
│       │   │   └── 📄 validation_event_handler.py
│       │   ├── 📁 models/
│       │   │   ├── 📄 __init__.py
│       │   │   └── 📄 validation.py
│       │   ├── 📁 routers/
│       │   │   ├── 📄 notification.py
│       │   │   └── 📄 validation.py
│       │   ├── 📁 services/
│       │   │   ├── 📄 __init__.py
│       │   │   └── 📄 validation_service.py
│       │   └── 📄 __init__.py
│       └── 📄 __init__.py
├── 📄 .gitignore
├── 📄 Dockerfile
├── 📄 Get detail code.ipynb
├── 📄 lark_events.csv
├── 📄 project_complete_info.txt
├── 📄 README.md
└── 📄 requirements.txt


📄 DANH SÁCH TẤT CẢ FILE
--------------------------------------------------
.gitignore (594 bytes)
app\core\__init__.py (376 bytes)
app\core\bootstrap\application.py (8435 bytes)
app\core\config\__init__.py (271 bytes)
app\core\config\field_constants.py (1232 bytes)
app\core\config\node_config.py (5382 bytes)
app\core\config\settings.py (3520 bytes)
app\core\events\event_registry.py (2702 bytes)
app\core\infrastructure\__init__.py (176 bytes)
app\core\infrastructure\cache_service.py (11934 bytes)
app\core\infrastructure\event_bus.py (5703 bytes)
app\core\infrastructure\lark_service.py (11949 bytes)
app\core\models\event.py (899 bytes)
app\core\models\response.py (1015 bytes)
app\core\models\shared.py (553 bytes)
app\core\routers\monitoring.py (1619 bytes)
app\core\routers\webhook.py (2919 bytes)
app\core\utils\__init__.py (332 bytes)
app\core\utils\amount_detector.py (10162 bytes)
app\core\utils\field_extractor.py (12805 bytes)
app\core\utils\helpers.py (2198 bytes)
app\domains\__init__.py (593 bytes)
app\domains\notification\__init__.py (262 bytes)
app\domains\notification\models\__init__.py (425 bytes)
app\domains\notification\models\notification.py (1578 bytes)
app\domains\notification\services\__init__.py (235 bytes)
app\domains\notification\services\lark_webhook_service.py (12787 bytes)
app\domains\notification\services\notification_coordinator.py (8726 bytes)
app\domains\qr_generation\__init__.py (251 bytes)
app\domains\qr_generation\handlers\__init__.py (82 bytes)
app\domains\qr_generation\handlers\qr_event_handler.py (6616 bytes)
app\domains\qr_generation\models\__init__.py (359 bytes)
app\domains\qr_generation\models\qr.py (1571 bytes)
app\domains\qr_generation\routers\qr.py (1789 bytes)
app\domains\qr_generation\services\__init__.py (214 bytes)
app\domains\qr_generation\services\amount_detector.py (15034 bytes)
app\domains\qr_generation\services\qr_processor.py (17581 bytes)
app\domains\qr_generation\services\vietqr_service.py (6971 bytes)
app\domains\validation\__init__.py (301 bytes)
app\domains\validation\handlers\__init__.py (106 bytes)
app\domains\validation\handlers\validation_event_handler.py (10972 bytes)
app\domains\validation\models\__init__.py (289 bytes)
app\domains\validation\models\validation.py (2871 bytes)
app\domains\validation\routers\notification.py (1283 bytes)
app\domains\validation\routers\validation.py (1756 bytes)
app\domains\validation\services\__init__.py (135 bytes)
app\domains\validation\services\validation_service.py (15465 bytes)
Dockerfile (1896 bytes)
Get detail code.ipynb (10463 bytes)
lark_events.csv (111947 bytes)
project_complete_info.txt (0 bytes)
README.md (7974 bytes)
requirements.txt (136 bytes)

Tổng cộng: 53 file

💻 NỘI DUNG TẤT CẢ FILE CODE
================================================================================

============================================================
FILE: app\core\__init__.py
============================================================
"""
Core infrastructure exports
"""
from app.core.config import *
from app.core.infrastructure import *
from app.core.utils import *

__all__ = [
    # Configuration
    "settings", "NODE_CONFIG",
    
    # Infrastructure  
    "event_bus", "cache_service", "lark_service",
    
    # Utils
    "extract_instance_code", "get_event_type", "format_currency"
]

============================================================

============================================================
FILE: app\core\bootstrap\application.py
============================================================
import asyncio
from datetime import datetime
from app.core.events.event_registry import event_registry
from app.core.config.settings import settings


class ApplicationBootstrap:
    """
    Bootstrap toàn bộ ứng dụng theo kiến trúc DDD (Domain-Driven Design).
    
    Lớp này chịu trách nhiệm khởi tạo và cấu hình tất cả các thành phần cần thiết
    của ứng dụng bao gồm event handlers, infrastructure services và kiểm tra
    sức khỏe hệ thống.
    
    Attributes:
        startup_time (datetime): Thời điểm bắt đầu khởi tạo ứng dụng
        is_initialized (bool): Trạng thái khởi tạo của ứng dụng
    """
    
    def __init__(self):
        """Khởi tạo ApplicationBootstrap với trạng thái ban đầu."""
        self.startup_time = None
        self.is_initialized = False
        
    async def initialize(self):
        """
        Khởi tạo toàn bộ ứng dụng theo thứ tự ưu tiên.
        
        Quá trình khởi tạo bao gồm:
        1. Đăng ký event handlers
        2. Khởi tạo infrastructure services  
        3. Kiểm tra sức khỏe hệ thống
        
        Raises:
            Exception: Khi có lỗi trong quá trình khởi tạo
        """
        print("🚀 Bắt đầu khởi tạo ứng dụng...")
        self.startup_time = datetime.now()
        
        try:
            # 1. Đăng ký các event handlers
            await self._register_event_handlers()
            
            # 2. Khởi tạo các infrastructure services
            await self._initialize_infrastructure()
            
            # 3. Kiểm tra sức khỏe hệ thống
            await self._validate_system_health()
            
            # Đánh dấu ứng dụng đã khởi tạo thành công
            self.is_initialized = True
            elapsed = (datetime.now() - self.startup_time).total_seconds()
            
            print(f"✅ Khởi tạo ứng dụng hoàn tất trong {elapsed:.2f}s")
            
        except Exception as e:
            print(f"❌ Khởi tạo ứng dụng thất bại: {e}")
            raise
    
    async def _register_event_handlers(self):
        """
        Đăng ký tất cả event handlers từ domain layer.
        
        Method này sử dụng event_registry để tự động đăng ký tất cả
        handlers được định nghĩa trong các domain modules.
        
        Raises:
            Exception: Khi không thể đăng ký event handlers
        """
        print("📝 Đang đăng ký event handlers...")
        
        try:
            # Gọi registry để đăng ký tất cả domain handlers
            event_registry.register_domain_handlers()
            
            # Lấy thông tin trạng thái đăng ký để log
            status = event_registry.get_registration_status()
            print(f"   • Đã đăng ký {status['total_handlers']} handlers cho {status['total_event_types']} loại event")
            
        except Exception as e:
            print(f"❌ Đăng ký event handlers thất bại: {e}")
            raise
    
    async def _initialize_infrastructure(self):
        """
        Khởi tạo và kiểm tra các infrastructure services.
        
        Bao gồm:
        - Lark API service (kết nối đến Lark/Feishu)
        - Cache service (Redis hoặc in-memory cache)
        - Notification service (webhook alerts)
        
        Raises:
            Exception: Khi không thể khởi tạo infrastructure services
        """
        print("🏗️ Đang khởi tạo infrastructure services...")
        
        try:
            # Kiểm tra kết nối Lark API
            from app.core.infrastructure.lark_service import lark_service
            
            print("   • Đang kiểm tra kết nối Lark API...")
            token = await lark_service.get_access_token()
            if token:
                print("   ✅ Kết nối Lark API thành công")
            else:
                print("   ⚠️ Kết nối Lark API thất bại - kiểm tra lại thông tin xác thực")
            
            # Khởi tạo cache service
            from app.core.infrastructure.cache_service import cache_service
            print("   • Cache service đã được khởi tạo")
            print(f"   • Thời gian cache QR code: {settings.QR_CACHE_DURATION_MINUTES} phút")
            
            # Kiểm tra notification service nếu được bật
            if settings.ENABLE_VALIDATION_ALERTS:
                print("   • Cảnh báo validation đã được bật")
                if settings.LARK_WEBHOOK_URL:
                    print("   ✅ Webhook URL đã được cấu hình")
                else:
                    print("   ⚠️ Chưa cấu hình webhook URL")
            else:
                print("   • Cảnh báo validation đã được tắt")
            
        except Exception as e:
            print(f"❌ Khởi tạo infrastructure thất bại: {e}")
            raise
    
    async def _validate_system_health(self):
        """
        Kiểm tra sức khỏe tổng thể của hệ thống.
        
        Validates:
        - Event bus hoạt động bình thường
        - Node configuration đã được load
        - Environment variables cần thiết đã được cấu hình
        
        Raises:
            Exception: Khi phát hiện vấn đề nghiêm trọng với hệ thống
        """
        print("🔍 Đang kiểm tra sức khỏe hệ thống...")
        
        try:
            # Kiểm tra event bus
            from app.core.infrastructure.event_bus import event_bus
            handler_count = len(event_bus.handlers.get("approval.instance.updated", []))
            print(f"   • Event bus: {handler_count} handlers đã đăng ký cho approval events")
            
            # Kiểm tra node configuration
            from app.core.config.node_config import NODE_CONFIG
            print(f"   • Cấu hình node: {len(NODE_CONFIG)} nodes đã được cấu hình")
            
            # Kiểm tra các environment variables bắt buộc
            required_vars = ["LARK_APP_ID", "LARK_APP_SECRET"]
            missing_vars = []
            
            # Duyệt qua từng biến môi trường bắt buộc
            for var in required_vars:
                if not getattr(settings, var, None):
                    missing_vars.append(var)
            
            # Báo cáo kết quả kiểm tra environment variables
            if missing_vars:
                print(f"   ⚠️ Thiếu các biến môi trường: {', '.join(missing_vars)}")
            else:
                print("   ✅ Tất cả biến môi trường bắt buộc đều có")
            
            print("   ✅ Kiểm tra sức khỏe hệ thống hoàn tất")
            
        except Exception as e:
            print(f"❌ Kiểm tra sức khỏe hệ thống thất bại: {e}")
            raise
    
    def get_startup_info(self) -> dict:
        """
        Lấy thông tin chi tiết về quá trình khởi động ứng dụng.
        
        Returns:
            dict: Dictionary chứa thông tin startup bao gồm:
                - startup_time: Thời điểm bắt đầu khởi tạo
                - is_initialized: Trạng thái khởi tạo
                - uptime_seconds: Thời gian hoạt động (giây)
                - event_handlers: Thông tin về event handlers đã đăng ký
                - architecture: Loại kiến trúc được sử dụng
                - version: Phiên bản ứng dụng
        """
        return {
            "startup_time": self.startup_time.isoformat() if self.startup_time else None,
            "is_initialized": self.is_initialized,
            "uptime_seconds": (datetime.now() - self.startup_time).total_seconds() if self.startup_time else 0,
            "event_handlers": event_registry.get_registration_status(),
            "architecture": "DDD",
            "version": "2.0.0"
        }


app_bootstrap = ApplicationBootstrap()

============================================================

============================================================
FILE: app\core\config\__init__.py
============================================================
from .settings import settings
from .node_config import NODE_CONFIG, get_node_config, get_configured_node_ids
from .field_constants import FFN

__all__ = [
    "settings", 
    "NODE_CONFIG", 
    "get_node_config", 
    "get_configured_node_ids",
    "FFN"
]

============================================================

============================================================
FILE: app\core\config\field_constants.py
============================================================
# app/core/config/field_constants.py

class FormFieldNames:
    """
    Single Source of Truth for all Lark Approval form field names.
    Tập trung tất cả tên trường của form phê duyệt Lark tại một nơi duy nhất.
    """
    
    # === Trường Tiền Tệ Cấp Cao (Top-level Amount Fields) ===
    ADVANCE_AMOUNT = "Số tiền tạm ứng"
    PAYMENT_AMOUNT = "Số tiền thanh toán"
    REMAINING_PAYMENT_AMOUNT = "Số tiền còn phải thanh toán"
    TOTAL_PAYMENT_AMOUNT = "Total số tiền thanh toán"

    # === Trường Trong FieldList Kế Toán (Accounting FieldList Fields) ===
    ACCOUNTING_ADVANCE_INFO = "Kế toán - Thông tin tạm ứng"
    ACCOUNTING_PAYMENT_INFO = "Kế toán - Thông tin thanh toán"
    EXPENDITURE_AMOUNT = "Số tiền chi" # Dùng chung cho cả tạm ứng và thanh toán

    # === Trường Thông Tin Ngân Hàng (Bank Information Fields) ===
    BANK_NAME = "Ngân hàng"
    BANK_ACCOUNT_NUMBER = "Số tài khoản ngân hàng"
    BENEFICIARY_NAME = "Tên người thụ hưởng"

# Tạo một instance để dễ dàng import và sử dụng
# from app.core.config.field_constants import FFN
FFN = FormFieldNames()
============================================================

============================================================
FILE: app\core\config\node_config.py
============================================================
from .field_constants import FFN

# Cấu hình chi tiết cho từng node trong approval workflow
NODE_CONFIG = {
    # Node trưởng phòng duyệt - Có thể detect cả advance và payment (Không bắt được node submit, node này luôn là node tiếp theo)
    "30e5338b60587c64c7cef5f6a7211ccb": {
        "name": "truong_phong_duyet",
        "type": "dual_detection",                   # Loại node hỗ trợ cả advance và payment
        "advance_field": FFN.ADVANCE_AMOUNT,        # Tên field chứa số tiền tạm ứng
        "payment_field": FFN.PAYMENT_AMOUNT,        # Tên field chứa số tiền thanh toán
        "strategy": "detect_both_fields",           # Strategy tự động detect loại QR dựa trên fields
        "required_status": "PENDING",               # Status cần thiết để trigger QR generation
        "description": "Trưởng phòng duyệt - Auto detect advance/payment"
    },
    
    # Node thanh toán
    "f23535375a26847ef71c1cbf0755f246": {
        "name": "thanh_toan_sau_tam_ung", 
        "type": "payment_only",                          # Loại node chỉ xử lý payment
        "advance_field": None,                           # Không có field advance
        "payment_field": FFN.REMAINING_PAYMENT_AMOUNT,   # Field chứa số tiền cần thanh toán
        "strategy": "payment_field_only",                # Strategy chỉ xử lý payment field
        "required_status": "APPROVED",                   # Node này cần status APPROVED
        
        # Điều kiện bổ sung để trigger QR generation
        "additional_conditions": [
            {
                "node_id": "ef83b231885a1a77658f32808a199764",  # Node tiếp theo
                "required_status": "PENDING",                   # Node tiếp theo phải PENDING
                "description": "Node tiếp theo phải PENDING"    # Mô tả điều kiện
            }
        ],
        "description": "Thanh toán sau tạm ứng - Payment only (trigger on APPROVED + next node PENDING)"
    }
}


def get_node_config(node_id: str) -> dict:
    """
    Lấy configuration chi tiết cho một node_id cụ thể.
    
    Args:
        node_id (str): Node ID cần lấy configuration
        
    Returns:
        dict: Dictionary chứa cấu hình node bao gồm:
            - name: Tên node
            - type: Loại node (dual_detection, payment_only, etc.)
            - advance_field: Tên field chứa số tiền tạm ứng
            - payment_field: Tên field chứa số tiền thanh toán
            - strategy: Chiến lược xử lý (detect_both_fields, payment_field_only, etc.)
            - required_status: Status cần thiết để trigger
            - additional_conditions: Các điều kiện bổ sung (optional)
            - description: Mô tả node
        Trả về None nếu không tìm thấy node_id
    """
    return NODE_CONFIG.get(node_id)


def get_node_strategy(node_id: str) -> str:
    """
    Lấy strategy xử lý của một node cụ thể.
    
    Args:
        node_id (str): Node ID cần lấy strategy
        
    Returns:
        str: Tên strategy của node như:
            - "detect_both_fields": Tự động detect advance/payment
            - "payment_field_only": Chỉ xử lý payment
            - "unknown": Nếu không tìm thấy node hoặc strategy
    """
    config = get_node_config(node_id)
    return config.get("strategy", "unknown") if config else "unknown"


def print_node_config_summary():
    """
    In ra tóm tắt chi tiết của NODE_CONFIG bao gồm additional conditions.
    
    Function này hiển thị thông tin tổng quan về tất cả nodes được cấu hình,
    bao gồm strategy, fields, required status và các điều kiện bổ sung.
    """
    print("📋 Tóm tắt cấu hình NODE_CONFIG:")
    
    # Duyệt qua từng node trong configuration
    for node_id, config in NODE_CONFIG.items():
        required_status = config.get('required_status', 'PENDING')
        additional_conditions = config.get('additional_conditions', [])
        
        # Hiển thị thông tin cơ bản của node
        print(f"   • {node_id[:8]}... - {config['name']} ({config['strategy']})")
        print(f"     Các trường: advance='{config['advance_field']}', payment='{config['payment_field']}'")
        print(f"     Status yêu cầu: {required_status}")
        
        # Hiển thị các điều kiện bổ sung nếu có
        if additional_conditions:
            print(f"     Điều kiện bổ sung:")
            for condition in additional_conditions:
                condition_node_short = condition['node_id'][:8]
                condition_status = condition['required_status']
                print(f"       - {condition_node_short}... phải có status {condition_status}")


def get_configured_node_ids():
    """
    Lấy danh sách tất cả node IDs đã được cấu hình.
    
    Returns:
        List[str]: Danh sách tất cả node IDs có trong NODE_CONFIG
    """
    return list(NODE_CONFIG.keys())


# Backward compatibility - Giữ lại tên cũ để không break existing code
ALLOWED_NODE_IDS = get_configured_node_ids()

============================================================

============================================================
FILE: app\core\config\settings.py
============================================================
import os
from typing import Optional


class Settings:
    """
    Cấu hình toàn bộ ứng dụng từ environment variables và default values.
    
    Settings class quản lý tất cả các cấu hình cần thiết cho ứng dụng bao gồm:
    - FastAPI server configuration
    - Lark/Feishu API credentials và endpoints
    - VietQR service configuration
    - Webhook và notification settings
    - Cache và performance settings
    - File storage settings
    - Validation và alert settings
    
    Tất cả settings có thể được override bằng environment variables.
    """
    
    # ===== FASTAPI SERVER SETTINGS =====
    # Cấu hình cho FastAPI web server
    DEBUG: bool = os.getenv("DEBUG", "false").lower() == "true"  # Bật/tắt debug mode
    PORT: int = int(os.getenv("PORT", "8000"))                   # Port để chạy server
    
    # ===== LARK/FEISHU API SETTINGS =====
    # Thông tin xác thực và endpoints cho Lark API
    LARK_APP_ID: str = os.getenv("LARK_APP_ID", "cli_a758ffaf41f8502f")
    LARK_APP_SECRET: str = os.getenv("LARK_APP_SECRET", "45Jsgm3TYfEwD2F67BH1LctlYEcCjZpH")
    
    # Base URL cho tất cả Lark API calls
    BASE_URL: str = "https://open.larksuite.com/open-apis"
    
    # Endpoint chuyên dụng cho upload file lên approval system
    APPROVAL_UPLOAD_URL: str = "https://www.larksuite.com/approval/openapi/v2/file/upload"
    
    # ===== VIETQR SERVICE SETTINGS =====
    # Cấu hình cho VietQR API để generate QR codes
    VIETQR_TEMPLATE: str = "compact2"                           # Template layout cho QR code
    VIETQR_BASE_URL: str = "https://img.vietqr.io/image"       # Base URL của VietQR service
    
    # ===== WEBHOOK & NOTIFICATION SETTINGS =====
    # Cấu hình webhook để gửi notifications
    LARK_WEBHOOK_URL: str = os.getenv(
        "LARK_WEBHOOK_URL", 
        "https://open.larksuite.com/open-apis/bot/v2/hook/6a53a060-40d7-4716-9a90-970a6cbdaf64"
    )
    
    # Bật/tắt validation alerts qua webhook
    ENABLE_VALIDATION_ALERTS: bool = os.getenv("ENABLE_VALIDATION_ALERTS", "true").lower() == "true"

    # ===== CACHE & PERFORMANCE SETTINGS =====
    # Cấu hình cache để tối ưu performance và tránh duplicate requests
    QR_CACHE_DURATION_MINUTES: int = 5      # Thời gian cache QR generation (phút)
    TOKEN_CACHE_BUFFER_SECONDS: int = 300   # Buffer time trước khi token hết hạn (5 phút)

    # ===== FILE STORAGE SETTINGS =====
    # Cấu hình file storage cho logging và data persistence
    EVENTS_FILE: str = "lark_events.csv"    # File lưu trữ event logs
    
    # ===== USER & AUTHENTICATION SETTINGS =====
    # User ID mặc định để tạo comments trong Lark approval
    DEFAULT_USER_ID: str = "cd11b141"
    
    # ===== VALIDATION & MONITORING SETTINGS =====
    # Cấu hình các tính năng validation và monitoring (cho future extensions)
    
    # Bật/tắt validation số tiền trong approval workflow
    ENABLE_AMOUNT_VALIDATION: bool = os.getenv("ENABLE_AMOUNT_VALIDATION", "true").lower() == "true"
    
    # Bật/tắt alerts cho workflow errors và anomalies
    ENABLE_WORKFLOW_ALERTS: bool = os.getenv("ENABLE_WORKFLOW_ALERTS", "true").lower() == "true"


# Global settings instance - sử dụng trong toàn bộ ứng dụng
# Import settings từ module này để truy cập tất cả configuration
settings = Settings()

============================================================

============================================================
FILE: app\core\events\event_registry.py
============================================================
"""
Event Registry - Central registration for all domain event handlers
"""
from typing import Dict, List, Callable
from app.core.infrastructure.event_bus import event_bus

class EventRegistry:
    """Central registry for domain event handlers"""
    
    def __init__(self):
        self.registered_handlers: Dict[str, List[str]] = {}
    
    def register_handler(self, event_type: str, handler: Callable, domain: str = "core"):
        """Register a handler for an event type"""
        try:
            event_bus.subscribe(event_type, handler)
            
            # Track registration for monitoring
            if event_type not in self.registered_handlers:
                self.registered_handlers[event_type] = []
            
            handler_info = f"{domain}.{handler.__name__}"
            self.registered_handlers[event_type].append(handler_info)
            
            print(f"✅ Registered {handler_info} for event: {event_type}")
            
        except Exception as e:
            print(f"❌ Failed to register handler {handler.__name__}: {e}")
    
    def register_domain_handlers(self):
        """Register all domain handlers"""
        print("🔧 Registering domain event handlers...")
        
        try:
            # QR Generation Domain Handlers
            from app.domains.qr_generation.handlers import qr_event_handler
            self.register_handler(
                "approval.instance.updated", 
                qr_event_handler.handle_approval_event,
                "qr_generation"
            )
            
            # Validation Domain Handlers  
            from app.domains.validation.handlers import validation_event_handler
            self.register_handler(
                "approval.instance.updated",
                validation_event_handler.handle_approval_event, 
                "validation"
            )
            
            print(f"✅ Successfully registered handlers for {len(self.registered_handlers)} event types")
            
        except Exception as e:
            print(f"❌ Error registering domain handlers: {e}")
            raise
    
    def get_registration_status(self) -> Dict:
        """Get current registration status"""
        total_handlers = sum(len(handlers) for handlers in self.registered_handlers.values())
        
        return {
            "total_event_types": len(self.registered_handlers),
            "total_handlers": total_handlers,
            "registrations": self.registered_handlers,
            "event_bus_handlers": len(event_bus.handlers)
        }

# Global registry instance
event_registry = EventRegistry()

============================================================

============================================================
FILE: app\core\infrastructure\__init__.py
============================================================
from .event_bus import event_bus
from .cache_service import cache_service
from .lark_service import lark_service

__all__ = ["event_bus", "cache_service", "lark_service"]

============================================================

============================================================
FILE: app\core\infrastructure\cache_service.py
============================================================
from datetime import datetime, timedelta
from typing import Dict, Optional


class CacheService:
    """
    Service quản lý cache cho QR code generation và validation alerts.
    
    CacheService giúp tránh trùng lặp bằng cách cache thời điểm tạo QR codes
    và gửi validation alerts. Service này sử dụng in-memory cache với
    automatic expiration để tiết kiệm bộ nhớ.
    
    Attributes:
        qr_generation_cache (Dict[str, datetime]): Cache thời điểm tạo QR codes
        validation_alert_cache (Dict[str, datetime]): Cache thời điểm gửi validation alerts
    """
    
    def __init__(self):
        """Khởi tạo CacheService với các cache dictionary rỗng."""
        self.qr_generation_cache: Dict[str, datetime] = {}
        self.validation_alert_cache: Dict[str, datetime] = {}
    
    def generate_cache_key(self, instance_code: str, node_id: str, qr_type: str) -> str:
        """
        Tạo cache key unique cho QR code để detect duplicates.
        
        Args:
            instance_code (str): Mã instance của approval workflow
            node_id (str): ID của node trong workflow
            qr_type (str): Loại QR code (payment, advance, etc.)
            
        Returns:
            str: Cache key format: {instance_code}_{short_node_id}_{qr_type}
        """
        # Rút ngắn node_id để cache key không quá dài
        short_node_id = node_id[:8] if len(node_id) > 8 else node_id
        return f"{instance_code}_{short_node_id}_{qr_type}"

    def generate_validation_cache_key(self, instance_code: str, validation_type: str) -> str:
        """
        Tạo cache key cho validation alerts để tránh spam alerts.
        
        Args:
            instance_code (str): Mã instance của approval workflow
            validation_type (str): Loại validation (amount_mismatch, workflow_error, etc.)
            
        Returns:
            str: Cache key format: validation_{instance_code}_{validation_type}
        """
        return f"validation_{instance_code}_{validation_type}"

    def is_qr_recently_generated(self, instance_code: str, node_id: str, qr_type: str, 
                               cache_duration_minutes: int = 5) -> bool:
        """
        Kiểm tra xem QR code đã được tạo trong khoảng thời gian gần đây chưa.
        
        Args:
            instance_code (str): Mã instance của approval workflow
            node_id (str): ID của node trong workflow
            qr_type (str): Loại QR code
            cache_duration_minutes (int, optional): Thời gian cache tính bằng phút. Mặc định 5 phút.
            
        Returns:
            bool: True nếu QR đã được tạo gần đây, False nếu chưa hoặc đã hết hạn
        """
        try:
            cache_key = self.generate_cache_key(instance_code, node_id, qr_type)
            
            # Kiểm tra xem cache key có tồn tại không
            if cache_key not in self.qr_generation_cache:
                print(f"🆕 Cache miss: {cache_key} - chưa từng tạo QR")
                return False
            
            # Tính thời gian đã trải qua kể từ lần tạo QR cuối
            generated_time = self.qr_generation_cache[cache_key]
            current_time = datetime.now()
            time_diff = current_time - generated_time
            
            # Nếu đã quá thời gian cache thì xóa entry và return False
            if time_diff > timedelta(minutes=cache_duration_minutes):
                del self.qr_generation_cache[cache_key] 
                print(f"⏰ Cache đã hết hạn: {cache_key} ({time_diff.total_seconds()/60:.1f} phút trước)")
                return False
            
            print(f"🔒 Cache hit: {cache_key} - QR đã tạo {time_diff.total_seconds()/60:.1f} phút trước")
            return True
            
        except Exception as e:
            print(f"❌ Lỗi khi kiểm tra cache: {e}")
            return False

    def is_validation_alert_recently_sent(self, instance_code: str, validation_type: str,
                                        cache_duration_minutes: int = 10) -> bool:
        """
        Kiểm tra xem validation alert đã được gửi trong khoảng thời gian gần đây chưa.
        
        Args:
            instance_code (str): Mã instance của approval workflow
            validation_type (str): Loại validation error
            cache_duration_minutes (int, optional): Thời gian cache tính bằng phút. Mặc định 10 phút.
            
        Returns:
            bool: True nếu alert đã được gửi gần đây, False nếu chưa hoặc đã hết hạn
        """
        try:
            cache_key = self.generate_validation_cache_key(instance_code, validation_type)
            
            # Kiểm tra xem cache key có tồn tại không
            if cache_key not in self.validation_alert_cache:
                print(f"🆕 Validation cache miss: {cache_key} - chưa từng gửi alert")
                return False
            
            # Tính thời gian đã trải qua kể từ lần gửi alert cuối
            sent_time = self.validation_alert_cache[cache_key]
            current_time = datetime.now()
            time_diff = current_time - sent_time
            
            # Nếu đã quá thời gian cache thì xóa entry và return False
            if time_diff > timedelta(minutes=cache_duration_minutes):
                del self.validation_alert_cache[cache_key]
                print(f"⏰ Validation cache đã hết hạn: {cache_key} ({time_diff.total_seconds()/60:.1f} phút trước)")
                return False
            
            print(f"🔒 Validation cache hit: {cache_key} - Alert đã gửi {time_diff.total_seconds()/60:.1f} phút trước")
            return True
            
        except Exception as e:
            print(f"❌ Lỗi khi kiểm tra validation cache: {e}")
            return False

    def mark_qr_as_generated(self, instance_code: str, node_id: str, qr_type: str):
        """
        Đánh dấu QR code đã được tạo bằng cách lưu timestamp vào cache.
        
        Args:
            instance_code (str): Mã instance của approval workflow
            node_id (str): ID của node trong workflow
            qr_type (str): Loại QR code
        """
        try:
            cache_key = self.generate_cache_key(instance_code, node_id, qr_type)
            self.qr_generation_cache[cache_key] = datetime.now()
            
            print(f"🔒 Đã đánh dấu QR được tạo: {cache_key}")
            print(f"📊 Kích thước QR Cache: {len(self.qr_generation_cache)} entries")
            
        except Exception as e:
            print(f"❌ Lỗi khi đánh dấu cache: {e}")

    def mark_validation_alert_as_sent(self, instance_code: str, validation_type: str):
        """
        Đánh dấu validation alert đã được gửi bằng cách lưu timestamp vào cache.
        
        Args:
            instance_code (str): Mã instance của approval workflow
            validation_type (str): Loại validation error
        """
        try:
            cache_key = self.generate_validation_cache_key(instance_code, validation_type)
            self.validation_alert_cache[cache_key] = datetime.now()
            
            print(f"🔒 Đã đánh dấu validation alert được gửi: {cache_key}")
            print(f"📊 Kích thước Validation Cache: {len(self.validation_alert_cache)} entries")
            
        except Exception as e:
            print(f"❌ Lỗi khi đánh dấu validation cache: {e}")

    def get_cache_status(self) -> Dict:
        """
        Lấy trạng thái chi tiết của tất cả cache (QR và validation).
        
        Returns:
            Dict: Dictionary chứa thông tin chi tiết về:
                - qr_cache: Thông tin về QR generation cache
                - validation_cache: Thông tin về validation alert cache
                - current_time: Thời gian hiện tại
        """
        try:
            current_time = datetime.now()
            
            # Tính toán trạng thái QR Cache
            active_qr_cache = {}
            for cache_key, generated_time in self.qr_generation_cache.items():
                time_diff = current_time - generated_time
                minutes_ago = time_diff.total_seconds() / 60
                
                active_qr_cache[cache_key] = {
                    'generated_at': generated_time.isoformat(),
                    'minutes_ago': round(minutes_ago, 1),
                    'will_expire_in_minutes': max(0, 5 - minutes_ago)  # 5 phút cho QR
                }
            
            # Tính toán trạng thái Validation Cache
            active_validation_cache = {}
            for cache_key, sent_time in self.validation_alert_cache.items():
                time_diff = current_time - sent_time
                minutes_ago = time_diff.total_seconds() / 60
                
                active_validation_cache[cache_key] = {
                    'sent_at': sent_time.isoformat(),
                    'minutes_ago': round(minutes_ago, 1),
                    'will_expire_in_minutes': max(0, 10 - minutes_ago)  # 10 phút cho validation
                }
            
            return {
                'qr_cache': {
                    'total_cached_qr': len(self.qr_generation_cache),
                    'active_cache': active_qr_cache,
                    'cache_duration_minutes': 5
                },
                'validation_cache': {
                    'total_cached_alerts': len(self.validation_alert_cache),
                    'active_cache': active_validation_cache,
                    'cache_duration_minutes': 10
                },
                'current_time': current_time.isoformat()
            }
            
        except Exception as e:
            return {"error": str(e)}

    def clear_cache(self) -> Dict:
        """
        Xóa tất cả cache entries (cả QR và validation) và trả về thông tin chi tiết.
        
        Returns:
            Dict: Dictionary chứa:
                - message: Thông báo kết quả
                - cleared_qr_keys: Danh sách QR cache keys đã bị xóa
                - cleared_validation_keys: Danh sách validation cache keys đã bị xóa
                - current_cache_sizes: Kích thước cache hiện tại (sau khi clear)
        """
        try:
            # Lưu lại thông tin trước khi clear
            old_qr_count = len(self.qr_generation_cache)
            old_validation_count = len(self.validation_alert_cache)
            old_qr_keys = list(self.qr_generation_cache.keys())
            old_validation_keys = list(self.validation_alert_cache.keys())
            
            # Clear tất cả cache
            self.qr_generation_cache.clear()
            self.validation_alert_cache.clear()
            
            return {
                'message': f'Đã xóa thành công {old_qr_count} QR cache entries và {old_validation_count} validation cache entries',
                'cleared_qr_keys': old_qr_keys,
                'cleared_validation_keys': old_validation_keys,
                'current_qr_cache_size': len(self.qr_generation_cache),
                'current_validation_cache_size': len(self.validation_alert_cache)
            }
            
        except Exception as e:
            return {"success": False, "error": str(e)}


cache_service = CacheService()

============================================================

============================================================
FILE: app\core\infrastructure\event_bus.py
============================================================
# app/services/event_bus.py
import asyncio
from typing import Dict, List, Callable, Any
from datetime import datetime


class EventBus:
    """
    Event Bus system để quản lý và phân phối events trong ứng dụng.
    
    EventBus cho phép các component đăng ký handlers cho các loại event khác nhau
    và publish events để thực thi tất cả handlers đã đăng ký một cách bất đồng bộ.
    
    Attributes:
        handlers (Dict[str, List[Callable]]): Dictionary chứa danh sách handlers cho từng event type
        event_history (List[Dict]): Lịch sử tất cả events đã được publish
    """
    
    def __init__(self):
        """Khởi tạo EventBus với handlers và event history rỗng."""
        self.handlers: Dict[str, List[Callable]] = {}
        self.event_history: List[Dict] = []
    
    def subscribe(self, event_type: str, handler: Callable):
        """
        Đăng ký handler cho một event type cụ thể.
        
        Args:
            event_type (str): Loại event cần lắng nghe
            handler (Callable): Hàm xử lý sẽ được gọi khi event được publish
            
        Note:
            Handler phải là async function và nhận event_data làm tham số
        """
        # Khởi tạo danh sách handlers cho event type nếu chưa tồn tại
        if event_type not in self.handlers:
            self.handlers[event_type] = []
        
        # Thêm handler vào danh sách
        self.handlers[event_type].append(handler)
        print(f"📝 Đã đăng ký handler cho event: {event_type}")
    
    async def publish(self, event_type: str, event_data: Dict[str, Any]):
        """
        Publish event và thực thi tất cả handlers đã đăng ký song song.
        
        Args:
            event_type (str): Loại event cần publish
            event_data (Dict[str, Any]): Dữ liệu sẽ được truyền cho các handlers
            
        Returns:
            List: Danh sách kết quả từ tất cả handlers (bao gồm cả exceptions)
        """
        print(f"📢 Đang publish event: {event_type}")
        
        # Lưu lịch sử event
        event_record = {
            "timestamp": datetime.now().isoformat(),
            "event_type": event_type,
            "data": event_data,
            "handlers_count": len(self.handlers.get(event_type, []))
        }
        self.event_history.append(event_record)
        
        # Thực thi tất cả handlers đồng thời
        if event_type in self.handlers:
            tasks = []
            
            # Tạo task cho mỗi handler
            for handler in self.handlers[event_type]:
                task = asyncio.create_task(
                    self._run_handler_safe(handler, event_data)
                )
                tasks.append(task)
            
            # Đợi tất cả handlers hoàn thành (kể cả khi có lỗi)
            results = await asyncio.gather(*tasks, return_exceptions=True)
            
            # Ghi log kết quả từ mỗi handler
            for i, result in enumerate(results):
                handler_name = self.handlers[event_type][i].__name__
                if isinstance(result, Exception):
                    print(f"❌ Handler {handler_name} thất bại: {result}")
                else:
                    print(f"✅ Handler {handler_name} hoàn thành: {result}")
            
            return results
        else:
            print(f"⚠️ Không có handler nào được đăng ký cho event: {event_type}")
            return []
    
    async def _run_handler_safe(self, handler: Callable, event_data: Dict) -> Dict:
        """
        Thực thi handler với error handling và monitoring thời gian.
        
        Args:
            handler (Callable): Handler function cần thực thi
            event_data (Dict): Dữ liệu event được truyền cho handler
            
        Returns:
            Dict: Thông tin kết quả bao gồm success status, result/error, và thời gian thực thi
        """
        handler_name = handler.__name__
        try:
            print(f"🚀 Bắt đầu thực thi handler: {handler_name}")
            start_time = datetime.now()
            
            # Gọi handler (phải là async function)
            result = await handler(event_data)
            
            # Tính thời gian thực thi
            end_time = datetime.now()
            duration = (end_time - start_time).total_seconds()
            
            return {
                "handler": handler_name,
                "success": True,
                "result": result,
                "duration_seconds": duration
            }
            
        except Exception as e:
            print(f"❌ Handler {handler_name} gặp lỗi: {e}")
            return {
                "handler": handler_name,
                "success": False,
                "error": str(e),
                "duration_seconds": 0
            }
    
    def get_event_history(self, limit: int = 50) -> List[Dict]:
        """
        Lấy lịch sử các events đã được publish.
        
        Args:
            limit (int, optional): Số lượng events gần nhất cần lấy. Mặc định là 50.
            
        Returns:
            List[Dict]: Danh sách các event records theo thứ tự thời gian (mới nhất cuối)
        """
        return self.event_history[-limit:]


event_bus = EventBus()

============================================================

============================================================
FILE: app\core\infrastructure\lark_service.py
============================================================
import requests
import json
from datetime import datetime
from typing import Optional, Dict
from app.core.config.settings import settings


class LarkService:
    """
    Service tương tác với Lark/Feishu API để quản lý approval instances.
    
    LarkService cung cấp các chức năng chính:
    - Xác thực và quản lý access tokens với caching
    - Lấy thông tin approval instances
    - Upload hình ảnh lên Lark
    - Tạo comments với attachments
    
    Attributes:
        access_token_cache (Dict): Cache lưu trữ access token và thời gian hết hạn
    """
    
    def __init__(self):
        """Khởi tạo LarkService với token cache rỗng."""
        self.access_token_cache = {"token": None, "expires_at": None}
    
    async def get_access_token(self) -> Optional[str]:
        """
        Lấy access token từ LarkSuite API với caching mechanism.
        
        Method này sẽ sử dụng cached token nếu còn hiệu lực, otherwise
        sẽ gọi API để lấy token mới và cache lại.
        
        Returns:
            Optional[str]: Access token nếu thành công, None nếu thất bại
        """
        current_time = datetime.now().timestamp()
        
        # Kiểm tra xem token đã cache còn hiệu lực không
        if (self.access_token_cache["token"] and 
            self.access_token_cache["expires_at"] and 
            current_time < self.access_token_cache["expires_at"]):
            return self.access_token_cache["token"]
        
        try:
            # Gọi API để lấy tenant access token mới
            url = f"{settings.BASE_URL}/auth/v3/tenant_access_token/internal"
            payload = {
                "app_id": settings.LARK_APP_ID,
                "app_secret": settings.LARK_APP_SECRET
            }
            
            response = requests.post(url, json=payload, timeout=10)
            data = response.json()
            
            # Kiểm tra response từ API
            if data.get("code") == 0:
                token = data["tenant_access_token"]
                expires_in = data.get("expire", 7200)  # Mặc định 2 tiếng
                
                # Cache token với buffer time để tránh token hết hạn giữa chừng
                self.access_token_cache["token"] = token
                self.access_token_cache["expires_at"] = current_time + expires_in - settings.TOKEN_CACHE_BUFFER_SECONDS
                
                print(f"✅ Lấy access token thành công")
                return token
            else:
                print(f"❌ Lấy token thất bại: {data}")
                return None
                
        except Exception as e:
            print(f"❌ Lỗi khi lấy token: {e}")
            return None

    async def get_approval_instance(self, instance_code: str, access_token: str) -> Optional[Dict]:
        """
        Lấy thông tin chi tiết của approval instance từ Lark API.
        
        Args:
            instance_code (str): Mã định danh của approval instance
            access_token (str): Access token để xác thực API call
            
        Returns:
            Optional[Dict]: Thông tin instance nếu thành công, None nếu thất bại
        """
        try:
            url = f"{settings.BASE_URL}/approval/v4/instances/{instance_code}"
            headers = {"Authorization": f"Bearer {access_token}"}
            
            print(f"🔍 Đang lấy thông tin instance: {instance_code}")
            response = requests.get(url, headers=headers, timeout=10)
            
            # Kiểm tra HTTP status code
            if response.status_code != 200:
                print(f"❌ Lỗi HTTP khi gọi API: {response.status_code}")
                return None
                
            api_response = response.json()
            
            # Kiểm tra Lark API response code
            if api_response.get("code") != 0:
                print(f"❌ Lỗi Lark API response: {api_response}")
                return None
                
            return api_response
            
        except Exception as e:
            print(f"❌ Lỗi khi lấy thông tin approval instance: {e}")
            return None

    async def upload_image_to_approval(self, image_buffer, filename: str, access_token: str) -> Dict:
        """
        Upload hình ảnh lên Lark Approval system để sử dụng trong comments.
        
        Args:
            image_buffer: Buffer chứa dữ liệu hình ảnh (bytes)
            filename (str): Tên file của hình ảnh
            access_token (str): Access token để xác thực API call
            
        Returns:
            Dict: Dictionary chứa:
                - success (bool): Trạng thái upload
                - file_code (str): Mã file từ Lark (nếu success)  
                - file_url (str): URL file từ Lark (nếu success)
                - error (str): Thông báo lỗi (nếu failed)
        """
        try:
            # Reset buffer position về đầu để đọc từ beginning
            image_buffer.seek(0)
            
            # Chuẩn bị multipart form data cho upload
            files = {
                'name': (None, filename),
                'type': (None, 'image'),
                'content': (filename, image_buffer, 'image/png')
            }
            
            headers = {
                'Authorization': f'Bearer {access_token}'
            }
            
            print(f"📤 Đang upload hình ảnh: {filename}")
            response = requests.post(settings.APPROVAL_UPLOAD_URL, files=files, headers=headers)
            
            # Xử lý response từ upload API
            if response.status_code == 200:
                data = response.json()
                if data.get('code') == 0:
                    file_code = data['data']['code']
                    file_url = data['data']['url']
                    print(f'✅ Upload hình ảnh thành công! File code: {file_code}')
                    return {
                        'success': True,
                        'file_code': file_code,
                        'file_url': file_url
                    }
                else:
                    error_msg = f"Lỗi API: {data.get('msg')} (code: {data.get('code')})"
                    print(f'❌ Upload thất bại: {error_msg}')
                    return {'success': False, 'error': error_msg}
            else:
                error_msg = f"Lỗi HTTP: {response.status_code}"
                print(f'❌ Upload thất bại: {error_msg}')
                return {'success': False, 'error': error_msg}
                
        except Exception as e:
            error_msg = f"Exception: {str(e)}"
            print(f"❌ Lỗi upload: {error_msg}")
            return {'success': False, 'error': error_msg}

    async def create_enhanced_comment_with_image(self, instance_code: str, file_url: str, file_code: str, 
                                               filename: str, qr_type: str, amount: int, node_name: str,
                                               access_token: str, user_id: str = None) -> Dict:
        """
        Tạo comment với hình ảnh QR code và thông tin chi tiết.
        
        Args:
            instance_code (str): Mã instance của approval workflow
            file_url (str): URL của file đã upload
            file_code (str): Code của file từ Lark system
            filename (str): Tên file hình ảnh
            qr_type (str): Loại QR ('advance' hoặc 'payment')
            amount (int): Số tiền của QR code
            node_name (str): Tên node trong workflow
            access_token (str): Access token để xác thực
            user_id (str, optional): User ID thực hiện comment
            
        Returns:
            Dict: Dictionary chứa:
                - success (bool): Trạng thái tạo comment
                - comment_id (str): ID của comment được tạo (nếu success)
                - error (str): Thông báo lỗi (nếu failed)
        """
        try:
            # Sử dụng default user ID nếu không được cung cấp
            if user_id is None:
                user_id = settings.DEFAULT_USER_ID
                
            create_comment_url = f'{settings.BASE_URL}/approval/v4/instances/{instance_code}/comments'
            
            # Parameters cho API call
            params = {
                "user_id": user_id,
                "user_id_type": "user_id"
            }
            
            # Tạo text hiển thị cho QR type
            qr_type_display = {
                'advance': 'TẠM ỨNG',
                'payment': 'THANH TOÁN'
            }
            
            # Tạo nội dung comment với thông tin chi tiết
            comment_text = f"""🏦 Mã VietQR {qr_type_display.get(qr_type, qr_type.upper())}
💰 Số tiền: {amount:,} VND"""

            # Ước tính kích thước file (rough estimate)
            try:
                file_size = len(filename) * 100  # Ước tính dựa trên độ dài filename
            except:
                file_size = 50000  # Giá trị mặc định

            # Tạo content data với text và file attachment
            content_data = {
                "text": comment_text,
                "files": [{
                    "url": file_url,
                    "fileSize": file_size,
                    "title": filename,
                    "type": "image",
                    "extra": file_code
                }]
            }
            
            # Request body với JSON content
            request_body = {
                "content": json.dumps(content_data, ensure_ascii=False)
            }
            
            headers_comment = {
                'Authorization': f'Bearer {access_token}',
                'Content-Type': 'application/json'
            }
            
            print(f"📤 Đang tạo enhanced comment cho instance: {instance_code}")
            print(f"   Nội dung: {comment_text.replace(chr(10), ' | ')}")
            
            # Gọi API để tạo comment
            response = requests.post(
                create_comment_url, 
                params=params,
                json=request_body, 
                headers=headers_comment
            )
            
            # Xử lý response từ comment API
            if response.status_code == 200:
                comment_result = response.json()
                if comment_result.get('code') == 0:
                    comment_id = comment_result.get("data", {}).get("comment_id", "N/A")
                    print(f'✅ Tạo enhanced comment thành công! Comment ID: {comment_id}')
                    return {'success': True, 'comment_id': comment_id}
                else:
                    error_msg = f"Lỗi API: {comment_result.get('msg')} (code: {comment_result.get('code')})"
                    print(f'❌ Tạo comment thất bại: {error_msg}')
                    return {'success': False, 'error': error_msg}
            else:
                error_msg = f"Lỗi HTTP: {response.status_code}"
                print(f'❌ Tạo comment thất bại: {error_msg}')
                return {'success': False, 'error': error_msg}
                
        except Exception as e:
            error_msg = f"Exception: {str(e)}"
            print(f"❌ Lỗi tạo enhanced comment: {error_msg}")
            return {'success': False, 'error': error_msg}


lark_service = LarkService()

============================================================

============================================================
FILE: app\core\models\event.py
============================================================
from pydantic import BaseModel
from typing import Optional, Dict, Any
from datetime import datetime

class EventHeader(BaseModel):
    event_id: Optional[str] = None
    event_type: Optional[str] = None
    create_time: Optional[str] = None
    token: Optional[str] = None
    tenant_key: Optional[str] = None
    app_id: Optional[str] = None

class EventBody(BaseModel):
    instance_code: Optional[str] = None
    type: Optional[str] = None
    object: Optional[Dict[str, Any]] = None

class LarkEvent(BaseModel):
    schema: Optional[str] = None
    header: Optional[EventHeader] = None
    event: Optional[EventBody] = None
    type: Optional[str] = None  # For URL verification
    challenge: Optional[str] = None  # For URL verification

class EventRecord(BaseModel):
    timestamp: datetime
    event_type: str
    instance_code: Optional[str]
    raw_event: str

============================================================

============================================================
FILE: app\core\models\response.py
============================================================
from pydantic import BaseModel
from typing import Optional, Dict, Any, List

class APIResponse(BaseModel):
    success: bool
    message: Optional[str] = None
    data: Optional[Dict[str, Any]] = None
    error: Optional[str] = None

class UploadResult(BaseModel):
    success: bool
    file_code: Optional[str] = None
    file_url: Optional[str] = None
    error: Optional[str] = None

class CommentResult(BaseModel):
    success: bool
    comment_id: Optional[str] = None
    error: Optional[str] = None

class QRGenerationResult(BaseModel):
    success: bool
    qr_type: Optional[str] = None
    amount: Optional[float] = None
    field_used: Optional[str] = None
    node_name: Optional[str] = None
    comment_id: Optional[str] = None
    error: Optional[str] = None
    processing_info: Optional[Dict[str, Any]] = None

class CacheStatus(BaseModel):
    total_cached_qr: int
    active_cache: Dict[str, Dict[str, Any]]
    cache_duration_minutes: int
    current_time: str

============================================================

============================================================
FILE: app\core\models\shared.py
============================================================
from pydantic import BaseModel
from typing import Optional, List, Dict, Any

class FormField(BaseModel):
    name: Optional[str] = None
    type: Optional[str] = None
    value: Optional[Any] = None

class TaskInfo(BaseModel):
    node_id: Optional[str] = None
    status: Optional[str] = None
    task_id: Optional[str] = None
    node_name: Optional[str] = None

class ApprovalInstance(BaseModel):
    instance_code: str
    status: Optional[str] = None
    form: Optional[str] = None
    task_list: Optional[List[TaskInfo]] = None

============================================================

============================================================
FILE: app\core\routers\monitoring.py
============================================================
from fastapi import APIRouter
from app.core.infrastructure.event_bus import event_bus
from app.core.bootstrap.application import app_bootstrap

router = APIRouter()

@router.get("/system/health")
async def get_system_health():
    """System health check với DDD architecture"""
    return {
        "status": "healthy" if app_bootstrap.is_initialized else "initializing",
        "application": app_bootstrap.get_startup_info(),
        "event_system": {
            "total_event_types": len(event_bus.handlers),
            "registered_events": list(event_bus.handlers.keys()),
            "total_handlers": sum(len(handlers) for handlers in event_bus.handlers.values())
        }
    }

@router.get("/events/history")
async def get_event_history(limit: int = 50):
    """Event processing history"""
    return {
        "recent_events": event_bus.get_event_history(limit),
        "handlers": {
            event_type: [handler.__name__ for handler in handlers]
            for event_type, handlers in event_bus.handlers.items()
        }
    }

@router.post("/events/test/{instance_code}")
async def test_event_processing(instance_code: str):
    """Test event processing system"""
    event_data = {
        "instance_code": instance_code,
        "event_type": "test_event",
        "timestamp": "manual_test"
    }
    
    results = await event_bus.publish("approval.instance.updated", event_data)
    
    return {
        "test_instance": instance_code,
        "handlers_executed": len(results),
        "results": results,
        "architecture": "DDD"
    }

============================================================

============================================================
FILE: app\core\routers\webhook.py
============================================================
from fastapi import APIRouter, Request
from fastapi.responses import JSONResponse
from app.core.infrastructure.event_bus import event_bus
from app.core.utils.helpers import save_event_to_csv, get_event_type, extract_instance_code
from app.core.config.settings import settings

router = APIRouter()

@router.post("/webhook")
async def handle_lark_webhook(request: Request):
    """
    Xử lý webhook từ Lark với kiến trúc DDD

    Chức năng chính:
    - Nhận và xử lý các sự kiện webhook từ Lark
    - Xác thực URL verification cho webhook setup
    - Lưu trữ tất cả events vào file CSV để audit
    - Xử lý các sự kiện phê duyệt qua event bus pattern
    - Trả về response phù hợp cho từng loại event

    Args:
        request (Request): HTTP request chứa webhook data từ Lark

    Returns:
        JSONResponse: 
            - Đối với URL verification: {"challenge": "..."}
            - Đối với events thành công: {"status": "success", "architecture": "DDD"}
            - Đối với lỗi: {"error": "..."} với status 500
    """
    try:
        data = await request.json()
        print(f"📨 Nhận được webhook: {get_event_type(data)}")

        # Xử lý xác thực URL khi setup webhook
        if data.get("type") == "url_verification":
            print("🔐 Đang xử lý URL verification")
            return JSONResponse(content={"challenge": data.get("challenge")})

        print("💾 Đang lưu event vào CSV...")
        await save_event_to_csv(data, settings.EVENTS_FILE)

        # Xử lý các sự kiện phê duyệt thông qua event bus
        event_type = get_event_type(data)
        if "approval" in event_type.lower():
            instance_code = extract_instance_code(data)
            if instance_code:
                print(f"🔍 Đang xử lý instance phê duyệt: {instance_code}")

                # Phát hành event qua event bus - sẽ kích hoạt tất cả handlers đã đăng ký
                print("📡 Đang phát hành event qua event bus...")
                await event_bus.publish("approval.instance.updated", {
                    "instance_code": instance_code,
                    "event_type": event_type,
                    "timestamp": data.get("header", {}).get("create_time"),
                    "raw_data": data
                })
                print("✅ Đã phát hành event thành công")
            else:
                print("⚠️ Không tìm thấy instance code trong event phê duyệt")

        print("🎉 Xử lý webhook hoàn tất")
        return JSONResponse(content={"status": "success", "architecture": "DDD"})

    except Exception as e:
        print(f"❌ Lỗi khi xử lý webhook: {e}")
        return JSONResponse(content={"error": str(e)}, status_code=500)
============================================================

============================================================
FILE: app\core\utils\__init__.py
============================================================
from .helpers import extract_instance_code, get_event_type, format_currency, get_short_node_id
from .field_extractor import FieldExtractor
from .amount_detector import AmountDetector

__all__ = [
    "extract_instance_code", "get_event_type", "format_currency", "get_short_node_id",
    "FieldExtractor", "AmountDetector"
]

============================================================

============================================================
FILE: app\core\utils\amount_detector.py
============================================================
from typing import Dict, List, Optional
from app.core.config.node_config import get_node_config
from app.core.utils.field_extractor import FieldExtractor

class AmountDetector:
    def __init__(self):
        self.field_extractor = FieldExtractor()
    
    def detect_available_amount_fields(self, form_data: List[Dict], node_config: Dict = None) -> Dict:
        """
        Scan form data để tìm amount fields theo config của node
        
        Args:
            form_data (list): Form data từ API response
            node_config (dict): Node configuration (optional)
            
        Returns:
            dict: Detection results với các fields và values
        """
        try:
            # Sử dụng config từ node thay vì hardcode
            if node_config:
                advance_field = node_config.get('advance_field')
                payment_field = node_config.get('payment_field')
            else:
                # Fallback cho backward compatibility
                advance_field = "Số tiền tạm ứng"
                payment_field = "Số tiền thanh toán"
            
            # Extract cả 2 fields (chỉ khi field name không phải None)
            advance_value = self.field_extractor.extract_field_value(form_data, advance_field) if advance_field else None
            payment_value = self.field_extractor.extract_field_value(form_data, payment_field) if payment_field else None
            
            # Debug: tìm tất cả fields có chứa "tiền" hoặc "amount" 
            all_amount_fields = self.field_extractor.get_amount_fields(form_data)
            
            result = {
                'advance_amount': advance_value,
                'payment_amount': payment_value,
                'advance_field_found': advance_value is not None,
                'payment_field_found': payment_value is not None,
                'all_amount_fields': all_amount_fields,
                'fields_used': {
                    'advance_field': advance_field,
                    'payment_field': payment_field
                }
            }
            
            print(f"💰 Field detection results:")
            if advance_field:
                print(f"   - {advance_field}: {'✅ ' + str(advance_value) if advance_value else '❌ Not found'}")
            else:
                print(f"   - Advance field: ❌ Not configured")
                
            if payment_field:
                print(f"   - {payment_field}: {'✅ ' + str(payment_value) if payment_value else '❌ Not found'}")
            else:
                print(f"   - Payment field: ❌ Not configured")
                
            print(f"   - All amount fields: {list(all_amount_fields.keys())}")
            
            return result
            
        except Exception as e:
            print(f"❌ Error detecting amount fields: {e}")
            return {
                'advance_amount': None,
                'payment_amount': None,
                'advance_field_found': False,
                'payment_field_found': False,
                'all_amount_fields': {},
                'fields_used': {'advance_field': None, 'payment_field': None},
                'error': str(e)
            }
    
    def determine_qr_type_by_fields(self, field_detection_result: Dict) -> Dict:
        """
        Quyết định QR type dựa trên fields có giá trị
        
        Args:
            field_detection_result (dict): Kết quả từ detect_available_amount_fields()
            
        Returns:
            dict: QR type decision result
        """
        try:
            advance_found = field_detection_result.get('advance_field_found', False)
            payment_found = field_detection_result.get('payment_field_found', False)
            advance_amount = field_detection_result.get('advance_amount')
            payment_amount = field_detection_result.get('payment_amount')

            fields_used = field_detection_result.get('fields_used', {})
            advance_field_name = fields_used.get('advance_field', 'Số tiền tạm ứng')
            payment_field_name = fields_used.get('payment_field', 'Số tiền thanh toán')

            print(f"🎯 Determining QR type: advance={advance_found}, payment={payment_found}")
            
            # Logic priority: advance trước, sau đó payment
            if advance_found and advance_amount:
                try:
                    amount_value = float(advance_amount)
                    if amount_value > 0:
                        return {
                            'qr_type': 'advance',
                            'amount': amount_value,
                            'field_used': advance_field_name,
                            'reason': 'Found valid advance amount'
                        }
                except (ValueError, TypeError):
                    print(f"⚠️ Invalid advance amount: {advance_amount}")
            
            if payment_found and payment_amount:
                try:
                    amount_value = float(payment_amount)
                    if amount_value > 0:
                        return {
                            'qr_type': 'payment', 
                            'amount': amount_value,
                            'field_used': payment_field_name,
                            'reason': 'Found valid payment amount'
                        }
                except (ValueError, TypeError):
                    print(f"⚠️ Invalid payment amount: {payment_amount}")
            
            # Không tìm thấy field hợp lệ
            return {
                'qr_type': 'none',
                'amount': None,
                'field_used': None,
                'reason': f'No valid amount found (advance_found={advance_found}, payment_found={payment_found})'
            }
            
        except Exception as e:
            print(f"❌ Error determining QR type: {e}")
            return {
                'qr_type': 'none',
                'amount': None,
                'field_used': None,
                'reason': f'Error: {str(e)}'
            }
    
    def get_amount_and_type_for_node(self, node_id: str, form_data: List[Dict]) -> Dict:
        """
        Lấy amount và QR type cho một node cụ thể dựa trên strategy của node đó
        
        Args:
            node_id (str): Node ID
            form_data (list): Form data từ API
            
        Returns:
            dict: Processing result với success, qr_type, amount, etc.
        """
        try:
            node_config = get_node_config(node_id)
            if not node_config:
                return {
                    'success': False,
                    'qr_type': 'none',
                    'error': f'Node {node_id} not found in configuration'
                }
            
            strategy = node_config['strategy']
            node_name = node_config['name']
            
            print(f"🔍 Processing node: {node_name} (strategy: {strategy})")
            
            # Detect available fields
            field_detection = self.detect_available_amount_fields(form_data, node_config)
            
            if strategy == "detect_both_fields":
                # Dual detection: có thể là advance hoặc payment
                qr_decision = self.determine_qr_type_by_fields(field_detection)
                
                return {
                    'success': qr_decision['qr_type'] != 'none',
                    'qr_type': qr_decision['qr_type'],
                    'amount': qr_decision['amount'],
                    'field_used': qr_decision['field_used'],
                    'node_strategy': strategy,
                    'reason': f"Dual detection result: {qr_decision['reason']}",
                    'field_detection': field_detection
                }
                
            elif strategy == "payment_field_only":
                # Payment only: chỉ check payment field
                payment_amount = field_detection.get('payment_amount')
                payment_found = field_detection.get('payment_field_found', False)
                payment_field_name = node_config.get('payment_field')

                if payment_found and payment_amount:
                    try:
                        amount_value = float(payment_amount)
                        if amount_value > 0:
                            return {
                                'success': True,
                                'qr_type': 'payment',
                                'amount': amount_value,
                                'field_used': payment_field_name,
                                'node_strategy': strategy,
                                'reason': 'Payment-only strategy: found valid payment amount',
                                'field_detection': field_detection
                            }
                    except (ValueError, TypeError):
                        pass
                
                return {
                    'success': False,
                    'qr_type': 'none',
                    'amount': None,
                    'field_used': None,
                    'node_strategy': strategy,
                    'reason': f'Payment-only strategy: no valid payment amount (found={payment_found}, value={payment_amount})',
                    'field_detection': field_detection
                }
            
            else:
                return {
                    'success': False,
                    'qr_type': 'none',
                    'error': f'Unknown strategy: {strategy}'
                }
                
        except Exception as e:
            print(f"❌ Error processing node {node_id}: {e}")
            return {
                'success': False,
                'qr_type': 'none',
                'error': str(e)
            }

============================================================

============================================================
FILE: app\core\utils\field_extractor.py
============================================================
from typing import List, Dict, Any, Optional

class FieldExtractor:
    def extract_field_value(self, form_data: List[Dict], field_name: str, debug: bool = False) -> Optional[Any]:
        """
        Enhanced version: Trích xuất giá trị của một field từ form data với better error handling
        
        Args:
            form_data (list): Form data từ API
            field_name (str): Tên field cần tìm
            debug (bool): In debug info
            
        Returns:
            Giá trị field hoặc None nếu không tìm thấy
        """
        try:
            if debug:
                print(f"🔍 Searching for field: '{field_name}'")
                
            # Search in top-level fields
            for field in form_data:
                if field.get('name') == field_name:
                    value = field.get('value')
                    if debug:
                        print(f"✅ Found '{field_name}' in top-level: {value}")
                    return value
                
                # Search in nested fieldList
                if field.get('type') == 'fieldList' and 'value' in field:
                    field_list_values = field['value']
                    if isinstance(field_list_values, list):
                        for field_group in field_list_values:
                            if isinstance(field_group, list):
                                for sub_field in field_group:
                                    if isinstance(sub_field, dict) and sub_field.get('name') == field_name:
                                        value = sub_field.get('value')
                                        if debug:
                                            print(f"✅ Found '{field_name}' in fieldList: {value}")
                                        return value
            
            if debug:
                print(f"❌ Field '{field_name}' not found")
                print("Available fields:", [f.get('name') for f in form_data if f.get('name')])
                
            return None
            
        except Exception as e:
            print(f"❌ Error extracting field '{field_name}': {e}")
            return None

    def get_all_field_names(self, form_data: List[Dict]) -> List[str]:
        """
        Lấy tất cả field names từ form data
        
        Args:
            form_data: Form data từ API
            
        Returns:
            List[str]: Danh sách tên fields
        """
        field_names = []
        
        try:
            for field in form_data:
                field_name = field.get('name')
                if field_name:
                    field_names.append(field_name)
                
                # Check nested fieldList
                if field.get('type') == 'fieldList' and 'value' in field:
                    field_list_values = field['value']
                    if isinstance(field_list_values, list):
                        for field_group in field_list_values:
                            if isinstance(field_group, list):
                                for sub_field in field_group:
                                    if isinstance(sub_field, dict):
                                        sub_field_name = sub_field.get('name')
                                        if sub_field_name:
                                            field_names.append(sub_field_name)
        except Exception as e:
            print(f"❌ Error getting field names: {e}")
        
        return list(set(field_names))  # Remove duplicates

    def get_amount_fields(self, form_data: List[Dict]) -> Dict[str, Any]:
        """
        Tìm tất cả fields có chứa "tiền" hoặc "amount"
        
        Args:
            form_data: Form data từ API
            
        Returns:
            Dict[str, Any]: Dict với field name là key, value là giá trị
        """
        amount_fields = {}
        
        try:
            for field in form_data:
                field_name = field.get('name', '').lower()
                if 'tiền' in field_name or 'amount' in field_name:
                    amount_fields[field.get('name')] = field.get('value')
        except Exception as e:
            print(f"❌ Error getting amount fields: {e}")
        
        return amount_fields

    def extract_field_from_fieldlist(self, form_data: List[Dict], fieldlist_name: str, 
                                target_field_name: str, debug: bool = False) -> Optional[Any]:
        """
        Trích xuất giá trị đầu tiên của một field từ bên trong một fieldList cụ thể.
        
        Hàm này chỉ trả về giá trị đầu tiên tìm thấy. Để lấy tất cả giá trị,
        sử dụng `extract_all_values_from_fieldlist`.
        
        Args:
            form_data: Form data từ API
            fieldlist_name: Tên fieldList container (vd: "Kế toán - Thông tin tạm ứng")  
            target_field_name: Tên field cần tìm (vd: "Số tiền chi")
            debug: In debug info
            
        Returns:
            Giá trị field hoặc None nếu không tìm thấy
        """
        try:
            if debug:
                print(f"🔍 Searching for first '{target_field_name}' in fieldList '{fieldlist_name}'")
                
            if not fieldlist_name or not target_field_name:
                if debug: print("❌ Invalid parameters: fieldlist_name and target_field_name required")
                return None
                
            for field in form_data:
                if field.get('name') == fieldlist_name and field.get('type') == 'fieldList':
                    field_list_values = field.get('value', [])
                    if debug: print(f"📋 Found fieldList '{fieldlist_name}' with {len(field_list_values)} items")
                    
                    for field_group in field_list_values:
                        if isinstance(field_group, list):
                            for sub_field in field_group:
                                if isinstance(sub_field, dict) and sub_field.get('name') == target_field_name:
                                    value = sub_field.get('value')
                                    if debug: print(f"✅ Found first '{target_field_name}' = {value}")
                                    return value
                    
                    if debug: print(f"❌ Field '{target_field_name}' not found in fieldList")
                    return None
            
            if debug:
                print(f"❌ fieldList '{fieldlist_name}' not found")
                available = [f.get('name') for f in form_data if f.get('type') == 'fieldList']
                print(f"Available fieldLists: {available}")
            return None
            
        except Exception as e:
            print(f"❌ Error extracting field from fieldList: {e}")
            return None
            
    def extract_all_values_from_fieldlist(self, form_data: List[Dict], fieldlist_name: str, 
                                          target_field_name: str, debug: bool = False) -> List[Any]:
        """
        ✅ MỚI: Trích xuất TẤT CẢ các giá trị của một field từ TẤT CẢ các dòng trong một fieldList.
        
        Hữu ích khi cần tính tổng các giá trị trong một danh sách, ví dụ như tổng "Số tiền chi"
        từ nhiều lần tạm ứng của kế toán.
        
        Args:
            form_data: Form data từ API.
            fieldlist_name: Tên của fieldList container (ví dụ: "Kế toán - Thông tin tạm ứng").
            target_field_name: Tên của field cần trích xuất giá trị (ví dụ: "Số tiền chi").
            debug: Bật/tắt in thông tin gỡ lỗi.
            
        Returns:
            List[Any]: Một danh sách chứa tất cả các giá trị tìm thấy. Trả về list rỗng nếu không tìm thấy gì.
        """
        extracted_values = []
        try:
            if debug:
                print(f"🔍 Searching for ALL '{target_field_name}' values in fieldList '{fieldlist_name}'")

            for field in form_data:
                if field.get('name') == fieldlist_name and field.get('type') == 'fieldList':
                    field_list_values = field.get('value', [])
                    if debug:
                        print(f"📋 Found fieldList '{fieldlist_name}' with {len(field_list_values)} rows.")
                    
                    # Duyệt qua từng dòng (field_group) trong fieldList
                    for i, field_group in enumerate(field_list_values):
                        if isinstance(field_group, list):
                            # Duyệt qua từng trường (sub_field) trong dòng
                            for sub_field in field_group:
                                if isinstance(sub_field, dict) and sub_field.get('name') == target_field_name:
                                    value = sub_field.get('value')
                                    extracted_values.append(value)
                                    if debug:
                                        print(f"   ✅ Row {i+1}: Found value '{value}'")
                    
                    # Sau khi duyệt xong, không cần tìm nữa
                    if debug:
                        print(f"📊 Total values found: {len(extracted_values)}")
                    return extracted_values
            
            if debug:
                print(f"❌ FieldList '{fieldlist_name}' not found in form data.")
            return extracted_values

        except Exception as e:
            print(f"❌ Error extracting all values from fieldList: {e}")
            return extracted_values

    def extract_fields_by_prefix(self, form_data: List[Dict], prefix: str, debug: bool = False) -> Dict[str, Any]:
        """
        ✅ MỚI: Trích xuất tất cả các trường có tên bắt đầu bằng một tiền tố (prefix) cho trước.
        
        Hữu ích để tìm các trường động như "Số tiền tạm ứng lần 1:", "Số tiền tạm ứng lần 2:",...
        
        Args:
            form_data: Form data từ API.
            prefix: Tiền tố dùng để tìm kiếm (ví dụ: "Số tiền tạm ứng lần").
            debug: Bật/tắt in thông tin gỡ lỗi.
            
        Returns:
            Dict[str, Any]: Một dictionary với key là tên đầy đủ của trường và value là giá trị của nó.
        """
        extracted_fields = {}
        try:
            if debug:
                print(f"🔍 Searching for all fields with prefix: '{prefix}'")
            
            # Duyệt qua tất cả các trường ở mọi cấp độ
            for field in form_data:
                field_name = field.get('name')
                
                # Kiểm tra trường ở cấp cao nhất
                if field_name and field_name.startswith(prefix):
                    value = field.get('value')
                    extracted_fields[field_name] = value
                    if debug:
                        print(f"   ✅ Found top-level field: '{field_name}' = {value}")
                
                # Kiểm tra các trường lồng trong fieldList
                if field.get('type') == 'fieldList' and 'value' in field:
                    field_list_values = field.get('value', [])
                    if isinstance(field_list_values, list):
                        for field_group in field_list_values:
                            if isinstance(field_group, list):
                                for sub_field in field_group:
                                    sub_field_name = sub_field.get('name')
                                    if sub_field_name and sub_field_name.startswith(prefix):
                                        value = sub_field.get('value')
                                        extracted_fields[sub_field_name] = value
                                        if debug:
                                            print(f"   ✅ Found nested field: '{sub_field_name}' = {value}")
            
            if debug:
                print(f"📊 Total fields found with prefix: {len(extracted_fields)}")
            return extracted_fields

        except Exception as e:
            print(f"❌ Error extracting fields by prefix '{prefix}': {e}")
            return extracted_fields
============================================================

============================================================
FILE: app\core\utils\helpers.py
============================================================
from typing import Optional, Dict, Any
from datetime import datetime
import pandas as pd
import json
import os

def extract_instance_code(event_data: Dict) -> Optional[str]:
    """Trích xuất instance_code từ event"""
    try:
        event_body = event_data.get("event", {})
        if "instance_code" in event_body:
            return event_body["instance_code"]
            
        if "object" in event_body and "instance_code" in event_body["object"]:
            return event_body["object"]["instance_code"]
            
        return None
    except:
        return None

def get_event_type(event_data: Dict) -> str:
    """Lấy event type"""
    try:
        if "header" in event_data:
            return event_data["header"].get("event_type", "unknown")
        
        if "event" in event_data and "type" in event_data["event"]:
            return event_data["event"]["type"]
            
        return event_data.get("type", "unknown")
    except:
        return "unknown"

async def save_event_to_csv(event_data: Dict, events_file: str = "lark_events.csv"):
    """Lưu event vào CSV"""
    try:
        row_data = {
            "timestamp": datetime.now().isoformat(),
            "event_type": get_event_type(event_data),
            "instance_code": extract_instance_code(event_data),
            "raw_event": json.dumps(event_data, ensure_ascii=False)
        }
        
        df = pd.DataFrame([row_data])
        
        if os.path.exists(events_file):
            df.to_csv(events_file, mode='a', header=False, index=False, encoding='utf-8')
        else:
            df.to_csv(events_file, mode='w', header=True, index=False, encoding='utf-8')
            
        print(f"✅ Event saved to {events_file}")
        
    except Exception as e:
        print(f"❌ Error saving event: {e}")

def format_currency(amount: float) -> str:
    """Format số tiền theo định dạng VND"""
    return f"{amount:,} VND"

def get_short_node_id(node_id: str, length: int = 8) -> str:
    """Get short version of node ID for display"""
    return node_id[:length] + "..." if len(node_id) > length else node_id

============================================================

============================================================
FILE: app\domains\__init__.py
============================================================
"""
Domain package exports
"""
from app.domains.qr_generation import *
from app.domains.validation import *
from app.domains.notification import *

__all__ = [
    # QR Generation Domain
    "QRRequest", "QRResponse", "QRType", 
    "qr_service", "qr_event_handler",
    
    # Validation Domain  
    "ValidationResult", "ValidationResponse", "ValidationType",
    "validation_service", "validation_event_handler",
    
    # Notification Domain
    "NotificationResult", "NotificationType", "NotificationChannel",
    "notification_coordinator", "lark_webhook_service"
]

============================================================

============================================================
FILE: app\domains\notification\__init__.py
============================================================
# app/domains/notification/__init__.py
from .models import *
from .services import *

__all__ = [
    # Models
    "NotificationType", "NotificationResult", "NotificationRequest",
    # Services
    "lark_webhook_service", "notification_coordinator"
]

============================================================

============================================================
FILE: app\domains\notification\models\__init__.py
============================================================
from .notification import (
    NotificationType,
    NotificationChannel,
    NotificationPriority,
    NotificationRequest,
    NotificationResult,
    ValidationAlertRequest,
    CustomAlertRequest
)

__all__ = [
    "NotificationType",
    "NotificationChannel",
    "NotificationPriority",
    "NotificationRequest", 
    "NotificationResult",
    "ValidationAlertRequest",
    "CustomAlertRequest"
]

============================================================

============================================================
FILE: app\domains\notification\models\notification.py
============================================================
from pydantic import BaseModel
from typing import Optional, List, Dict, Any
from enum import Enum

class NotificationType(str, Enum):
    VALIDATION_ALERT = "validation_alert"
    CUSTOM_ALERT = "custom_alert"
    SERVICE_ERROR = "service_error"
    SYSTEM_NOTIFICATION = "system_notification"

class NotificationChannel(str, Enum):
    LARK_WEBHOOK = "lark_webhook"
    EMAIL = "email"
    SMS = "sms"

class NotificationPriority(str, Enum):
    LOW = "low"
    NORMAL = "normal"
    HIGH = "high"
    URGENT = "urgent"

class NotificationRequest(BaseModel):
    notification_type: NotificationType
    channel: NotificationChannel
    title: str
    message: str
    instance_code: Optional[str] = None
    priority: NotificationPriority = NotificationPriority.NORMAL
    metadata: Optional[Dict[str, Any]] = None

class NotificationResult(BaseModel):
    success: bool
    notification_type: NotificationType
    channel: NotificationChannel
    instance_code: Optional[str] = None
    sent_at: Optional[str] = None
    cached: bool = False
    cache_hit: bool = False
    error: Optional[str] = None
    metadata: Optional[Dict[str, Any]] = None

class ValidationAlertRequest(BaseModel):
    instance_code: str
    serial_number: Optional[str] = None
    validation_errors: List[str]
    priority: NotificationPriority = NotificationPriority.HIGH

class CustomAlertRequest(BaseModel):
    title: str
    message: str
    instance_code: Optional[str] = None
    priority: NotificationPriority = NotificationPriority.NORMAL

============================================================

============================================================
FILE: app\domains\notification\services\__init__.py
============================================================
# app/domains/notification/services/__init__.py
from .lark_webhook_service import lark_webhook_service
from .notification_coordinator import notification_coordinator

__all__ = ["lark_webhook_service", "notification_coordinator"]

============================================================

============================================================
FILE: app\domains\notification\services\lark_webhook_service.py
============================================================
"""
Lark Webhook Service - Dịch vụ gửi thông báo qua Lark webhook
"""
import requests
import json
from typing import List
from datetime import datetime
from app.core.config.settings import settings
from app.domains.notification.models import (
    NotificationResult, NotificationType, NotificationChannel,
    ValidationAlertRequest, CustomAlertRequest
)


class LarkWebhookService:
    """
    Dịch vụ gửi thông báo qua Lark webhook.
    
    Class này cung cấp khả năng gửi các loại thông báo khác nhau đến
    Lark (FeisHu) thông qua webhook API:
    
    - Validation alerts: Cảnh báo khi phát hiện lỗi validation
    - Custom alerts: Thông báo tùy chỉnh cho các sự kiện đặc biệt
    
    Service này hỗ trợ:
    - Format message theo chuẩn Lark webhook API
    - Error handling và retry logic
    - Tracking kết quả gửi với timestamp
    - Integration với notification coordinator
    - Configuration-based enabling/disabling
    
    Attributes:
        webhook_url (str): URL webhook của Lark từ settings
        channel (NotificationChannel): Channel type cho service này
    """
    
    def __init__(self):
        """Khởi tạo LarkWebhookService với cấu hình từ settings."""
        self.webhook_url = settings.LARK_WEBHOOK_URL
        self.channel = NotificationChannel.LARK_WEBHOOK
    
    async def send_validation_alert(self, request: ValidationAlertRequest) -> NotificationResult:
        """
        Gửi cảnh báo validation error qua Lark webhook.
        
        Method này sẽ format và gửi thông báo cảnh báo khi hệ thống
        phát hiện lỗi validation trong quy trình phê duyệt.
        
        Quy trình xử lý:
        1. Kiểm tra cấu hình có enable validation alerts không
        2. Validate webhook URL có được cấu hình không
        3. Format message theo template cảnh báo validation
        4. Gửi HTTP POST request đến Lark webhook
        5. Trả về kết quả với thông tin chi tiết
        
        Args:
            request (ValidationAlertRequest): Request chứa thông tin validation alert
                - instance_code: Mã instance có lỗi validation
                - validation_errors: Danh sách lỗi validation
                - priority: Mức độ ưu tiên của alert
        
        Returns:
            NotificationResult: Kết quả gửi thông báo bao gồm:
                - success: Trạng thái gửi thành công
                - notification_type: VALIDATION_ALERT
                - channel: LARK_WEBHOOK
                - instance_code: Mã instance liên quan
                - sent_at: Thời gian gửi (nếu thành công)
                - error: Thông báo lỗi (nếu thất bại)
                - metadata: Thông tin bổ sung (số lỗi, priority)
        """
        try:
            # Bước 1: Kiểm tra cấu hình có enable validation alerts không
            if not settings.ENABLE_VALIDATION_ALERTS:
                print(f"⚠️ Tính năng cảnh báo validation đã bị tắt, bỏ qua webhook cho {request.instance_code}")
                return NotificationResult(
                    success=True,  # Trả về success vì đã xử lý (disabled)
                    notification_type=NotificationType.VALIDATION_ALERT,
                    channel=self.channel,
                    instance_code=request.instance_code,
                    cached=True,
                    metadata={"disabled": True, "reason": "ENABLE_VALIDATION_ALERTS = False"}
                )
            
            # Bước 2: Kiểm tra webhook URL có được cấu hình không
            if not self.webhook_url:
                print(f"❌ Chưa cấu hình webhook URL cho Lark")
                return NotificationResult(
                    success=False,
                    notification_type=NotificationType.VALIDATION_ALERT,
                    channel=self.channel,
                    instance_code=request.instance_code,
                    error="Chưa cấu hình webhook URL"
                )
            
            # Bước 3: Format danh sách lỗi validation thành text dễ đọc
            print(f"📝 Đang format {len(request.validation_errors)} lỗi validation...")
            error_messages = "\n".join([f"• {error}" for error in request.validation_errors])
            
            # Tạo message data theo format của Lark webhook API
            message_data = {
                "msg_type": "text",
                "content": {
                    "text": f"""⚠️ CẢNH BÁO DỮ LIỆU KHÔNG HỢP LỆ
📄 Request No.: {request.serial_number}
❌ Các lỗi phát hiện:
{error_messages}

🔧 Vui lòng kiểm tra và xử lý."""
                }
            }
            
            # Cấu hình headers cho HTTP request
            headers = {"Content-Type": "application/json"}
            
            # Bước 4: Gửi HTTP POST request đến Lark webhook
            print(f"🚨 Đang gửi cảnh báo validation qua webhook cho {request.instance_code}")
            response = requests.post(
                self.webhook_url, 
                headers=headers, 
                data=json.dumps(message_data),
                timeout=10  # Timeout 10 giây để tránh treo
            )
            
            # Bước 5: Xử lý response và tạo kết quả
            success = response.status_code == 200
            sent_at = datetime.now().isoformat() if success else None
            
            if success:
                print(f"✅ Gửi cảnh báo validation thành công cho {request.instance_code}")
            else:
                print(f"❌ Gửi cảnh báo validation thất bại: HTTP {response.status_code} - {response.text}")
            
            return NotificationResult(
                success=success,
                notification_type=NotificationType.VALIDATION_ALERT,
                channel=self.channel,
                instance_code=request.instance_code,
                sent_at=sent_at,
                error=None if success else f"HTTP {response.status_code}: {response.text}",
                metadata={
                    "errors_count": len(request.validation_errors),
                    "priority": request.priority.value,
                    "response_status": response.status_code
                }
            )
                
        except requests.exceptions.Timeout:
            print(f"⏰ Timeout khi gửi validation webhook (quá 10 giây)")
            return NotificationResult(
                success=False,
                notification_type=NotificationType.VALIDATION_ALERT,
                channel=self.channel,
                instance_code=request.instance_code,
                error="Timeout khi gửi webhook"
            )
        except requests.exceptions.ConnectionError:
            print(f"🔌 Lỗi kết nối khi gửi validation webhook")
            return NotificationResult(
                success=False,
                notification_type=NotificationType.VALIDATION_ALERT,
                channel=self.channel,
                instance_code=request.instance_code,
                error="Lỗi kết nối webhook"
            )
        except Exception as e:
            print(f"❌ Lỗi không xác định khi gửi validation webhook: {e}")
            return NotificationResult(
                success=False,
                notification_type=NotificationType.VALIDATION_ALERT,
                channel=self.channel,
                instance_code=request.instance_code,
                error=str(e)
            )

    async def send_custom_alert(self, request: CustomAlertRequest) -> NotificationResult:
        """
        Gửi thông báo tùy chỉnh qua Lark webhook.
        
        Method này cho phép gửi các thông báo tùy chỉnh với title và message
        do người dùng định nghĩa, phù hợp cho các sự kiện đặc biệt hoặc
        thông báo hệ thống.
        
        Args:
            request (CustomAlertRequest): Request chứa thông tin custom alert
                - title: Tiêu đề thông báo
                - message: Nội dung thông báo
                - instance_code: Mã instance liên quan (optional)
                - priority: Mức độ ưu tiên
        
        Returns:
            NotificationResult: Kết quả gửi thông báo tương tự send_validation_alert
        """
        try:
            # Bước 1: Kiểm tra cấu hình và webhook URL
            if not settings.ENABLE_VALIDATION_ALERTS or not self.webhook_url:
                print(f"❌ Alerts bị tắt hoặc chưa cấu hình webhook URL")
                return NotificationResult(
                    success=False,
                    notification_type=NotificationType.CUSTOM_ALERT,
                    channel=self.channel,
                    instance_code=request.instance_code,
                    error="Alerts bị tắt hoặc chưa cấu hình webhook URL"
                )
            
            # Bước 2: Format message với title và nội dung tùy chỉnh
            print(f"📝 Đang tạo custom alert: {request.title}")
            alert_text = f"""🔔 {request.title}"""
            
            # Thêm instance code nếu có
            if request.instance_code:
                alert_text += f"\n📄 Instance: {request.instance_code}"
                
            alert_text += f"\n📢 {request.message}"
            
            # Tạo message data cho Lark webhook
            message_data = {
                "msg_type": "text",
                "content": {"text": alert_text}
            }
            
            # Bước 3: Gửi HTTP request
            print(f"📤 Đang gửi custom alert qua webhook...")
            headers = {"Content-Type": "application/json"}
            response = requests.post(
                self.webhook_url, 
                headers=headers, 
                data=json.dumps(message_data),
                timeout=10
            )
            
            # Bước 4: Xử lý kết quả
            success = response.status_code == 200
            sent_at = datetime.now().isoformat() if success else None
            
            if success:
                print(f"✅ Gửi custom alert thành công: {request.title}")
            else:
                print(f"❌ Gửi custom alert thất bại: HTTP {response.status_code} - {response.text}")
            
            return NotificationResult(
                success=success,
                notification_type=NotificationType.CUSTOM_ALERT,
                channel=self.channel,
                instance_code=request.instance_code,
                sent_at=sent_at,
                error=None if success else f"HTTP {response.status_code}: {response.text}",
                metadata={
                    "title": request.title,
                    "priority": request.priority.value,
                    "has_instance_code": request.instance_code is not None,
                    "response_status": response.status_code
                }
            )
            
        except requests.exceptions.Timeout:
            print(f"⏰ Timeout khi gửi custom alert webhook")
            return NotificationResult(
                success=False,
                notification_type=NotificationType.CUSTOM_ALERT,
                channel=self.channel,
                instance_code=request.instance_code,
                error="Timeout khi gửi webhook"
            )
        except requests.exceptions.ConnectionError:
            print(f"🔌 Lỗi kết nối khi gửi custom alert webhook")
            return NotificationResult(
                success=False,
                notification_type=NotificationType.CUSTOM_ALERT,
                channel=self.channel,
                instance_code=request.instance_code,
                error="Lỗi kết nối webhook"
            )
        except Exception as e:
            print(f"❌ Lỗi khi gửi custom alert: {e}")
            return NotificationResult(
                success=False,
                notification_type=NotificationType.CUSTOM_ALERT,
                channel=self.channel,
                instance_code=request.instance_code,
                error=str(e)
            )


lark_webhook_service = LarkWebhookService()
============================================================

============================================================
FILE: app\domains\notification\services\notification_coordinator.py
============================================================
"""
Notification Coordinator - Bộ điều phối trung tâm cho tất cả kênh thông báo
"""
from typing import List, Dict, Any
from app.domains.notification.models import (
    NotificationRequest, NotificationResult, NotificationType, 
    NotificationChannel, ValidationAlertRequest, CustomAlertRequest
)
from app.domains.notification.services.lark_webhook_service import lark_webhook_service
from app.core.infrastructure.cache_service import cache_service


class NotificationCoordinator:
    """
    Bộ điều phối trung tâm cho tất cả các kênh thông báo.
    
    Class này hoạt động như một central hub để:
    1. Quản lý và điều phối các kênh thông báo khác nhau (Lark, Email, SMS, etc.)
    2. Ngăn chặn duplicate notifications thông qua caching mechanism
    3. Route notifications đến đúng service dựa trên channel và type
    4. Cung cấp interface thống nhất cho việc gửi thông báo
    5. Track và log kết quả gửi thông báo
    
    Supported channels:
    - LARK_WEBHOOK: Gửi thông báo qua Lark webhook
    - Có thể mở rộng thêm EMAIL, SMS, SLACK, etc.
    
    Supported notification types:
    - VALIDATION_ALERT: Cảnh báo validation errors
    - CUSTOM_ALERT: Cảnh báo tùy chỉnh
    - QR_GENERATION: Thông báo tạo QR (tương lai)
    
    Attributes:
        channels (Dict): Map từ notification channel đến service implementation
    """
    
    def __init__(self):
        """Khởi tạo NotificationCoordinator với các kênh thông báo được hỗ trợ."""
        # Mapping từ notification channel đến service implementation
        # Dễ dàng mở rộng thêm channels mới trong tương lai
        self.channels = {
            NotificationChannel.LARK_WEBHOOK: lark_webhook_service
            # Có thể thêm:
            # NotificationChannel.EMAIL: email_service,
            # NotificationChannel.SMS: sms_service,
            # NotificationChannel.SLACK: slack_service,
        }
    
    async def send_notification(self, request: NotificationRequest) -> NotificationResult:
        """
        Gửi thông báo qua kênh được chỉ định với tính năng chống trùng lặp.
        
        Đây là method chính của coordinator, thực hiện:
        1. Kiểm tra duplicate notifications dựa trên cache
        2. Validate và route đến đúng channel service  
        3. Gọi method phù hợp dựa trên notification type
        4. Cache kết quả để tránh duplicate trong tương lai
        5. Trả về kết quả chi tiết cho monitoring
        
        Args:
            request (NotificationRequest): Request chứa thông tin notification cần gửi
            
        Returns:
            NotificationResult: Kết quả gửi thông báo bao gồm:
                - success (bool): Trạng thái gửi thành công
                - notification_type: Loại thông báo
                - channel: Kênh đã sử dụng
                - instance_code: Mã instance liên quan
                - cached (bool): Có được cache không
                - cache_hit (bool): Có bị skip do cache không
                - error (str): Thông báo lỗi nếu có
                - metadata (Dict): Thông tin bổ sung
        """
        
        # Bước 1: Kiểm tra duplicate notifications dựa trên cache
        if request.instance_code:
            # Tạo cache key duy nhất cho combination của type và instance
            cache_key = f"{request.notification_type.value}_{request.instance_code}"
            
            print(f"🔍 Kiểm tra duplicate notification cho: {cache_key}")
            
            # Kiểm tra xem đã gửi notification tương tự gần đây chưa
            if cache_service.is_validation_alert_recently_sent(
                request.instance_code, 
                request.notification_type.value,
                cache_duration_minutes=10
            ):
                print(f"🔄 PHÁT HIỆN THÔNG BÁO TRÙNG LẶP: {cache_key}")
                print(f"   → BỎ QUA gửi thông báo để tránh spam")
                
                return NotificationResult(
                    success=True,  # Trả về success vì đã xử lý (cached)
                    notification_type=request.notification_type,
                    channel=request.channel,
                    instance_code=request.instance_code,
                    cached=True,
                    cache_hit=True,
                    metadata={
                        "reason": "duplicate_prevention",
                        "cache_key": cache_key,
                        "cache_duration_minutes": 10
                    }
                )
        
        # Bước 2: Validate và lấy channel service
        print(f"📡 Đang định tuyến đến kênh: {request.channel.value}")
        channel_service = self.channels.get(request.channel)
        
        if not channel_service:
            print(f"❌ Kênh không được hỗ trợ: {request.channel.value}")
            return NotificationResult(
                success=False,
                notification_type=request.notification_type,
                channel=request.channel,
                instance_code=request.instance_code,
                error=f"Kênh không được hỗ trợ: {request.channel.value}",
                metadata={
                    "available_channels": list(self.channels.keys())
                }
            )
        
        # Bước 3: Route đến method phù hợp dựa trên notification type
        print(f"🎯 Xử lý loại thông báo: {request.notification_type.value}")
        
        if request.notification_type == NotificationType.VALIDATION_ALERT:
            # Xử lý validation alert
            print(f"🔔 Tạo validation alert request...")
            alert_request = ValidationAlertRequest(
                instance_code=request.instance_code,
                validation_errors=[request.message],
                priority=request.priority
            )
            
            print(f"📤 Đang gửi validation alert qua {request.channel.value}...")
            result = await channel_service.send_validation_alert(alert_request)
        
        elif request.notification_type == NotificationType.CUSTOM_ALERT:
            # Xử lý custom alert
            print(f"🎨 Tạo custom alert request...")
            alert_request = CustomAlertRequest(
                title=request.title,
                message=request.message,
                instance_code=request.instance_code,
                priority=request.priority
            )
            
            print(f"📤 Đang gửi custom alert qua {request.channel.value}...")
            result = await channel_service.send_custom_alert(alert_request)
        
        else:
            # Notification type không được hỗ trợ
            print(f"❌ Loại thông báo không được hỗ trợ: {request.notification_type.value}")
            return NotificationResult(
                success=False,
                notification_type=request.notification_type,
                channel=request.channel,
                instance_code=request.instance_code,
                error=f"Loại thông báo không được hỗ trợ: {request.notification_type.value}",
                metadata={
                    "available_types": [nt.value for nt in NotificationType]
                }
            )
        
        # Bước 4: Xử lý kết quả và cache nếu thành công
        if result.success and request.instance_code:
            print(f"✅ Gửi thông báo thành công - đánh dấu cache")
            
            # Đánh dấu đã gửi trong cache để tránh duplicate
            cache_service.mark_validation_alert_as_sent(
                request.instance_code, 
                request.notification_type.value
            )
            
            print(f"💾 Đã lưu vào cache để tránh duplicate trong 10 phút")
        elif result.success:
            print(f"✅ Gửi thông báo thành công (không có instance_code để cache)")
        else:
            print(f"❌ Gửi thông báo thất bại: {getattr(result, 'error', 'Lỗi không xác định')}")
        
        return result


# Instance toàn cục của coordinator để sử dụng trong toàn bộ hệ thống
notification_coordinator = NotificationCoordinator()
============================================================

============================================================
FILE: app\domains\qr_generation\__init__.py
============================================================
from .models import *
from .services import *
from .handlers import *

__all__ = [
    # Models
    "QRType", "BankInfo", "QRGenerationResult",
    # Services  
    "vietqr_service", "qr_processor",
    # Handlers
    "qr_event_handler"
]

============================================================

============================================================
FILE: app\domains\qr_generation\handlers\__init__.py
============================================================
from .qr_event_handler import qr_event_handler

__all__ = ["qr_event_handler"]

============================================================

============================================================
FILE: app\domains\qr_generation\handlers\qr_event_handler.py
============================================================
from typing import Dict
from app.core.infrastructure.lark_service import lark_service
from app.domains.qr_generation.services.qr_processor import qr_processor

class QREventHandler:
    """
    Bộ xử lý sự kiện tạo mã QR cho hệ thống phê duyệt Lark.
    
    Class này hoạt động như một event handler độc lập, nhận và xử lý
    các sự kiện phê duyệt để tự động tạo mã VietQR tương ứng.
    
    Quy trình xử lý:
    1. Nhận sự kiện phê duyệt từ hệ thống
    2. Trích xuất instance_code từ event data
    3. Lấy access token để gọi Lark API
    4. Gửi đến QRProcessor để xử lý tạo QR
    5. Trả về kết quả xử lý
    
    Attributes:
        name (str): Tên định danh của service ("QR_Generator")
    """
    
    def __init__(self):
        """Khởi tạo QREventHandler với tên service."""
        self.name = "QR_Generator"
    
    async def handle_approval_event(self, event_data: Dict) -> Dict:
        """
        Xử lý sự kiện phê duyệt để tạo mã QR tự động.
        
        [NÂNG CẤP] Bổ sung logic kiểm tra trạng thái đơn. Sẽ bỏ qua xử lý
        nếu đơn ở trạng thái cuối cùng như REJECTED, CANCELED, DELETED.
        
        Đây là method chính của handler, hoạt động hoàn toàn độc lập
        và không phụ thuộc vào các service khác. Method sẽ:
        
        1. Validate dữ liệu đầu vào (instance_code)
        2. Lấy access token từ Lark service
        3. Gọi QRProcessor để xử lý business logic
        4. Trả về kết quả chi tiết cho monitoring
        
        Args:
            event_data (Dict): Dữ liệu sự kiện chứa thông tin phê duyệt.
                             Bắt buộc phải có 'instance_code'
        
        Returns:
            Dict: Kết quả xử lý bao gồm:
                - success (bool): Trạng thái xử lý thành công
                - message (str): Thông báo chi tiết kết quả
                - instance_code (str): Mã instance đã xử lý (nếu có)
                - service (str): Tên service thực hiện
        
        Raises:
            Exception: Các lỗi không xác định sẽ được bắt và trả về trong response
        """
        try:
            # Bước 1: Validate và trích xuất instance_code từ event data
            instance_code = event_data.get('instance_code')
            if not instance_code:
                print(f"❌ [QR Handler] Thiếu instance_code trong dữ liệu sự kiện")
                return {
                    "success": False,
                    "message": "Không tìm thấy instance_code trong dữ liệu sự kiện", 
                    "service": self.name
                }
            
            # [THÊM MỚI] Bắt đầu khối logic kiểm tra trạng thái
            FINAL_STATUSES = ['REJECTED', 'CANCELED', 'DELETED']

            # Trích xuất trạng thái từ dữ liệu gốc của sự kiện để tránh gọi API không cần thiết
            raw_data = event_data.get('raw_data', {})
            instance_status = raw_data.get('event', {}).get('object', {}).get('status')
            
            # Kiểm tra xem trạng thái của đơn có nằm trong danh sách cần bỏ qua không
            if instance_status and instance_status in FINAL_STATUSES:
                print(f"⏭️ [QR Handler] Bỏ qua instance {instance_code} do có trạng thái cuối cùng: {instance_status}")
                return {
                    "success": True, # Coi như thành công vì đã xử lý đúng (bỏ qua)
                    "message": f"Bỏ qua xử lý do trạng thái đơn là {instance_status}",
                    "instance_code": instance_code,
                    "service": self.name
                }
            # [THÊM MỚI] Kết thúc khối logic kiểm tra trạng thái
            
            print(f"🏦 [QR Handler] Dịch vụ QR đang xử lý instance: {instance_code} (Trạng thái: {instance_status or 'N/A'})")
            
            # Bước 2: Lấy access token để gọi Lark API
            print(f"🔑 Đang lấy access token từ Lark...")
            access_token = await lark_service.get_access_token()
            if not access_token:
                print(f"❌ Không thể lấy access token từ Lark")
                return {
                    "success": False,
                    "message": "Không thể lấy access token từ Lark",
                    "service": self.name
                }
            
            print(f"✅ Đã lấy access token thành công")
            
            # Bước 3: Gửi đến QRProcessor để xử lý business logic chính
            print(f"⚙️ Bắt đầu xử lý tạo QR cho {instance_code}...")
            result = await qr_processor.process_approval_with_qr_comment(
                instance_code, access_token
            )
            
            # Bước 4: Tạo response với thông tin chi tiết
            if result:
                print(f"✅ [QR Handler] Hoàn thành xử lý QR cho {instance_code}")
                return {
                    "success": True,
                    "message": f"Xử lý QR hoàn thành thành công cho {instance_code}",
                    "instance_code": instance_code,
                    "service": self.name
                }
            else:
                print(f"❌ [QR Handler] Xử lý QR thất bại cho {instance_code}")
                return {
                    "success": False,
                    "message": f"Xử lý QR thất bại cho {instance_code}",
                    "instance_code": instance_code,
                    "service": self.name
                }
            
        except Exception as e:
            # Bắt tất cả exception không xác định để tránh crash service
            print(f"❌ Lỗi không xác định trong QR Service: {str(e)}")
            import traceback
            print(f"📋 Chi tiết lỗi:\n{traceback.format_exc()}")
            
            return {
                "success": False,
                "message": f"Lỗi QR Service: {str(e)}",
                "service": self.name,
                "error_type": type(e).__name__
            }

qr_event_handler = QREventHandler()
============================================================

============================================================
FILE: app\domains\qr_generation\models\__init__.py
============================================================
from .qr import (
    QRType,
    BankInfo,
    AmountDetectionResult,
    QRTypeResult,
    NodeProcessingResult,
    QRGenerationRequest,
    QRGenerationResult
)

__all__ = [
    "QRType",
    "BankInfo", 
    "AmountDetectionResult",
    "QRTypeResult",
    "NodeProcessingResult",
    "QRGenerationRequest",
    "QRGenerationResult"
]

============================================================

============================================================
FILE: app\domains\qr_generation\models\qr.py
============================================================
from pydantic import BaseModel
from typing import Optional, Dict, Any
from enum import Enum

class QRType(str, Enum):
    ADVANCE = "advance"
    PAYMENT = "payment"
    NONE = "none"

class BankInfo(BaseModel):
    bank_id: str
    account_no: str
    account_name: str

class AmountDetectionResult(BaseModel):
    advance_amount: Optional[float] = None
    payment_amount: Optional[float] = None
    advance_field_found: bool = False
    payment_field_found: bool = False
    all_amount_fields: Dict[str, Any] = {}
    fields_used: Dict[str, Optional[str]] = {}

class QRTypeResult(BaseModel):
    qr_type: QRType
    amount: Optional[float] = None
    field_used: Optional[str] = None
    reason: str

class NodeProcessingResult(BaseModel):
    success: bool
    qr_type: QRType = QRType.NONE
    amount: Optional[float] = None
    field_used: Optional[str] = None
    node_strategy: Optional[str] = None
    reason: Optional[str] = None
    error: Optional[str] = None
    field_detection: Optional[AmountDetectionResult] = None

class QRGenerationRequest(BaseModel):
    instance_code: str
    node_id: str
    qr_type: QRType
    amount: int
    bank_info: BankInfo
    description: str

class QRGenerationResult(BaseModel):
    success: bool
    qr_type: Optional[QRType] = None
    amount: Optional[float] = None
    field_used: Optional[str] = None
    node_name: Optional[str] = None
    comment_id: Optional[str] = None
    error: Optional[str] = None
    processing_info: Optional[Dict[str, Any]] = None

============================================================

============================================================
FILE: app\domains\qr_generation\routers\qr.py
============================================================
from fastapi import APIRouter, Depends
from app.domains.qr_generation.models import QRGenerationResult
from app.domains.qr_generation.services.qr_processor import qr_processor
from app.core.infrastructure.lark_service import lark_service

router = APIRouter(prefix="/qr", tags=["QR Generation"])

@router.post("/process/{instance_code}", response_model=QRGenerationResult)
async def manual_process_qr(instance_code: str):
    """Enhanced manual QR processing với domain models"""
    try:
        access_token = await lark_service.get_access_token()
        if not access_token:
            return QRGenerationResult(
                success=False,
                error="Cannot get access token"
            )
        
        # Process the instance
        result = await qr_processor.process_approval_with_qr_comment(instance_code, access_token)
        
        return QRGenerationResult(
            success=result,
            processing_info={
                "instance_code": instance_code,
                "processed": result
            }
        )
            
    except Exception as e:
        return QRGenerationResult(
            success=False,
            error=str(e)
        )

@router.get("/cache/status")
async def get_qr_cache_status():
    """Xem trạng thái QR cache"""
    from app.core.infrastructure.cache_service import cache_service
    cache_status = cache_service.get_cache_status()
    return cache_status.get('qr_cache', {})

@router.post("/cache/clear")
async def clear_qr_cache():
    """Clear QR cache"""
    from app.core.infrastructure.cache_service import cache_service
    result = cache_service.clear_cache()
    return {
        "message": "QR cache cleared",
        "details": result
    }

============================================================

============================================================
FILE: app\domains\qr_generation\services\__init__.py
============================================================
from .vietqr_service import vietqr_service
from .amount_detector import AmountDetector
from .qr_processor import qr_processor

__all__ = [
    "vietqr_service",
    "AmountDetector", 
    "qr_processor"
]

============================================================

============================================================
FILE: app\domains\qr_generation\services\amount_detector.py
============================================================
from typing import Dict, List, Optional
from app.core.config.node_config import get_node_config
from app.core.config.field_constants import FFN
from app.core.utils.field_extractor import FieldExtractor
from app.domains.qr_generation.models import AmountDetectionResult, QRTypeResult, QRType


class AmountDetector:
    """
    Bộ phát hiện và xác định số tiền cho việc tạo mã QR.

    Class này chịu trách nhiệm phân tích dữ liệu form để:
    - Tìm kiếm các trường chứa thông tin số tiền
    - Xác định loại QR (tạm ứng hoặc thanh toán) dựa trên node strategy
    - Validate và trả về số tiền phù hợp cho từng node

    Hỗ trợ nhiều chiến lược xử lý khác nhau:
    - detect_both_fields: Phát hiện cả tạm ứng và thanh toán
    - payment_field_only: Chỉ xử lý trường thanh toán

    Attributes:
        field_extractor (FieldExtractor): Công cụ trích xuất dữ liệu từ form
    """

    def __init__(self):
        """Khởi tạo AmountDetector với FieldExtractor."""
        self.field_extractor = FieldExtractor()

    def detect_available_amount_fields(self, form_data: List[Dict], node_config: Dict = None) -> Dict:
        """
        Quét dữ liệu form để tìm các trường số tiền theo cấu hình node.
        
        Phương thức này sẽ tìm kiếm các trường tạm ứng và thanh toán dựa trên
        cấu hình của node. Nếu không có cấu hình, sẽ sử dụng tên trường mặc định.
        
        Args:
            form_data (List[Dict]): Dữ liệu form từ API response của Lark
            node_config (Dict, optional): Cấu hình node chứa tên các trường cần tìm
            
        Returns:
            Dict: Kết quả phát hiện bao gồm:
                - advance_amount: Giá trị số tiền tạm ứng
                - payment_amount: Giá trị số tiền thanh toán  
                - advance_field_found: Có tìm thấy trường tạm ứng không
                - payment_field_found: Có tìm thấy trường thanh toán không
                - all_amount_fields: Tất cả trường chứa từ khóa tiền
                - fields_used: Tên các trường đã sử dụng để tìm kiếm
        """
        try:
            # Lấy tên trường từ cấu hình node hoặc sử dụng giá trị mặc định
            if node_config:
                advance_field = node_config.get('advance_field')
                payment_field = node_config.get('payment_field')
            else:
                # Giá trị mặc định để tương thích ngược
                advance_field = FFN.ADVANCE_AMOUNT
                payment_field = FFN.PAYMENT_AMOUNT
            
            # Trích xuất giá trị từ cả 2 trường (chỉ khi tên trường không phải None)
            advance_value = None
            payment_value = None
            
            if advance_field:
                advance_value = self.field_extractor.extract_field_value(form_data, advance_field)
            
            if payment_field:
                payment_value = self.field_extractor.extract_field_value(form_data, payment_field)
            
            # Debug: Tìm tất cả trường có chứa từ khóa "tiền" hoặc "amount"
            all_amount_fields = self.field_extractor.get_amount_fields(form_data)
            
            # Tạo kết quả chi tiết
            result = {
                'advance_amount': advance_value,
                'payment_amount': payment_value,
                'advance_field_found': advance_value is not None,
                'payment_field_found': payment_value is not None,
                'all_amount_fields': all_amount_fields,
                'fields_used': {
                    'advance_field': advance_field,
                    'payment_field': payment_field
                }
            }
            
            # Hiển thị kết quả phát hiện trường
            print(f"💰 Kết quả phát hiện trường số tiền:")
            if advance_field:
                status = f"✅ {advance_value}" if advance_value else "❌ Không tìm thấy"
                print(f"   - {advance_field}: {status}")
            else:
                print(f"   - Trường tạm ứng: ❌ Chưa được cấu hình")
                
            if payment_field:
                status = f"✅ {payment_value}" if payment_value else "❌ Không tìm thấy"
                print(f"   - {payment_field}: {status}")
            else:
                print(f"   - Trường thanh toán: ❌ Chưa được cấu hình")
                
            print(f"   - Tất cả trường số tiền: {list(all_amount_fields.keys())}")
            
            return result
            
        except Exception as e:
            print(f"❌ Lỗi khi phát hiện trường số tiền: {e}")
            return {
                'advance_amount': None,
                'payment_amount': None,
                'advance_field_found': False,
                'payment_field_found': False,
                'all_amount_fields': {},
                'fields_used': {'advance_field': None, 'payment_field': None},
                'error': str(e)
            }

    def determine_qr_type_by_fields(self, field_detection_result: Dict) -> Dict:
        """
        Xác định loại QR dựa trên các trường có giá trị hợp lệ.
        
        Logic ưu tiên: Tạm ứng được ưu tiên trước, sau đó đến thanh toán.
        Chỉ chọn trường có giá trị số hợp lệ và lớn hơn 0.
        
        Args:
            field_detection_result (Dict): Kết quả từ detect_available_amount_fields()
            
        Returns:
            Dict: Kết quả quyết định loại QR bao gồm:
                - qr_type: Loại QR ('advance', 'payment', hoặc 'none')
                - amount: Số tiền đã chọn
                - field_used: Tên trường đã sử dụng
                - reason: Lý do quyết định
        """
        try:
            # Trích xuất thông tin từ kết quả phát hiện trường
            advance_found = field_detection_result.get('advance_field_found', False)
            payment_found = field_detection_result.get('payment_field_found', False)
            advance_amount = field_detection_result.get('advance_amount')
            payment_amount = field_detection_result.get('payment_amount')

            # Lấy tên trường để hiển thị trong kết quả
            fields_used = field_detection_result.get('fields_used', {})
            advance_field_name = fields_used.get('advance_field', FFN.ADVANCE_AMOUNT)
            payment_field_name = fields_used.get('payment_field', FFN.PAYMENT_AMOUNT)

            print(f"🎯 Đang xác định loại QR: tạm_ứng={advance_found}, thanh_toán={payment_found}")
            
            # Logic ưu tiên: Kiểm tra tạm ứng trước
            if advance_found and advance_amount:
                try:
                    amount_value = float(advance_amount)
                    if amount_value > 0:
                        print(f"✅ Chọn tạm ứng: {amount_value:,} VND")
                        return {
                            'qr_type': 'advance',
                            'amount': amount_value,
                            'field_used': advance_field_name,
                            'reason': 'Tìm thấy số tiền tạm ứng hợp lệ'
                        }
                except (ValueError, TypeError):
                    print(f"⚠️ Số tiền tạm ứng không hợp lệ: {advance_amount}")
            
            # Nếu không có tạm ứng, kiểm tra thanh toán
            if payment_found and payment_amount:
                try:
                    amount_value = float(payment_amount)
                    if amount_value > 0:
                        print(f"✅ Chọn thanh toán: {amount_value:,} VND")
                        return {
                            'qr_type': 'payment', 
                            'amount': amount_value,
                            'field_used': payment_field_name,
                            'reason': 'Tìm thấy số tiền thanh toán hợp lệ'
                        }
                except (ValueError, TypeError):
                    print(f"⚠️ Số tiền thanh toán không hợp lệ: {payment_amount}")
            
            # Không tìm thấy trường hợp lệ nào
            print(f"❌ Không tìm thấy số tiền hợp lệ")
            return {
                'qr_type': 'none',
                'amount': None,
                'field_used': None,
                'reason': f'Không tìm thấy số tiền hợp lệ (tạm_ứng={advance_found}, thanh_toán={payment_found})'
            }
            
        except Exception as e:
            print(f"❌ Lỗi khi xác định loại QR: {e}")
            return {
                'qr_type': 'none',
                'amount': None,
                'field_used': None,
                'reason': f'Lỗi: {str(e)}'
            }

    def get_amount_and_type_for_node(self, node_id: str, form_data: List[Dict]) -> Dict:
        """
        Lấy số tiền và loại QR cho một node cụ thể dựa trên chiến lược của node.
        
        Đây là phương thức chính để xử lý node, sẽ:
        1. Lấy cấu hình node từ node_id
        2. Áp dụng chiến lược phù hợp (detect_both_fields hoặc payment_field_only)
        3. Phân tích form data và trả về kết quả
        
        Args:
            node_id (str): ID của node cần xử lý
            form_data (List[Dict]): Dữ liệu form từ Lark API
            
        Returns:
            Dict: Kết quả xử lý bao gồm:
                - success (bool): Xử lý thành công hay không
                - qr_type (str): Loại QR đã xác định
                - amount (float): Số tiền cho QR
                - field_used (str): Trường đã sử dụng
                - node_strategy (str): Chiến lược của node
                - reason (str): Lý do kết quả
                - field_detection (Dict): Chi tiết phát hiện trường
        """
        try:
            # Lấy cấu hình node từ hệ thống
            node_config = get_node_config(node_id)
            if not node_config:
                print(f"❌ Không tìm thấy cấu hình cho node {node_id}")
                return {
                    'success': False,
                    'qr_type': 'none',
                    'error': f'Không tìm thấy node {node_id} trong cấu hình'
                }
            
            # Trích xuất thông tin node
            strategy = node_config['strategy']
            node_name = node_config['name']
            
            print(f"🔍 Đang xử lý node: {node_name} (chiến lược: {strategy})")
            
            # Phát hiện các trường có sẵn trong form
            field_detection = self.detect_available_amount_fields(form_data, node_config)
            
            # Áp dụng chiến lược xử lý theo cấu hình
            if strategy == "detect_both_fields":
                # Chiến lược phát hiện kép: có thể là tạm ứng hoặc thanh toán
                print(f"📋 Áp dụng chiến lược phát hiện kép")
                qr_decision = self.determine_qr_type_by_fields(field_detection)
                
                return {
                    'success': qr_decision['qr_type'] != 'none',
                    'qr_type': qr_decision['qr_type'],
                    'amount': qr_decision['amount'],
                    'field_used': qr_decision['field_used'],
                    'node_strategy': strategy,
                    'reason': f"Kết quả phát hiện kép: {qr_decision['reason']}",
                    'field_detection': field_detection
                }
                
            elif strategy == "payment_field_only":
                # Chiến lược chỉ thanh toán: chỉ kiểm tra trường thanh toán
                print(f"💳 Áp dụng chiến lược chỉ thanh toán")
                payment_amount = field_detection.get('payment_amount')
                payment_found = field_detection.get('payment_field_found', False)
                payment_field_name = node_config.get('payment_field')

                if payment_found and payment_amount:
                    try:
                        amount_value = float(payment_amount)
                        if amount_value > 0:
                            print(f"✅ Tìm thấy số tiền thanh toán hợp lệ: {amount_value:,} VND")
                            return {
                                'success': True,
                                'qr_type': 'payment',
                                'amount': amount_value,
                                'field_used': payment_field_name,
                                'node_strategy': strategy,
                                'reason': 'Chiến lược chỉ thanh toán: tìm thấy số tiền hợp lệ',
                                'field_detection': field_detection
                            }
                    except (ValueError, TypeError):
                        print(f"⚠️ Số tiền thanh toán không hợp lệ: {payment_amount}")
                
                print(f"❌ Không tìm thấy số tiền thanh toán hợp lệ")
                return {
                    'success': False,
                    'qr_type': 'none',
                    'amount': None,
                    'field_used': None,
                    'node_strategy': strategy,
                    'reason': f'Chiến lược chỉ thanh toán: không có số tiền hợp lệ (tìm_thấy={payment_found}, giá_trị={payment_amount})',
                    'field_detection': field_detection
                }
            
            else:
                print(f"❌ Chiến lược không xác định: {strategy}")
                return {
                    'success': False,
                    'qr_type': 'none',
                    'error': f'Chiến lược không xác định: {strategy}'
                }
                
        except Exception as e:
            print(f"❌ Lỗi khi xử lý node {node_id}: {e}")
            return {
                'success': False,
                'qr_type': 'none',
                'error': str(e)
            }
============================================================

============================================================
FILE: app\domains\qr_generation\services\qr_processor.py
============================================================
import json
from app.core.config.settings import settings
# NODE_CONFIG và AmountDetector không còn cần thiết cho logic chính, nhưng giữ lại import để không ảnh hưởng các hàm phụ
from app.core.config.node_config import NODE_CONFIG
from app.core.config.field_constants import FFN
from app.core.infrastructure.lark_service import lark_service
from app.core.infrastructure.cache_service import cache_service
from app.core.utils.field_extractor import FieldExtractor
from app.domains.qr_generation.services.vietqr_service import vietqr_service
# AmountDetector không còn được sử dụng trong hàm chính nữa
# from app.domains.qr_generation.services.amount_detector import AmountDetector
from app.domains.qr_generation.models import QRType, BankInfo

class QRProcessor:
    """
    Bộ xử lý QR chính - Quản lý logic nghiệp vụ tạo và xử lý mã QR cho hệ thống phê duyệt.
    
    Class này xử lý toàn bộ quy trình từ việc kiểm tra node phê duyệt, trích xuất dữ liệu,
    validate thông tin, tạo mã VietQR và upload lên hệ thống Lark.
    
    Attributes:
        field_extractor (FieldExtractor): Bộ trích xuất trường dữ liệu từ form
    """

    def __init__(self):
        """Khởi tạo QRProcessor với các service cần thiết."""
        self.field_extractor = FieldExtractor()
        # self.amount_detector không còn cần thiết nữa
        # self.amount_detector = AmountDetector()

    # --- HÀM CŨ NÀY VẪN GIỮ LẠI NHƯNG KHÔNG ĐƯỢC GỌI TRONG HÀM CHÍNH ---
    def check_pending_allowed_node_in_task_list(self, api_response: dict, node_config: dict = None) -> dict:
        """
        Kiểm tra node có trạng thái phù hợp và đáp ứng các điều kiện bổ sung.
        (Hàm này không còn được sử dụng trong luồng chính tạo QR động)
        """
        if node_config is None:
            node_config = NODE_CONFIG
        # ... logic của hàm cũ giữ nguyên ...
        try:
            # Trích xuất dữ liệu từ API response
            data = api_response.get('data', {})
            task_list = data.get('task_list', [])
            configured_node_ids = list(node_config.keys())
            
            # Tạo map để tra cứu nhanh trạng thái của các node
            node_status_map = {}
            for task in task_list:
                node_id = task.get('node_id')
                status = task.get('status', 'UNKNOWN')
                if node_id:
                    node_status_map[node_id] = status
            
            print(f"🔍 Đang kiểm tra các node với điều kiện bổ sung:")
            for node_id, config in node_config.items():
                required_status = config.get('required_status', 'PENDING')
                additional_conditions = config.get('additional_conditions', [])
                print(f"   • {node_id[:8]}... - {config['name']} (yêu cầu: {required_status})")
                if additional_conditions:
                    for condition in additional_conditions:
                        print(f"     + Điều kiện thêm: {condition['node_id'][:8]}... phải ở trạng thái {condition['required_status']}")
            
            print(f"📋 Danh sách task chứa {len(task_list)} nhiệm vụ")
            
            matching_configured_nodes = []
            
            # Duyệt qua từng node đã cấu hình
            for node_id in configured_node_ids:
                config = node_config[node_id]
                required_status = config.get('required_status', 'PENDING')
                current_status = node_status_map.get(node_id, 'NOT_FOUND')
                
                # Kiểm tra điều kiện chính
                if current_status != required_status:
                    continue
                    
                # Kiểm tra các điều kiện bổ sung
                additional_conditions = config.get('additional_conditions', [])
                all_conditions_met = True
                
                for condition in additional_conditions:
                    condition_node_id = condition['node_id']
                    condition_required_status = condition['required_status']
                    condition_current_status = node_status_map.get(condition_node_id, 'NOT_FOUND')
                    
                    print(f"🔍 Kiểm tra điều kiện bổ sung: {condition_node_id[:8]}... ")
                    print(f"   Yêu cầu: {condition_required_status}, Hiện tại: {condition_current_status}")
                    
                    if condition_current_status != condition_required_status:
                        all_conditions_met = False
                        print(f"❌ Điều kiện bổ sung không đáp ứng cho {node_id[:8]}...")
                        break
                    else:
                        print(f"✅ Điều kiện bổ sung đã đáp ứng")
                
                # Nếu tất cả điều kiện đều thỏa mãn
                if all_conditions_met:
                    matching_configured_nodes.append({
                        'node_id': node_id,
                        'config': config,
                        'strategy': config['strategy'],
                        'matched_status': current_status,
                        'required_status': required_status,
                        'additional_conditions_met': True
                    })
                    print(f"✅ Tìm thấy node phù hợp: {node_id[:8]}... ({config['name']}) - Trạng thái: {current_status}")
            
            # Trả về node phù hợp đầu tiên
            if matching_configured_nodes:
                first_matching = matching_configured_nodes[0]
                return {
                    'found': True,
                    'node_id': first_matching['node_id'],
                    'node_config': first_matching['config'],
                    'strategy': first_matching['strategy'],
                    'matched_status': first_matching['matched_status'],
                    'required_status': first_matching['required_status'],
                    'all_tasks': task_list,
                    'all_matching_configured': matching_configured_nodes,
                    'node_status_map': node_status_map
                }
            else:
                print(f"❌ Không tìm thấy node nào đáp ứng tất cả điều kiện")
                return {
                    'found': False,
                    'node_id': None,
                    'node_config': None,
                    'strategy': None,
                    'matched_status': None,
                    'all_tasks': task_list,
                    'all_matching_configured': [],
                    'node_status_map': node_status_map
                }
            
        except Exception as e:
            print(f"❌ Lỗi khi kiểm tra node: {e}")
            return {
                'found': False,
                'error': str(e),
                'all_tasks': [],
                'all_matching_configured': []
            }


    def validate_amount_value(self, amount_value) -> dict:
        """
        Validate và chuyển đổi giá trị số tiền.
        """
        try:
            if amount_value is None:
                return {'valid': False, 'amount': None, 'error': 'Số tiền không được để trống'}
            
            amount_float = float(amount_value)
            amount_int = int(amount_float)
            
            if amount_int <= 0:
                return {'valid': False, 'amount': amount_int, 'error': 'Số tiền phải lớn hơn 0'}
                
            return {'valid': True, 'amount': amount_int, 'error': None}
            
        except (ValueError, TypeError) as e:
            return {'valid': False, 'amount': None, 'error': f'Định dạng số tiền không hợp lệ: {str(e)}'}

    async def process_approval_with_qr_comment(self, instance_code: str, access_token: str) -> bool:
        """
        Xử lý phê duyệt với tạo QR code và comment (phiên bản nâng cấp hỗ trợ nhiều lần tạm ứng).
        """
        try:
            # Bước 1: Lấy thông tin chi tiết của instance
            api_response = await lark_service.get_approval_instance(instance_code, access_token)
            if not api_response or 'data' not in api_response:
                print(f"❌ Không thể lấy thông tin instance {instance_code}")
                return False
            
            task_list = api_response['data'].get('task_list', [])
            form_str = api_response['data'].get('form', '[]')
            form_data = json.loads(form_str)

            # --- [LOGIC MỚI] Bắt đầu phần tìm kiếm lần tạm ứng hoạt động ---
            
            # 2.1: Tìm tất cả các node "Thủ quỹ chi tiền tạm ứng" trong quy trình
            cashier_nodes = [task for task in task_list if "Thủ quỹ chi tiền tạm ứng" in task.get('node_name', '')]
            print(f"🔍 Tìm thấy {len(cashier_nodes)} node 'Thủ quỹ chi tiền tạm ứng' trong quy trình.")

            active_advance_info = None
            
            # 2.2: Lặp qua các node thủ quỹ để tìm node đang PENDING
            for i, node in enumerate(cashier_nodes, 1):
                node_id = node.get('node_id')
                node_status = node.get('status')
                print(f"   - Kiểm tra lần tạm ứng {i} (Node ID: {node_id[:8]}..., Trạng thái: {node_status})...")

                # Điều kiện 1: Node phải ở trạng thái PENDING
                if node_status == 'PENDING':
                    # Điều kiện 2: Người dùng phải chọn "Yes" cho lần tạm ứng tương ứng
                    yes_no_field_name = f"Thanh toán tạm ứng lần {i}: Y/N"
                    amount_field_name = f"Số tiền tạm ứng lần {i}:"

                    yes_no_value = self.field_extractor.extract_field_value(form_data, yes_no_field_name)
                    
                    if yes_no_value == "Yes":
                        print(f"     ✅ Điều kiện thỏa mãn: Node PENDING và người dùng chọn 'Yes'.")
                        amount_value = self.field_extractor.extract_field_value(form_data, amount_field_name)
                        
                        active_advance_info = {
                            "amount": amount_value,
                            "node_id": node_id,
                            "node_name": node.get('node_name'),
                            "qr_type": "advance",
                            "field_used": amount_field_name,
                            "advance_round": i
                        }
                        print(f"     ➡️ Lần tạm ứng {i} được kích hoạt với số tiền: {amount_value}")
                        break # Tìm thấy rồi thì dừng lại
                    else:
                        print(f"     - Bỏ qua: Người dùng không chọn 'Yes' cho lần {i} (Giá trị: {yes_no_value}).")
                else:
                    print(f"     - Bỏ qua: Trạng thái node không phải PENDING.")

            # 2.3: Xử lý kết quả tìm kiếm
            if not active_advance_info:
                print(f"⏭️  Không có lần tạm ứng nào đang hoạt động (PENDING và được chọn 'Yes'). Bỏ qua tạo QR.")
                return True # Coi như thành công vì đã xử lý đúng (bỏ qua)

            # --- [LOGIC MỚI] Kết thúc phần tìm kiếm ---


            # --- [PHẦN GIỮ NGUYÊN] Tiếp tục xử lý với thông tin đã tìm được ---

            # Lấy các biến từ kết quả tìm kiếm
            matching_node_id = active_advance_info['node_id']
            qr_type = active_advance_info['qr_type']
            amount_value = active_advance_info['amount']
            field_used = active_advance_info['field_used']
            node_name = active_advance_info['node_name']
            
            # Bước 5: Kiểm tra duplicate TRƯỚC KHI tạo QR
            if cache_service.is_qr_recently_generated(
                instance_code, matching_node_id, qr_type, 
                settings.QR_CACHE_DURATION_MINUTES
            ):
                print(f"⚠️ PHÁT HIỆN TRÙNG LẶP: QR {qr_type.upper()} cho node {node_name} đã được tạo gần đây.")
                print(f"   → BỎ QUA tạo QR để tránh trùng lặp.")
                return True
            
            print(f"💰 Chi tiết tạo QR cho lần tạm ứng {active_advance_info['advance_round']}:")
            print(f"   - Loại: {qr_type}")
            print(f"   - Số tiền: {amount_value}")
            print(f"   - Trường sử dụng: {field_used}")
            print(f"   - Node kích hoạt: {node_name} ({matching_node_id[:8]}...)")
            
            # Bước 6: Validate số tiền
            amount_validation = self.validate_amount_value(amount_value)
            if not amount_validation['valid']:
                print(f"❌ Số tiền không hợp lệ: {amount_validation['error']}")
                return False
                
            amount_int = amount_validation['amount']

            # Bước 7: Trích xuất thông tin ngân hàng
            bank_id = self.field_extractor.extract_field_value(form_data, FFN.BANK_NAME)
            account_no = self.field_extractor.extract_field_value(form_data, FFN.BANK_ACCOUNT_NUMBER)
            account_name = self.field_extractor.extract_field_value(form_data, FFN.BENEFICIARY_NAME)

            if not all([bank_id, account_no, account_name]):
                missing = [f for f, v in {FFN.BANK_NAME: bank_id, FFN.BANK_ACCOUNT_NUMBER: account_no, FFN.BENEFICIARY_NAME: account_name}.items() if not v]
                print(f"❌ Thiếu thông tin ngân hàng: {', '.join(missing)}")
                return False
            
            # Bước 8: Tạo mô tả QR theo loại
            description = vietqr_service.generate_qr_description(f"{qr_type}{active_advance_info['advance_round']}", instance_code)
            
            print(f"🏦 Tạo VietQR với thông tin:")
            print(f"   - Ngân hàng: {bank_id}")
            print(f"   - Số tài khoản: {account_no}")
            print(f"   - Tên người nhận: {account_name}")
            print(f"   - Số tiền: {amount_int:,} VND")
            print(f"   - Mô tả: {description}")
            
            # Bước 9: Tạo VietQR code trong bộ nhớ
            qr_image_buffer = vietqr_service.create_qr_in_memory(
                bank_id=bank_id,
                account_no=account_no,
                amount=amount_int,
                description=description,
                account_name=account_name
            )
            
            if not qr_image_buffer:
                print("❌ Không thể tạo mã VietQR")
                return False
            
            # Bước 10: Upload ảnh lên Lark Approval
            filename = f"{instance_code}_{qr_type}{active_advance_info['advance_round']}_qr.png"
            upload_result = await lark_service.upload_image_to_approval(qr_image_buffer, filename, access_token)
            
            if not upload_result['success']:
                print(f"❌ Upload thất bại: {upload_result['error']}")
                return False
            
            # Bước 11: Đánh dấu đã tạo QR SAU KHI upload thành công
            cache_service.mark_qr_as_generated(instance_code, matching_node_id, qr_type)
            
            # Bước 12: Tạo comment nâng cao với thông tin chi tiết
            comment_result = await lark_service.create_enhanced_comment_with_image(
                instance_code=instance_code,
                file_url=upload_result['file_url'],
                file_code=upload_result['file_code'],
                filename=filename,
                qr_type=f"{qr_type} Lần {active_advance_info['advance_round']}", # Làm rõ hơn trong comment
                amount=amount_int,
                node_name=node_name,
                access_token=access_token
            )
            
            if comment_result['success']:
                print(f"✅ Hoàn thành xử lý phê duyệt {instance_code}")
                print(f"💰 Loại: {qr_type.upper()} LẦN {active_advance_info['advance_round']} | Số tiền: {amount_int:,} VND")
                print(f"🏷️ Node: {node_name}")
                print(f"📋 Trường: {field_used}")
                print(f"💬 ID Comment: {comment_result['comment_id']}")
                return True
            else:
                print(f"❌ Tạo comment thất bại: {comment_result['error']}")
                return False
                
        except Exception as e:
            print(f"❌ Lỗi xử lý phê duyệt: {e}")
            import traceback
            traceback.print_exc()
            return False

qr_processor = QRProcessor()
============================================================

============================================================
FILE: app\domains\qr_generation\services\vietqr_service.py
============================================================
import requests
from urllib.parse import quote
from PIL import Image
from io import BytesIO
from app.core.config.settings import settings
from app.domains.qr_generation.models import QRType


class VietQRService:
    """
    Dịch vụ tạo mã QR thanh toán VietQR.
    
    Class này cung cấp các chức năng để tạo mã QR VietQR thông qua API,
    xử lý hình ảnh và tạo mô tả phù hợp cho từng loại giao dịch.
    
    VietQR là hệ thống thanh toán QR code chuẩn của Việt Nam, cho phép
    tạo mã QR chứa thông tin ngân hàng, số tiền và nội dung chuyển khoản.
    
    Attributes:
        base_url (str): URL cơ sở của VietQR API từ settings
    """

    def __init__(self):
        """Khởi tạo VietQRService với URL API từ cấu hình."""
        self.base_url = settings.VIETQR_BASE_URL
    
    def create_qr_in_memory(self, bank_id: str, account_no: str, amount: int, 
                           description: str, account_name: str, 
                           template: str = None) -> BytesIO:
        """
        Tạo mã QR VietQR với thông tin thanh toán và trả về dữ liệu ảnh trong bộ nhớ.
        
        Phương thức này sẽ:
        1. Tạo URL request đến VietQR API với các tham số đã mã hóa
        2. Gửi HTTP request để lấy hình ảnh QR
        3. Xử lý hình ảnh bằng PIL (chuyển đổi format nếu cần)
        4. Trả về BytesIO object chứa dữ liệu PNG
        
        Args:
            bank_id (str): Mã ngân hàng (ví dụ: 970422 cho MB Bank)
            account_no (str): Số tài khoản thụ hưởng
            amount (int): Số tiền giao dịch (đơn vị: VND)
            description (str): Nội dung chuyển khoản (sẽ được mã hóa URL)
            account_name (str): Tên chủ tài khoản (sẽ được mã hóa URL)
            template (str, optional): Template QR. Defaults to settings.VIETQR_TEMPLATE
        
        Returns:
            BytesIO: Dữ liệu ảnh QR dạng PNG trong bộ nhớ, hoặc None nếu có lỗi
            
        Raises:
            requests.exceptions.RequestException: Lỗi khi gọi API
            PIL.UnidentifiedImageError: Lỗi khi xử lý hình ảnh
        """
        # Sử dụng template mặc định nếu không được chỉ định
        if template is None:
            template = settings.VIETQR_TEMPLATE
        
        # Mã hóa URL cho các tham số tiếng Việt để tránh lỗi encoding
        encoded_desc = quote(description)
        encoded_name = quote(account_name)
        
        # Tạo URL request theo format của VietQR API
        url = (f"{self.base_url}/{bank_id}-{account_no}-{template}.jpg?"
               f"amount={amount}&addInfo={encoded_desc}&accountName={encoded_name}")
        
        print(f"🌐 URL VietQR: {url}")
        
        try:
            # Gửi HTTP GET request với timeout để tránh treo
            print(f"📡 Đang gửi yêu cầu tạo QR đến VietQR API...")
            response = requests.get(url, timeout=10)
            response.raise_for_status()  # Raise exception nếu HTTP status code không thành công
            
            print(f"✅ Nhận được dữ liệu QR từ API ({len(response.content)} bytes)")
            
            # Mở và xử lý hình ảnh từ response content
            image = Image.open(BytesIO(response.content))
            print(f"🖼️ Đã tải ảnh QR - Kích thước: {image.size}, Mode: {image.mode}")
            
            # Chuyển đổi sang RGB nếu ảnh có mode không tương thích với PNG
            # RGBA (có alpha channel), LA (grayscale + alpha), P (palette mode)
            if image.mode in ('RGBA', 'LA', 'P'):
                print(f"🔄 Chuyển đổi ảnh từ mode {image.mode} sang RGB")
                image = image.convert('RGB')
            
            # Tạo BytesIO buffer để lưu ảnh PNG
            img_buffer = BytesIO()
            image.save(img_buffer, format='PNG')
            img_buffer.seek(0)  # Reset con trở về đầu buffer để đọc từ đầu
            
            print(f"✅ Tạo mã VietQR thành công trong bộ nhớ")
            print(f"📦 Kích thước buffer: {img_buffer.getbuffer().nbytes} bytes")
            return img_buffer
            
        except requests.exceptions.Timeout:
            print(f"⏰ Timeout khi gọi VietQR API (quá 10 giây)")
            return None
        except requests.exceptions.ConnectionError:
            print(f"🔌 Lỗi kết nối đến VietQR API")
            return None
        except requests.exceptions.HTTPError as e:
            print(f"🚫 Lỗi HTTP từ VietQR API: {e}")
            print(f"    Status code: {response.status_code}")
            return None
        except requests.exceptions.RequestException as e:
            print(f"❌ Lỗi request khi gọi VietQR API: {e}")
            return None
        except Exception as e:
            print(f"❌ Lỗi không xác định khi xử lý VietQR: {e}")
            return None

    def generate_qr_description(self, qr_type: str, instance_code: str) -> str:
        """
        Tạo mô tả (nội dung chuyển khoản) cho mã QR dựa trên loại giao dịch.
        
        Mô tả sẽ được hiển thị trong nội dung chuyển khoản của ngân hàng,
        giúp người nhận dễ dàng nhận biết mục đích giao dịch.
        
        Args:
            qr_type (str): Loại QR code ('advance', 'payment', hoặc giá trị khác)
            instance_code (str): Mã đơn phê duyệt để tham chiếu
            
        Returns:
            str: Nội dung mô tả cho QR code
            
        Examples:
            >>> generate_qr_description('advance', 'AP123456')
            'Tam ung don AP123456'
            
            >>> generate_qr_description('payment', 'AP123456') 
            'Thanh toan don AP123456'
            
            >>> generate_qr_description('other', 'AP123456')
            'Don AP123456'
        """
        # Xác định mô tả dựa trên loại QR
        if qr_type == 'advance':
            description = f"Tam ung don {instance_code}"
            print(f"📝 Tạo mô tả QR tạm ứng: {description}")
        elif qr_type == 'payment':
            description = f"Thanh toan don {instance_code}"
            print(f"📝 Tạo mô tả QR thanh toán: {description}")
        else:
            # Fallback cho các loại khác
            description = f"Don {instance_code}"
            print(f"📝 Tạo mô tả QR chung: {description}")
            
        return description

vietqr_service = VietQRService()
============================================================

============================================================
FILE: app\domains\validation\__init__.py
============================================================
# app/domains/validation/__init__.py
from .models import *
from .services import *
from .handlers import *

__all__ = [
    # Models
    "ValidationType", "ValidationResult", "ValidationResponse",
    # Services
    "validation_service",
    # Handlers  
    "validation_event_handler"
]

============================================================

============================================================
FILE: app\domains\validation\handlers\__init__.py
============================================================
from .validation_event_handler import validation_event_handler

__all__ = ["validation_event_handler"]

============================================================

============================================================
FILE: app\domains\validation\handlers\validation_event_handler.py
============================================================
"""
Validation Event Handler - Bộ xử lý sự kiện validation cho hệ thống phê duyệt
"""
from typing import Dict, List, Optional
import json
from app.domains.validation.services import validation_service
from app.core.infrastructure import lark_service
from app.domains.notification.services import lark_webhook_service
from app.core.infrastructure import cache_service

class ValidationEventHandler:
    """
    Bộ xử lý sự kiện validation cho hệ thống phê duyệt.
    
    Class này chịu trách nhiệm:
    1. Nhận và xử lý các sự kiện phê duyệt để validation
    2. Chạy các quy tắc validation trên dữ liệu form và workflow
    3. Gửi cảnh báo qua webhook khi phát hiện vấn đề
    4. Ngăn chặn duplicate alerts để tránh spam notification
    5. Xử lý lỗi và gửi error alerts khi cần thiết
    
    Attributes:
        name (str): Tên định danh của service
        webhook_service: Service gửi webhook notifications
    """
    
    def __init__(self):
        """Khởi tạo ValidationEventHandler với webhook service."""
        self.name = "Validation_Service"
        self.webhook_service = lark_webhook_service

    async def handle_approval_event(self, event_data: Dict) -> Dict:
        """
        Xử lý sự kiện phê duyệt để thực hiện validation với cơ chế anti-spam nâng cao.

        [NÂNG CẤP] Bổ sung logic kiểm tra trạng thái đơn. Sẽ bỏ qua xử lý
        nếu đơn ở trạng thái cuối cùng như REJECTED, CANCELED, DELETED.
        
        Quy trình xử lý mới:
        1. Lấy dữ liệu instance từ Lark.
        2. Chạy tất cả các validation rules.
        3. Lọc ra các kết quả không hợp lệ (invalid).
        4. **[LOGIC MỚI]** Lặp qua từng lỗi không hợp lệ:
            a. Dùng `validation_type` cụ thể của lỗi để kiểm tra cache.
            b. Nếu lỗi chưa được cache, thêm nó vào danh sách cần gửi cảnh báo.
        5. Nếu có lỗi cần cảnh báo, gửi một webhook duy nhất chứa tất cả các lỗi mới.
        6. **[LOGIC MỚI]** Sau khi gửi, ghi cache cho từng loại lỗi đã được cảnh báo.
        """
        instance_code = event_data.get('instance_code')
        if not instance_code:
            return {"success": False, "message": "Không tìm thấy instance_code", "service": self.name}

        try:
            # [THÊM MỚI] Bắt đầu khối logic kiểm tra trạng thái
            FINAL_STATUSES = ['REJECTED', 'CANCELED', 'DELETED']

            # Trích xuất trạng thái từ dữ liệu gốc của sự kiện để tránh gọi API không cần thiết
            raw_data = event_data.get('raw_data', {})
            instance_status = raw_data.get('event', {}).get('object', {}).get('status')

            # Nếu không có trong payload, thì tìm trong event body
            event_body = raw_data.get('event', {})
            if not instance_status:
                instance_status = event_body.get('status')


            # Kiểm tra xem trạng thái của đơn có nằm trong danh sách cần bỏ qua không
            if instance_status and instance_status in FINAL_STATUSES:
                print(f"⏭️ [Validation Handler] Bỏ qua instance {instance_code} do có trạng thái cuối cùng: {instance_status}")
                return {
                    "success": True, # Coi như thành công vì đã xử lý đúng (bỏ qua)
                    "message": f"Bỏ qua validation do trạng thái đơn là {instance_status}",
                    "instance_code": instance_code,
                    "webhook_sent": False, # Không có webhook nào được gửi
                    "service": self.name
                }
            # [THÊM MỚI] Kết thúc khối logic kiểm tra trạng thái

            print(f"🔍 [Validation Handler] Dịch vụ Validation đang xử lý: {instance_code} (Trạng thái: {instance_status or 'N/A'})")
            
            # Bước 1 & 2: Lấy dữ liệu từ Lark
            access_token = await lark_service.get_access_token()
            if not access_token:
                return {"success": False, "message": "Không thể lấy access token", "service": self.name}

            api_response = await lark_service.get_approval_instance(instance_code, access_token)
            if not api_response or 'data' not in api_response:
                return {"success": False, "message": "Không thể lấy dữ liệu instance", "service": self.name}
            
            serial_number = api_response.get('data', {}).get('serial_number')
            form_data = json.loads(api_response['data'].get('form', '[]'))
            task_list = api_response['data'].get('task_list', [])
            
            # Bước 3: Chạy validations và lọc ra các lỗi
            validation_results = validation_service.run_all_validations(
                form_data, task_list, "dummy_node_id" # node_id có thể cần được truyền vào từ event_data nếu logic yêu cầu
            )
            invalid_results = [r for r in validation_results if not r.is_valid]
            
            if not invalid_results:
                print("✅ [Validation Handler] Tất cả validation đều thành công.")
                return {
                    "success": True, "message": "Tất cả validation đều thành công",
                    "webhook_sent": False, "webhook_skipped_count": 0,
                    "service": self.name
                }
            
            # --- PHẦN LOGIC ANTI-SPAM ĐƯỢC THAY THẾ HOÀN TOÀN ---
            # Bước 4: Lọc ra các cảnh báo chưa được gửi (chưa có trong cache)
            alerts_to_send = []
            skipped_count = 0
            
            print(f"⚠️ [Validation Handler] Phát hiện {len(invalid_results)} vấn đề. Đang kiểm tra cache anti-spam...")
            for result in invalid_results:
                # TẠO CACHE KEY CỤ THỂ CHO TỪNG LỖI
                # Dùng hash của message để đảm bảo mỗi lỗi là duy nhất
                specific_error_key = f"{result.validation_type.value}_{hash(result.message)}"
                
                if cache_service.is_validation_alert_recently_sent(
                    instance_code, specific_error_key, cache_duration_minutes=10
                ):
                    print(f"  🔄 Bỏ qua (đã cache): {result.message[:80]}...") # Log một phần message
                    skipped_count += 1
                else:
                    print(f"  🆕 Cần gửi cảnh báo cho: {result.message[:80]}...")
                    alerts_to_send.append(result)

            # Bước 5: Gửi webhook nếu có cảnh báo mới cần gửi
            webhook_sent = False
            if alerts_to_send:
                error_messages = [r.message for r in alerts_to_send]
                print(f"📨 [Validation Handler] Đang gửi {len(error_messages)} cảnh báo mới qua webhook...")
                
                webhook_sent = await self._send_validation_alert(instance_code, error_messages, serial_number)
                
                # Bước 6: Nếu gửi thành công, ghi cache cho từng lỗi đã gửi
                if webhook_sent:
                    print("✅ [Validation Handler] Gửi webhook thành công. Đang cập nhật cache...")
                    for result in alerts_to_send:
                        # DÙNG LẠI CACHE KEY CỤ THỂ ĐÃ TẠO Ở TRÊN
                        specific_error_key = f"{result.validation_type.value}_{hash(result.message)}"
                        cache_service.mark_validation_alert_as_sent(instance_code, specific_error_key)
                        print(f"  🔒 Đã cache cho: {result.message[:80]}...")
                else:
                    print("❌ [Validation Handler] Gửi webhook thất bại.")
            else:
                print("✅ [Validation Handler] Không có cảnh báo mới nào cần gửi. Tất cả đã được cache.")

            return {
                "success": True,
                "message": f"Hoàn thành validation. {len(alerts_to_send)} cảnh báo mới đã được gửi. {skipped_count} cảnh báo bị bỏ qua do cache.",
                "alerts_sent_count": len(alerts_to_send),
                "webhook_sent": webhook_sent,
                "webhook_skipped_count": skipped_count,
                "validation_details": [r.dict() for r in validation_results],
                "service": self.name
            }
            
        except Exception as e:
            # Xử lý lỗi hệ thống (giữ nguyên logic cũ)
            print(f"❌ [Validation Handler] Lỗi nghiêm trọng trong Validation Service: {str(e)}")
            # ... (phần xử lý lỗi này có thể giữ nguyên hoặc cải tiến sau)
            return {
                "success": False,
                "message": f"Lỗi Validation Service: {str(e)}",
                "service": self.name
            }

    async def _send_validation_alert(self, instance_code: str, error_messages: List[str], serial_number: Optional[str]) -> bool:
        """Gửi cảnh báo validation qua webhook service."""
        try:
            from app.domains.notification.models import ValidationAlertRequest, NotificationPriority
            request = ValidationAlertRequest(
                instance_code=instance_code,
                serial_number=serial_number,
                validation_errors=error_messages,
                priority=NotificationPriority.HIGH
            )
            result = await self.webhook_service.send_validation_alert(request)
            return result.success
        except Exception as e:
            print(f"❌ Lỗi khi gửi validation alert: {e}")
            return False

    async def _send_error_alert(self, instance_code: str, error_message: str) -> bool:
        """Gửi cảnh báo lỗi hệ thống qua webhook service."""
        try:
            # Logic này hiện không được dùng trong luồng chính nhưng giữ lại để có thể dùng sau
            result = await self.webhook_service.send_custom_alert(
                title="LỖI VALIDATION SERVICE",
                message=f"Lỗi xử lý validation cho {instance_code}: {error_message}",
                instance_code=instance_code
            )
            return result.success
        except Exception as e:
            print(f"❌ Lỗi khi gửi error alert: {e}")
            return False


validation_event_handler = ValidationEventHandler()
============================================================

============================================================
FILE: app\domains\validation\models\__init__.py
============================================================
from .validation import (
    ValidationType,
    ValidationStatus,
    ValidationResult,
    ValidationRequest,
    ValidationResponse
)

__all__ = [
    "ValidationType",
    "ValidationStatus", 
    "ValidationResult",
    "ValidationRequest",
    "ValidationResponse"
]

============================================================

============================================================
FILE: app\domains\validation\models\validation.py
============================================================
from pydantic import BaseModel
from typing import Optional, Dict, Any, List
from enum import Enum


class ValidationType(str, Enum):
    AMOUNT_SUM = "amount_sum_validation"

    ADVANCE_AMOUNT_MISMATCH = "advance_amount_mismatch"      # Tạm ứng
    PAYMENT_AMOUNT_MISMATCH = "payment_amount_mismatch"      # Thanh toán  
    TOTAL_AMOUNT_MISMATCH = "total_amount_mismatch"          # Tổng amount
    
    WORKFLOW_STATUS = "workflow_status_validation" 
    FIELD_CONSISTENCY = "field_consistency_validation"
    PAYMENT_CONSISTENCY = "payment_consistency_validation"
    TOTAL_PAYMENT_VALIDATION = "total_payment_validation"


class ValidationStatus(str, Enum):
    VALID = "valid"
    INVALID = "invalid"
    SKIPPED = "skipped"
    ERROR = "error"


class ValidationResult(BaseModel):
    """Enhanced validation result model with proper enums"""
    is_valid: bool
    validation_type: ValidationType
    status: ValidationStatus
    message: str
    details: Optional[Dict[str, Any]] = None
    
    @classmethod
    def create_valid(cls, validation_type: ValidationType, message: str, details: Dict = None):
        return cls(
            is_valid=True,
            validation_type=validation_type,
            status=ValidationStatus.VALID,
            message=message,
            details=details or {}
        )
    
    @classmethod
    def create_invalid(cls, validation_type: ValidationType, message: str, details: Dict = None):
        return cls(
            is_valid=False,
            validation_type=validation_type,
            status=ValidationStatus.INVALID,
            message=message,
            details=details or {}
        )
    
    @classmethod
    def create_skipped(cls, validation_type: ValidationType, message: str, details: Dict = None):
        return cls(
            is_valid=True,  # Skipped is not a failure
            validation_type=validation_type,
            status=ValidationStatus.SKIPPED,
            message=message,
            details=details or {}
        )
    
    @classmethod
    def create_error(cls, validation_type: ValidationType, message: str, details: Dict = None):
        return cls(
            is_valid=False,
            validation_type=validation_type,
            status=ValidationStatus.ERROR,
            message=message,
            details=details or {}
        )


class ValidationRequest(BaseModel):
    instance_code: str
    form_data: List[Dict[str, Any]]
    task_list: List[Dict[str, Any]]
    node_id: Optional[str] = None


class ValidationResponse(BaseModel):
    success: bool
    instance_code: str
    validation_results: List[ValidationResult]
    invalid_count: int
    total_validations: int
    alerts_sent: bool = False
    webhook_sent: bool = False
    message: Optional[str] = None
============================================================

============================================================
FILE: app\domains\validation\routers\notification.py
============================================================
from fastapi import APIRouter
from app.domains.notification.models import NotificationRequest, NotificationResult
from app.domains.notification.services.notification_coordinator import notification_coordinator

router = APIRouter(prefix="/notification", tags=["Notification"])

@router.post("/send", response_model=NotificationResult)
async def send_notification(request: NotificationRequest):
    """Manual gửi notification"""
    return await notification_coordinator.send_notification(request)

@router.get("/channels")
async def get_notification_channels():
    """Xem danh sách notification channels"""
    from app.domains.notification.models import NotificationChannel, NotificationType
    return {
        "channels": [ch.value for ch in NotificationChannel],
        "types": [nt.value for nt in NotificationType],
        "supported_combinations": {
            "lark_webhook": ["validation_alert", "custom_alert", "service_error"]
        }
    }

@router.get("/cache/status")
async def get_notification_cache_status():
    """Xem trạng thái notification cache"""
    from app.core.infrastructure.cache_service import cache_service
    cache_status = cache_service.get_cache_status()
    return cache_status.get('validation_cache', {})

============================================================

============================================================
FILE: app\domains\validation\routers\validation.py
============================================================
from fastapi import APIRouter
from app.domains.validation.models import ValidationRequest, ValidationResponse
from app.domains.validation.services.validation_service import validation_service

router = APIRouter(prefix="/validation", tags=["Validation"])

@router.post("/validate", response_model=ValidationResponse)
async def validate_instance(request: ValidationRequest):
    """Manual validation của một instance"""
    try:
        # Chạy validations
        validation_results = validation_service.run_all_validations(
            request.form_data, 
            request.task_list, 
            request.node_id or "manual_validation"
        )
        
        invalid_count = len([r for r in validation_results if not r.is_valid])
        
        return ValidationResponse(
            success=True,
            instance_code=request.instance_code,
            validation_results=validation_results,
            invalid_count=invalid_count,
            total_validations=len(validation_results),
            message=f"Completed {len(validation_results)} validations, {invalid_count} issues found"
        )
        
    except Exception as e:
        return ValidationResponse(
            success=False,
            instance_code=request.instance_code,
            validation_results=[],
            invalid_count=0,
            total_validations=0,
            message=f"Validation error: {str(e)}"
        )

@router.get("/rules")
async def get_validation_rules():
    """Xem danh sách validation rules"""
    from app.domains.validation.models import ValidationType
    return {
        "available_rules": [vt.value for vt in ValidationType],
        "total_rules": len(ValidationType)
    }

============================================================

============================================================
FILE: app\domains\validation\services\__init__.py
============================================================
# app/domains/validation/services/__init__.py
from .validation_service import validation_service

__all__ = ["validation_service"]

============================================================

============================================================
FILE: app\domains\validation\services\validation_service.py
============================================================
"""
Validation Service - Dịch vụ domain cho các quy tắc validation
"""
from typing import Dict, List, Any, Optional
from app.domains.validation.models import ValidationResult, ValidationType, ValidationStatus
from app.core.utils.field_extractor import FieldExtractor
from app.core.config.field_constants import FFN

class ValidationService:
    """
    Dịch vụ validation cho hệ thống phê duyệt.
    
    Class này cung cấp các quy tắc validation khác nhau để kiểm tra
    tính nhất quán và hợp lệ của dữ liệu trong quy trình phê duyệt:
    
    - ADVANCE_AMOUNT_MISMATCH: So sánh tổng số tiền tạm ứng
    - PAYMENT_AMOUNT_MISMATCH: So sánh số tiền thanh toán
    - TOTAL_AMOUNT_MISMATCH: Kiểm tra tổng số tiền thanh toán
    - WORKFLOW_STATUS: Kiểm tra trạng thái node
    - FIELD_CONSISTENCY: Kiểm tra logic giữa các trường
    
    Mỗi validation sẽ trả về ValidationResult với một trong các trạng thái:
    - VALID: Validation pass
    - INVALID: Validation fail  
    - SKIPPED: Bỏ qua do thiếu dữ liệu
    - ERROR: Có lỗi trong quá trình validation
    
    Attributes:
        field_extractor (FieldExtractor): Công cụ trích xuất dữ liệu từ form
        validation_rules (Dict): Map từ validation type đến method tương ứng
    """
    
    def __init__(self):
        """Khởi tạo ValidationService với field extractor và mapping rules."""
        self.field_extractor = FieldExtractor()
        
        self.validation_rules = {
            ValidationType.ADVANCE_AMOUNT_MISMATCH: self.validate_advance_amount_mismatch,
            ValidationType.PAYMENT_AMOUNT_MISMATCH: self.validate_payment_amount_mismatch,
            #ValidationType.TOTAL_AMOUNT_MISMATCH: self.validate_total_amount_mismatch,
            ValidationType.WORKFLOW_STATUS: self.validate_workflow_status,
            ValidationType.FIELD_CONSISTENCY: self.validate_field_consistency,
        }
    
    # Thay vì trả về ValidationResult, giờ đây hàm sẽ trả về List[ValidationResult]
    def validate_advance_amount_mismatch(self, form_data: List[Dict], **kwargs) -> List[ValidationResult]:
        """
        Trả về một danh sách các ValidationResult, mỗi result cho một lỗi.
        """
        try:
            accountant_expenditures = self.field_extractor.extract_all_values_from_fieldlist(
                form_data, FFN.ACCOUNTING_ADVANCE_INFO, FFN.EXPENDITURE_AMOUNT
            )
            
            results = []
            found_data = False

            for i in range(1, 5): # Chỉ kiểm tra 4 lần
                user_advance_field = f"Số tiền tạm ứng lần {i}:"
                user_advance_value = self.field_extractor.extract_field_value(form_data, user_advance_field)
                
                if user_advance_value is not None:
                    found_data = True

                if (i - 1) >= len(accountant_expenditures) or user_advance_value is None:
                    continue
                
                accountant_expenditure_value = accountant_expenditures[i-1]
                
                try:
                    user_amount = float(user_advance_value)
                    accountant_amount = float(accountant_expenditure_value)
                    
                    if abs(user_amount - accountant_amount) >= 0.01:
                        message = (f"❌ Lỗi Tạm ứng Lần {i}: Yêu cầu ({user_amount:,.0f}) ≠ Kế toán chi ({accountant_amount:,.0f}). "
                                f"Lệch: {abs(user_amount - accountant_amount):,.0f} VND")
                        # Tạo một result riêng cho lỗi này
                        results.append(ValidationResult.create_invalid(ValidationType.ADVANCE_AMOUNT_MISMATCH, message))
                except (ValueError, TypeError):
                    message = f"❌ Lỗi định dạng số Tạm ứng Lần {i}."
                    results.append(ValidationResult.create_invalid(ValidationType.ADVANCE_AMOUNT_MISMATCH, message))

            # Nếu không có lỗi nào được tìm thấy và có dữ liệu để kiểm tra
            if not results and found_data:
                results.append(ValidationResult.create_valid(
                    ValidationType.ADVANCE_AMOUNT_MISMATCH,
                    "✅ Tất cả các lần tạm ứng đã khớp."
                ))
            
            # Nếu không có dữ liệu để kiểm tra
            if not found_data:
                results.append(ValidationResult.create_skipped(
                    ValidationType.ADVANCE_AMOUNT_MISMATCH,
                    "ℹ️ Bỏ qua: Không tìm thấy dữ liệu tạm ứng để so sánh."
                ))
            
            return results
                
        except Exception as e:
            return [ValidationResult.create_error(
                ValidationType.ADVANCE_AMOUNT_MISMATCH,
                f"❌ Lỗi hệ thống khi validation tiền tạm ứng: {e}",
            )]

    def validate_payment_amount_mismatch(self, form_data: List[Dict], **kwargs) -> ValidationResult:
        """
        Validation tính nhất quán số tiền thanh toán (giữ nguyên logic cũ).
        
        So sánh "Kế toán - Thông tin thanh toán" với "Số tiền còn phải thanh toán" 
        hoặc "Số tiền thanh toán".
        """
        try:
            payment_info_amount = self.field_extractor.extract_field_from_fieldlist(
                form_data,  FFN.ACCOUNTING_PAYMENT_INFO, FFN.EXPENDITURE_AMOUNT
            )
            amount_due = self.field_extractor.extract_field_value(
                form_data,  FFN.REMAINING_PAYMENT_AMOUNT
            )
            amount_paid = self.field_extractor.extract_field_value(
                form_data, FFN.PAYMENT_AMOUNT
            )
            
            compare_amount = amount_due if amount_due is not None else amount_paid
            compare_field_name = FFN.REMAINING_PAYMENT_AMOUNT if amount_due is not None else FFN.PAYMENT_AMOUNT

            if payment_info_amount is None or compare_amount is None:
                return ValidationResult.create_skipped(
                    ValidationType.PAYMENT_AMOUNT_MISMATCH,
                    "ℹ️ Bỏ qua: Không tìm thấy đủ các trường về số tiền thanh toán để so sánh."
                )

            payment_info_float = float(payment_info_amount)
            compare_amount_float = float(compare_amount)

            if abs(payment_info_float - compare_amount_float) < 0.01:
                return ValidationResult.create_valid(
                    ValidationType.PAYMENT_AMOUNT_MISMATCH,
                    f"✅ Số tiền thanh toán nhất quán: {payment_info_float:,.0f} VND"
                )
            else:
                message = (f"❌ Lỗi thanh toán: 'Kế toán' ({payment_info_float:,.0f}) ≠ "
                           f"'{compare_field_name}' ({compare_amount_float:,.0f}). "
                           f"Chênh lệch: {abs(payment_info_float - compare_amount_float):,.0f} VND")
                details = {"payment_info_amount": payment_info_float, "compare_amount": compare_amount_float}
                return ValidationResult.create_invalid(ValidationType.PAYMENT_AMOUNT_MISMATCH, message, details)
        except (ValueError, TypeError) as e:
            return ValidationResult.create_error(
                ValidationType.PAYMENT_AMOUNT_MISMATCH, f"❌ Lỗi định dạng số tiền thanh toán: {e}",
            )
        except Exception as e:
            return ValidationResult.create_error(
                ValidationType.PAYMENT_AMOUNT_MISMATCH, f"❌ Lỗi không xác định khi validation tiền thanh toán: {e}",
            )

    def validate_total_amount_mismatch(self, form_data: List[Dict], **kwargs) -> ValidationResult:
        """
        Validation tổng số tiền thanh toán dựa trên các khoản chi đã được kế toán xác nhận.
        
        Công thức: Total = (Tổng các khoản chi trong FieldList "Kế toán - Thông tin tạm ứng") + (Số tiền còn phải thanh toán).
        """
        try:
            # Lấy tổng các khoản chi tạm ứng THỰC TẾ từ kế toán
            accountant_expenditures = self.field_extractor.extract_all_values_from_fieldlist(
                form_data, FFN.ACCOUNTING_ADVANCE_INFO, FFN.EXPENDITURE_AMOUNT
            )
            total_accountant_advance = sum(float(v) for v in accountant_expenditures if v is not None and str(v).strip() != '')

            # Lấy các trường còn lại
            amount_due = self.field_extractor.extract_field_value(form_data, FFN.REMAINING_PAYMENT_AMOUNT)
            total_payment_actual = self.field_extractor.extract_field_value(form_data, FFN.TOTAL_PAYMENT_AMOUNT)

            if total_accountant_advance == 0 and amount_due is None:
                return ValidationResult.create_skipped(
                    ValidationType.TOTAL_AMOUNT_MISMATCH,
                    f"ℹ️ Bỏ qua: Kế toán chưa điền thông tin chi hoặc số tiền còn lại."
                )

            if total_payment_actual is None:
                return ValidationResult.create_skipped(
                    ValidationType.TOTAL_AMOUNT_MISMATCH,
                    f"ℹ️ Bỏ qua: Không tìm thấy trường '{FFN.TOTAL_PAYMENT_AMOUNT}' để tính tổng."
                )

            amount_due_float = float(amount_due) if amount_due is not None else 0.0
            total_actual_float = float(total_payment_actual)
            
            total_expected = total_accountant_advance + amount_due_float

            if abs(total_expected - total_actual_float) < 0.01:
                return ValidationResult.create_valid(
                    ValidationType.TOTAL_AMOUNT_MISMATCH,
                    f"✅ Tổng số tiền hợp lệ: {total_actual_float:,.0f} VND"
                )
            else:
                case_description = f"Tổng Kế toán chi ({total_accountant_advance:,.0f}) + Còn Lại ({amount_due_float:,.0f})"
                message = (f"❌ Lỗi tổng tiền: Thực tế ({total_actual_float:,.0f}) ≠ "
                        f"Dự kiến ({total_expected:,.0f} từ {case_description}). "
                        f"Chênh lệch: {abs(total_expected - total_actual_float):,.0f} VND")
                details = {
                    "total_expected": total_expected, 
                    "total_actual": total_actual_float,
                    "total_accountant_advance": total_accountant_advance,
                    "remaining_payment": amount_due_float
                }
                return ValidationResult.create_invalid(ValidationType.TOTAL_AMOUNT_MISMATCH, message, details)
        except (ValueError, TypeError) as e:
            return ValidationResult.create_error(
                ValidationType.TOTAL_AMOUNT_MISMATCH, f"❌ Lỗi định dạng số khi tính tổng tiền: {e}",
            )
        except Exception as e:
            return ValidationResult.create_error(
                ValidationType.TOTAL_AMOUNT_MISMATCH, f"❌ Lỗi không xác định khi validation tổng tiền: {e}",
            )
    
    def validate_workflow_status(self, task_list: List[Dict], node_id: str, **kwargs) -> ValidationResult:
        """
        Validation trạng thái workflow để phát hiện node bị thu hồi.
        """
        try:
            target_node = next((task for task in task_list if task.get('node_id') == node_id), None)
            
            if not target_node:
                return ValidationResult.create_skipped(
                    ValidationType.WORKFLOW_STATUS,
                    f"ℹ️ Bỏ qua: Node {node_id[:8]}... không tìm thấy trong danh sách task"
                )
            
            current_status = target_node.get('status', 'UNKNOWN')
            problematic_statuses = ['REJECTED', 'CANCELED', 'WITHDRAWN']
            if current_status in problematic_statuses:
                return ValidationResult.create_invalid(
                    ValidationType.WORKFLOW_STATUS,
                    f"⚠️ CẢNH BÁO: Node {node_id[:8]}... có trạng thái {current_status} - có thể đã bị thu hồi hoặc từ chối"
                )
            
            return ValidationResult.create_valid(
                ValidationType.WORKFLOW_STATUS,
                f"✅ Node {node_id[:8]}... có trạng thái bình thường: {current_status}"
            )
        except Exception as e:
            return ValidationResult.create_error(
                ValidationType.WORKFLOW_STATUS,
                f"❌ Lỗi kiểm tra trạng thái workflow: {str(e)}"
            )
    
    def validate_field_consistency(self, form_data: List[Dict], **kwargs) -> ValidationResult:
        """
        Placeholder cho các logic validation về tính nhất quán của các trường khác.
        """
        return ValidationResult.create_valid(
            ValidationType.FIELD_CONSISTENCY,
            "✅ Kiểm tra tính nhất quán các trường thành công (placeholder)"
        )
    
    def run_validation(self, validation_type: ValidationType, **kwargs) -> ValidationResult:
        """
        Chạy một quy tắc validation cụ thể.
        """
        if validation_type in self.validation_rules:
            return self.validation_rules[validation_type](**kwargs)
        else:
            return ValidationResult.create_error(
                validation_type,
                f"❌ Loại validation không xác định: {validation_type}"
            )
    
    def run_all_validations(self, form_data: List[Dict], task_list: List[Dict], 
                           node_id: str) -> List[ValidationResult]:
        """
        Chạy tất cả các validation rules đã được đăng ký.
        """
        print(f"🚀 Bắt đầu chạy tất cả validation cho node {node_id[:8]}...")
        results = []
        
        for validation_type in self.validation_rules.keys():
            print(f"▶️ Đang chạy: {validation_type.value}...")
            # Sử dụng extend để xử lý việc một rule có thể trả về nhiều result
            validation_func = self.validation_rules[validation_type]
            
            # Cần kiểm tra xem hàm có trả về list hay không
            # Vì các hàm khác vẫn trả về 1 result đơn lẻ
            result_or_list = validation_func(
                form_data=form_data,
                task_list=task_list,
                node_id=node_id
            )

            if isinstance(result_or_list, list):
                results.extend(result_or_list)
            else:
                results.append(result_or_list)

        invalid_count = sum(1 for r in results if not r.is_valid)
        print(f"📈 Hoàn thành validation: Tìm thấy {invalid_count} vấn đề.")
        
        return results

validation_service = ValidationService()
============================================================

============================================================
FILE: README.md
============================================================
1. Lark Platform ──POST──► handle_lark_webhook()
                              │
2. Extract & Filter ◄─────────┤
                              │
3. event_bus.publish("approval.instance.updated", data)
                              │
4. EventBus ◄─────────────────┘
    │
    ├─ Save to event_history[]
    │
    ├─ Find registered handlers for "approval.instance.updated"
    │
    └─ asyncio.gather() ──┬──► _run_handler_safe(qr_handler, data)
                          │      │
                          │      └──► QRHandler.handle() ──► Generate QR
                          │
                          └──► _run_handler_safe(validation_handler, data)  
                                 │
                                 └──► ValidationHandler.handle() ──► Send Alert
5. Results ──► Log success/failure cho mỗi handler



4. EventBus ──► asyncio.gather() ──┬──► _run_handler_safe(qr_handler, data)
                                   │      │
                                   │      └──► QRHandler.handle() 
                                   │             │
                                   │             ▼
                                   │      ┌─────────────────────────────┐
                                   │      │    QR Generation Flow       │
                                   │      ├─────────────────────────────┤
                                   │      │ 1. Extract instance_code    │
                                   │      │    ↓                        │
                                   │      │ 2. lark_service.get_instance(instance_code)
                                   │      │    ↓ (API Call)             │
                                   │      │ 3. Lark API ──► Instance Data
                                   │      │    ↓                        │
                                   │      │ 4. Check NODE_CONFIG        │
                                   │      │    ├─ Valid Node? ──► Continue
                                   │      │    └─ Invalid? ──► Skip & Return
                                   │      │    ↓                        │
                                   │      │ 5. cache_service.check()    │
                                   │      │    key: "qr:{instance}:{node}"
                                   │      │    ├─ Exists? ──► Skip (Duplicate)
                                   │      │    └─ Not exists? ──► Continue
                                   │      │    ↓                        │
                                   │      │ 6. amount_detector.extract()│
                                   │      │    ──► Parse amount from form
                                   │      │    ↓                        │
                                   │      │ 7. vietqr_service.generate()│
                                   │      │    ──► VietQR API Call     │
                                   │      │    ──► Get QR image bytes  │
                                   │      │    ↓                        │
                                   │      │ 8. lark_service.upload_image()
                                   │      │    ──► Lark API ──► file_code
                                   │      │    ↓                        │
                                   │      │ 9. lark_service.post_comment()
                                   │      │    ──► Post QR to approval  │
                                   │      │    ↓                        │
                                   │      │10. cache_service.set()      │
                                   │      │    ──► Mark QR created (15min TTL)
                                   │      │    ↓                        │
                                   │      │✅ Return success            │
                                   │      └─────────────────────────────┘
                                   │
                                   └──► _run_handler_safe(validation_handler, data)
                                          │
                                          └──► ValidationHandler.handle()
                                                 │
                                                 ▼
                                        ┌─────────────────────────────┐
                                        │   Validation & Alert Flow   │
                                        ├─────────────────────────────┤
                                        │ 1. Extract instance_code    │
                                        │    ↓                        │
                                        │ 2. lark_service.get_instance()
                                        │    ↓ (API Call)             │
                                        │ 3. Lark API ──► Instance Data
                                        │    ↓                        │
                                        │ 4. validation_service.validate()
                                        │    ├─ Check amount consistency
                                        │    ├─ Verify required fields│
                                        │    ├─ Business rule validation
                                        │    └─ Return errors[]       │
                                        │    ↓                        │
                                        │ 5. Check validation results │
                                        │    ├─ No errors? ──► Skip & Return
                                        │    └─ Has errors? ──► Continue
                                        │    ↓                        │
                                        │ 6. cache_service.check()    │
                                        │    key: "alert:{instance}:{hash}"
                                        │    ├─ Exists? ──► Skip (Duplicate)
                                        │    └─ Not exists? ──► Continue
                                        │    ↓                        │
                                        │ 7. notification_coordinator.send()
                                        │    ──► Format alert message │
                                        │    ↓                        │
                                        │ 8. lark_webhook_service.send()
                                        │    ──► Call Lark Bot API   │
                                        │    ──► Send to user/group  │
                                        │    ↓                        │
                                        │ 9. cache_service.set()      │
                                        │    ──► Mark alert sent (15min TTL)
                                        │    ↓                        │
                                        │✅ Return success            │
                                        └─────────────────────────────┘
============================================================

============================================================
FILE: requirements.txt
============================================================
fastapi==0.104.1
uvicorn[standard]==0.24.0
requests==2.31.0
pandas==2.1.3
Pillow==10.1.0
python-multipart==0.0.6
pydantic==2.5.0

============================================================


📊 THỐNG KÊ
------------------------------
Tổng số file: 53
File code: 49
Các loại file code:
  .md: 1 file
  .py: 46 file
  .txt: 2 file
